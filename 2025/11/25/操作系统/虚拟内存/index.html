<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="什么是虚拟内存 虚拟内存 &#x3D; 让每个进程看到一片连续的大地址空间，并由操作系统自动把它映射到真实、碎片化的物理内存中，从而解决内存不够用、内存碎片和进程隔离的问题。   虚拟内存主要有两种形式一种是内存分段（早期提出，现在很少使用），一种是内存分页（目前普遍流行的） 内存分段 虚拟内存 &#x3D; 让每个进程看到一片连续的大地址空间，并由系统自动把它映射到真实、碎片化的物理内存中，从而">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟内存">
<meta property="og:url" content="http://example.com/2025/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:description" content="什么是虚拟内存 虚拟内存 &#x3D; 让每个进程看到一片连续的大地址空间，并由操作系统自动把它映射到真实、碎片化的物理内存中，从而解决内存不够用、内存碎片和进程隔离的问题。   虚拟内存主要有两种形式一种是内存分段（早期提出，现在很少使用），一种是内存分页（目前普遍流行的） 内存分段 虚拟内存 &#x3D; 让每个进程看到一片连续的大地址空间，并由系统自动把它映射到真实、碎片化的物理内存中，从而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763610082037-65d6b47e-ad47-4de7-a5dd-564dae0ee8ee.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763610545559-4fc22978-89e3-4815-81b4-1d94f8bea46f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763611538345-cb28a6db-b441-42f6-a404-05bed414cd70.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763611848903-05c7b0a8-c833-490b-9a95-3b48db4c3ab2.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763612282612-7c17d021-0f4a-4e60-83be-0c162c133333.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763613007279-a81a4306-2753-4233-b7b4-02bc3f48a88c.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763624150432-d6b97759-caff-40e2-adb2-c3fc7a43523c.png">
<meta property="article:published_time" content="2025-11-25T13:31:54.808Z">
<meta property="article:modified_time" content="2025-11-25T13:40:27.008Z">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763610082037-65d6b47e-ad47-4de7-a5dd-564dae0ee8ee.png">


<link rel="canonical" href="http://example.com/2025/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","path":"2025/11/25/操作系统/虚拟内存/","title":"虚拟内存"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>虚拟内存 | 刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">刘翰霖</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">什么是虚拟内存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="nav-number">2.</span> <span class="nav-text">内存分段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">2.1.</span> <span class="nav-text">内存碎片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E7%9A%84%E5%A4%96%E9%83%A8%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%9D%A5%E8%A7%A3%E5%86%B3"><span class="nav-number">2.1.1.</span> <span class="nav-text">对于内存分段的外部内存碎片问题，可以使用内存交换来解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%95%88%E7%8E%87%E4%BD%8E"><span class="nav-number">2.2.</span> <span class="nav-text">内存交换效率低</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="nav-number">3.</span> <span class="nav-text">内存分页</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%88%86%E6%AE%B5%E7%9A%84%E3%80%8C%E5%A4%96%E9%83%A8%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%92%8C%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%95%88%E7%8E%87%E4%BD%8E%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%98%AF%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84%E7%9A%84%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">分页机制下，虚拟地址和物理地址是如何映射的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.</span> <span class="nav-text">多级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BA%86%E4%BA%8C%E7%BA%A7%E8%A1%A8%EF%BC%8C%E6%98%A0%E5%B0%84-4GB-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B0%B1%E9%9C%80%E8%A6%81-4KB%EF%BC%88%E4%B8%80%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%89-4MB%EF%BC%88%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%89%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E4%B8%8D%E6%98%AF%E6%9B%B4%E5%A4%A7%E4%BA%86%E5%90%97%EF%BC%9F"><span class="nav-number">3.3.1.</span> <span class="nav-text">分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%88%86%E7%BA%A7%E7%9A%84%E7%AE%80%E5%8D%95%E9%A1%B5%E8%A1%A8%E4%B8%8D%E8%83%BD%E6%8C%89%E9%9C%80%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="nav-number">3.3.2.</span> <span class="nav-text">为什么不分级的简单页表不能按需创建？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TLB"><span class="nav-number">3.4.</span> <span class="nav-text">TLB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">4.</span> <span class="nav-text">linux 内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#inux-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%AA%E2%80%9C%E6%AE%B5%E2%80%9D"><span class="nav-number">4.1.</span> <span class="nav-text">inux 如何判断一个虚拟地址属于哪个“段”</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="虚拟内存 | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          虚拟内存
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h1><p> 虚拟内存 &#x3D; 让每个进程看到一片连续的大地址空间，并由操作系统自动把它映射到真实、碎片化的物理内存中，从而解决内存不够用、内存碎片和进程隔离的问题。  </p>
<p>虚拟内存主要有两种形式一种是内存分段（早期提出，现在很少使用），一种是内存分页（目前普遍流行的）</p>
<h1 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h1><p> 虚拟内存 &#x3D; 让每个进程看到一片连续的大地址空间，并由系统自动把它映射到真实、碎片化的物理内存中，从而解决内存不够用、内存碎片和进程隔离的问题。  </p>
<p>分段划分，本质上就是通过一个段表进行虚拟地址-&gt;真实地址的映射</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763610082037-65d6b47e-ad47-4de7-a5dd-564dae0ee8ee.png"></p>
<p>分段划分会有两个问题</p>
<ul>
<li>内存碎片</li>
<li>内存交换的效率低</li>
</ul>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p><font style="color:rgb(44, 62, 80);">我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</font></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">游戏占用了 512MB 内存</font></li>
<li><font style="color:rgb(44, 62, 80);">浏览器占用了 128MB 内存</font></li>
<li><font style="color:rgb(44, 62, 80);">音乐占用了 256 MB 内存。</font></li>
</ul>
<p><font style="color:rgb(44, 62, 80);">这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。</font></p>
<p><font style="color:rgb(44, 62, 80);">如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763610545559-4fc22978-89e3-4815-81b4-1d94f8bea46f.png"></p>
<p><strong>分段会产生“外部碎片”，不会产生“内部碎片”。</strong></p>
<ul>
<li><strong>不会产生内部碎片：</strong><br>分段按“真实需求大小”整体分配，只有找到能容纳整个段的连续空间才会分配，因此不会出现“分配多余空间被浪费”的情况。</li>
<li><strong>会产生外部碎片：</strong><br>由于段大小不固定、必须连续，内存中会形成许多小的、彼此不连续的空洞，可能导致后续大的段无法放入，进而产生外部碎片。</li>
</ul>
<h3 id="对于内存分段的外部内存碎片问题，可以使用内存交换来解决"><a href="#对于内存分段的外部内存碎片问题，可以使用内存交换来解决" class="headerlink" title="对于内存分段的外部内存碎片问题，可以使用内存交换来解决"></a>对于内存分段的外部内存碎片问题，可以使用内存交换来解决</h3><p><font style="color:rgb(44, 62, 80);">可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</font></p>
<h2 id="内存交换效率低"><a href="#内存交换效率低" class="headerlink" title="内存交换效率低"></a><font style="color:rgb(44, 62, 80);">内存交换效率低</font></h2><p>由于内存分段很容易产生外部内存碎片，所以我们不得不进行大量的内存交换，而内存交换涉及到磁盘io效率很低</p>
<h1 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h1><p><strong><font style="color:rgb(48, 79, 254);">分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</font></strong><font style="color:rgb(44, 62, 80);">。这样一个连续并且尺寸固定的内存空间，我们叫</font><strong><font style="color:rgb(48, 79, 254);">页</font></strong><font style="color:rgb(44, 62, 80);">（</font><em><font style="color:rgb(200, 73, 255);">Page</font></em><font style="color:rgb(44, 62, 80);">）。在 Linux 下，每一页的大小为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;4KB&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);">。虚拟地址与物理地址之间通过</font><strong><font style="color:rgb(48, 79, 254);">页表</font></strong><font style="color:rgb(44, 62, 80);">来映射，如下图：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763611538345-cb28a6db-b441-42f6-a404-05bed414cd70.png"></p>
<p><font style="color:rgb(44, 62, 80);">页表是存储在内存里的，</font><strong><font style="color:rgb(48, 79, 254);">内存管理单元</font></strong><font style="color:rgb(44, 62, 80);"> （</font><em><font style="color:rgb(200, 73, 255);">MMU（计算机硬件）</font></em><font style="color:rgb(44, 62, 80);">）就做将虚拟内存地址转换成物理地址的工作。</font></p>
<h2 id="分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"><a href="#分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？" class="headerlink" title="分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？"></a>分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？</h2><p><strong>1. 分页不会有外部碎片</strong><br>内存被预先划分成大小固定的页（如 4KB），页与页紧密排列，因此不会出现“不连续的小空洞”。</p>
<p><strong>2. 分页会有内部碎片</strong><br>内存分配的最小单位是页，即使程序只用到几百字节，也必须分配整页，所以会产生内部碎片。</p>
<p><strong>3. 分页的换入换出效率更高</strong><br>当内存不足时，操作系统只需将“近期未使用的少量页面”换出到磁盘，再按需将这些页面换入，而不是移动整个大段，因此交换开销更小。</p>
<p><strong>4. 分页支持按需加载</strong><br>程序启动时无需一次性加载所有内容，只需建立虚拟页与物理页的映射，程序运行到需要某个虚拟页时，再触发缺页中断并把对应页加载到内存即可。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763611848903-05c7b0a8-c833-490b-9a95-3b48db4c3ab2.png"></p>
<h2 id="分页机制下，虚拟地址和物理地址是如何映射的？"><a href="#分页机制下，虚拟地址和物理地址是如何映射的？" class="headerlink" title="分页机制下，虚拟地址和物理地址是如何映射的？"></a>分页机制下，虚拟地址和物理地址是如何映射的？</h2><p><font style="color:rgb(44, 62, 80);">在分页机制下，虚拟地址分为两部分，</font><strong><font style="color:rgb(48, 79, 254);">页号</font></strong><font style="color:rgb(44, 62, 80);">和</font><strong><font style="color:rgb(48, 79, 254);">页内偏移</font></strong><font style="color:rgb(44, 62, 80);">。页号作为页表的索引，</font><strong><font style="color:rgb(48, 79, 254);">页表</font></strong><font style="color:rgb(44, 62, 80);">包含物理页每页所在</font><strong><font style="color:rgb(48, 79, 254);">物理内存的基地址</font></strong><font style="color:rgb(44, 62, 80);">，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</font></p>
<font style="color:rgb(44, 62, 80);">  
</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2025/png/50543647/1763612066346-bc916948-fa43-48be-8fe2-b1a0ff5cb937.png)

<p><font style="color:rgb(44, 62, 80);">总结一下，对于一个内存地址转换，其实就是这样三个步骤：</font></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">把虚拟内存地址，切分成页号和偏移量；</font></li>
<li><font style="color:rgb(44, 62, 80);">根据页号，从页表里面，查询对应的物理页号；</font></li>
<li><font style="color:rgb(44, 62, 80);">直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</font></li>
</ul>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a><font style="color:rgb(44, 62, 80);">多级页表</font></h2><p>对于只有一个页表的简单分页</p>
<ul>
<li>每个进程都有独立的虚拟地址空间，因此每个进程都需要自己的页表。</li>
<li>以 <strong>32 位系统</strong>为例：虚拟空间 4GB、页大小 4KB → 需要约 <strong>100 万个页</strong>。</li>
<li>每个页表项 4 字节 → 一个完整页表大小约 <strong>4MB</strong>。</li>
<li>一个进程 4MB 看似不大，但 <strong>100 个进程就要 400MB</strong> 内存仅用于存页表。</li>
<li>在 64 位环境下虚拟地址空间更大，页表会更巨大。</li>
</ul>
<p>为了解决空间问题，就引入了多级页表</p>
<p><font style="color:rgb(44, 62, 80);">对于32位操作系统我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1024&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 个页表（二级页表），每个表（二级页表）中包含 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1024&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 个「页表项」，形成</font><strong><font style="color:rgb(48, 79, 254);">二级分页</font></strong><font style="color:rgb(44, 62, 80);">。如下图所示：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763612282612-7c17d021-0f4a-4e60-83be-0c162c133333.png"></p>
<h3 id="分了二级表，映射-4GB-地址空间就需要-4KB（一级页表）-4MB（二级页表）的内存，这样占用空间不是更大了吗？"><a href="#分了二级表，映射-4GB-地址空间就需要-4KB（一级页表）-4MB（二级页表）的内存，这样占用空间不是更大了吗？" class="headerlink" title="分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？"></a>分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？</h3><ul>
<li>虽然虚拟地址空间是 4GB，但进程实际只使用其中很小的一部分，所以绝大多数页表项始终是空的。</li>
<li>如果只使用一级页表，就必须一次性构建覆盖整个 4GB 空间的页表（约 4MB），而且每个进程都要有一份，这会造成巨大浪费。</li>
<li>二级页表的做法是：一级页表仍覆盖整个虚拟空间，但只有当某个一级页表项被访问时，才按需创建对应的二级页表。</li>
<li>一级页表始终存在（大小约 4KB）</li>
<li>二级页表“用到哪一块虚拟空间就创建哪一块”，未访问的区域不占用页表内存</li>
</ul>
<p><em>对于64位操作系统我们一般会使用四级页表</em></p>
<h3 id="为什么不分级的简单页表不能按需创建？"><a href="#为什么不分级的简单页表不能按需创建？" class="headerlink" title="为什么不分级的简单页表不能按需创建？"></a>为什么不分级的简单页表不能按需创建？</h3><p> 因为简单页表承担的是“直接把虚拟页号映射到页表项”的工作，它必须完整存在，否则 MMU 无法完成地址转换。  <font style="color:rgb(44, 62, 80);">所以</font><strong>页表一定要覆盖全部虚拟地址空间</strong></p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p> 根据局部性原理，程序在短时间内会频繁访问相同的地址区域。所以在cpu 芯片中加入了一个<font style="color:rgb(44, 62, 80);">专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（</font><em><font style="color:rgb(200, 73, 255);">Translation Lookaside Buffer</font></em><font style="color:rgb(44, 62, 80);">） ，</font>  <font style="color:rgb(44, 62, 80);">通常称为页表缓存、转址旁路缓存、快表等。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763613007279-a81a4306-2753-4233-b7b4-02bc3f48a88c.png"></p>
<p>CPU 内部集成了内存管理单元（MMU），负责地址转换，并与 TLB 协同工作。</p>
<p>有了 TLB 后，CPU 查地址时会<strong>先查 TLB</strong>；如果命中，则无需访问页表；如果未命中，再去查正常的页表。</p>
<p>由于程序具有局部性，常访问的页通常只有少数几个，所以 TLB 的命中率往往非常高。</p>
<h1 id="linux-内存布局"><a href="#linux-内存布局" class="headerlink" title="linux 内存布局"></a>linux 内存布局</h1><p>linux 内存布局是采用思想上分段，实现上分页</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763624150432-d6b97759-caff-40e2-adb2-c3fc7a43523c.png"></p>
<h3 id="inux-如何判断一个虚拟地址属于哪个“段”"><a href="#inux-如何判断一个虚拟地址属于哪个“段”" class="headerlink" title="inux 如何判断一个虚拟地址属于哪个“段”"></a>inux 如何判断一个虚拟地址属于哪个“段”</h3><p><strong>判断一个地址属于哪个“段”不是看页号，也不是硬件段表，而是查 VMA（虚拟内存区域）。</strong></p>
<ul>
<li>每个进程维护一组 VMA（vm_area_struct）</li>
<li>每个 VMA 对应一个区间，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0x00400000, 0x00500000] → 代码段</span><br><span class="line">[0x00600000, 0x00680000] → 数据段/BSS</span><br><span class="line">[0x08000000, 0x09000000] → 堆</span><br><span class="line">[0x7ffdxxxx, 0x7fffffff] → 栈</span><br></pre></td></tr></table></figure>

<ul>
<li>查询逻辑：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址 ∈ 哪个 VMA 区间 → 所属的逻辑段</span><br></pre></td></tr></table></figure>

<p><em>VMA本质上是一个红黑树数据结构</em></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/11/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7hash/" rel="prev" title="一致性hash">
                  <i class="fa fa-angle-left"></i> 一致性hash
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" rel="next" title="零拷贝">
                  零拷贝 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
