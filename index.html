<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="刘翰霖">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">刘翰霖</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/WebSocket/%E7%BD%91%E7%BB%9C/WebSocket/websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/WebSocket/%E7%BD%91%E7%BB%9C/WebSocket/websocket/" class="post-title-link" itemprop="url">websocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/WebSocket/" itemprop="url" rel="index"><span itemprop="name">WebSocket</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>WebSocket</strong> 是一种基于 <strong>TCP</strong> 的<strong>全双工通信协议</strong>，允许客户端和服务器之间建立<strong>持续连接</strong>，双方都可以随时主动发送数据。</p>
<table>
<thead>
<tr>
<th>通信模式</th>
<th>特点</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单工通信</strong></td>
<td>只能单向传输，A → B，B 不能回传</td>
<td>广播、电视</td>
</tr>
<tr>
<td><strong>半双工通信</strong></td>
<td>双方都能传输，但不能同时进行</td>
<td>对讲机（你说完我再说）</td>
</tr>
<tr>
<td><strong>全双工通信</strong></td>
<td>双方可以同时发送与接收数据</td>
<td>电话、WebSocket、TCP</td>
</tr>
</tbody></table>
<h2 id="为什么要有websocket"><a href="#为什么要有websocket" class="headerlink" title="为什么要有websocket"></a>为什么要有websocket</h2><h3 id="http的局限性"><a href="#http的局限性" class="headerlink" title="http的局限性"></a>http的局限性</h3><ol>
<li>传统的 HTTP 协议是单向的——浏览器必须先发起请求，服务器才能返回响应。</li>
<li>若想实现双向通信，只能通过轮询的方式不断请求服务器，这不仅延迟高，还会造成大量资源浪费。</li>
</ol>
<p>websocket的优点</p>
<h3 id="websocket的优势"><a href="#websocket的优势" class="headerlink" title="websocket的优势"></a>websocket的优势</h3><ul>
<li>WebSocket 允许<strong>客户端与服务器之间建立持久、全双工</strong>的连接。</li>
<li>一旦连接建立，双方可以随时互发数据，不再需要反复建立连接。</li>
</ul>
<h2 id="Websocket是基于Http-协议的么"><a href="#Websocket是基于Http-协议的么" class="headerlink" title="Websocket是基于Http 协议的么"></a>Websocket是基于Http 协议的么</h2><p> ✅ <strong>WebSocket 只在“建立连接”时依赖 HTTP&#x2F;1.1 协议</strong>，<br>🚫 <strong>一旦连接建立成功后，就不再使用 HTTP&#x2F;1.1 协议，而是切换为独立的 WebSocket 协议</strong>。  </p>
<h3 id="握手阶段（基于HTTP协议）"><a href="#握手阶段（基于HTTP协议）" class="headerlink" title="握手阶段（基于HTTP协议）"></a>握手阶段（基于HTTP协议）</h3><p> 在最初阶段，客户端想与服务器建立 WebSocket 连接时，<br>它必须先发一个 <strong>HTTP&#x2F;1.1 请求</strong> 来请求“协议升级”，称为 <strong>HTTP Upgrade 握手</strong>。  </p>
<h3 id="举个例子👇"><a href="#举个例子👇" class="headerlink" title="举个例子👇"></a>举个例子👇</h3><p>客户端发送：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761183691824-17b6d7d1-cbe1-433f-9435-3e09b07f3176.png"></p>
<p>🧠 关键点：</p>
<ul>
<li><code>Upgrade: websocket</code> 表示请求升级到 WebSocket 协议。</li>
<li><code>Connection: Upgrade</code> 表示这个连接要切换协议。</li>
<li><code>Sec-WebSocket-Key</code> 是一个随机字符串，服务器会根据它计算返回值用于验证。</li>
</ul>
<p> 服务器返回：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761183733215-5035dbe3-8f6f-4177-9d33-011c9ea38f54.png"></p>
<p>这条 <code>101 Switching Protocols</code> 响应代表：</p>
<p>🔁 <strong>HTTP 连接已成功升级为 WebSocket 连接</strong></p>
<h3 id="通信阶段（脱离HTTP，使用WebSocket-协议）"><a href="#通信阶段（脱离HTTP，使用WebSocket-协议）" class="headerlink" title="通信阶段（脱离HTTP，使用WebSocket 协议）"></a>通信阶段（脱离HTTP，使用WebSocket 协议）</h3><p> 握手成功后，这个 TCP 连接<strong>不再使用 HTTP 报文格式</strong>，<br>而是完全切换到 <strong>WebSocket 专属的帧格式</strong>（Frame-based Protocol）。  </p>
<p>也就是说：</p>
<ul>
<li>不再有 HTTP 头；</li>
<li>不再有请求-响应模式；</li>
<li>客户端和服务端都能主动发送消息；</li>
<li>使用二进制帧封装数据（包含 opcode、mask、payload 等字段）。</li>
</ul>
<h4 id="WebSocket-数据帧的基本结构"><a href="#WebSocket-数据帧的基本结构" class="headerlink" title="WebSocket 数据帧的基本结构"></a>WebSocket 数据帧的基本结构</h4><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FIN</td>
<td>是否是最后一帧</td>
</tr>
<tr>
<td>Opcode</td>
<td>数据类型（文本、二进制、ping、pong）</td>
</tr>
<tr>
<td>Mask</td>
<td>客户端到服务端数据需掩码</td>
</tr>
<tr>
<td>Payload length</td>
<td>数据长度</td>
</tr>
<tr>
<td>Payload data</td>
<td>真实数据</td>
</tr>
</tbody></table>
<h3 id="从网络层角度看"><a href="#从网络层角度看" class="headerlink" title="从网络层角度看"></a>从网络层角度看</h3><table>
<thead>
<tr>
<th>层级</th>
<th>WebSocket 所处位置</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>WebSocket 协议（建立在 HTTP 之上）</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP（保持长连接）</td>
</tr>
<tr>
<td>网络层</td>
<td>IP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>以太网、Wi-Fi 等</td>
</tr>
</tbody></table>
<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>使用的协议</th>
<th>是否基于 HTTP</th>
</tr>
</thead>
<tbody><tr>
<td>握手阶段</td>
<td>HTTP (Upgrade)</td>
<td>✅ 是</td>
</tr>
<tr>
<td>握手成功后</td>
<td>WebSocket</td>
<td>❌ 否</td>
</tr>
</tbody></table>
<h2 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h2><table>
<thead>
<tr>
<th>模块</th>
<th>作用</th>
<th>关键概念</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣ 数据帧（Frame）</td>
<td>最小传输单元</td>
<td>Text Frame &#x2F; Binary Frame &#x2F; Control Frame</td>
</tr>
<tr>
<td>2️⃣ 消息（Message）</td>
<td>一个完整的逻辑信息（可能由多个帧组成）</td>
<td>分片（Fragmentation）</td>
</tr>
<tr>
<td>3️⃣ 心跳机制（Ping &#x2F; Pong）</td>
<td>保持连接活性</td>
<td>防止空闲连接被中断</td>
</tr>
<tr>
<td>4️⃣ 关闭连接（Close Frame）</td>
<td>优雅地断开连接</td>
<td>状态码与关闭原因</td>
</tr>
<tr>
<td>5️⃣ 错误与重连</td>
<td>保证稳定性</td>
<td>reconnect 策略</td>
</tr>
</tbody></table>
<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p> WebSocket 不像 HTTP 那样传输纯文本，而是<strong>基于“帧”来通信</strong>。一条 WebSocket 消息由一个或多个帧组成，每个帧中包含：  </p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>FIN</td>
<td>是否是最后一帧（1 表示是）</td>
</tr>
<tr>
<td>OPCODE</td>
<td>表示帧类型（0x1 文本，0x2 二进制，0x8 关闭，0x9 ping，0xA pong）</td>
</tr>
<tr>
<td>MASK</td>
<td>是否启用掩码（客户端发的都必须加掩码）</td>
</tr>
<tr>
<td>Payload length</td>
<td>数据长度</td>
</tr>
<tr>
<td>Payload data</td>
<td>实际数据</td>
</tr>
</tbody></table>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>一条消息（Message）可以拆成多个帧（Frame）发送。<br>这叫 <strong>分片（Fragmentation）</strong>。</p>
<p>例如：</p>
<ul>
<li>发送 10MB 的大文件 → 分为多个帧发送（前几帧 FIN&#x3D;0，最后一帧 FIN&#x3D;1）</li>
<li>这样做能边传边解析，提高实时性</li>
</ul>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p> WebSocket 是<strong>长连接</strong>，但中间网络设备可能在长时间无数据时断开连接。为此，协议定义了两个控制帧：  </p>
<ul>
<li><code>Ping</code>：由一方发送，用来确认连接是否还活着；</li>
<li><code>Pong</code>：对方收到后立刻回应。</li>
</ul>
<p>👉 常见做法：</p>
<ul>
<li>服务端每隔 30 秒发送一次 Ping；</li>
<li>若 3 次未收到 Pong，就认为连接断开。</li>
</ul>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>WebSocket 关闭连接也要遵守协议流程：</p>
<ol>
<li>一方发送 <strong>Close 帧（opcode&#x3D;0x8）</strong>；</li>
<li>另一方收到后也回一个 <strong>Close 帧</strong>；</li>
<li>双方都关闭 TCP 通道。</li>
</ol>
<h3 id="异常断开"><a href="#异常断开" class="headerlink" title="异常断开"></a>异常断开</h3><p> 如果出现异常断开（比如网络掉线），前端通常会：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761205571637-e52f3b3a-b0b0-4d6c-935d-ec9cef5e9557.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761205578634-d54fee65-954e-4651-bf54-b74972a8d224.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/WebSocket/%E7%BD%91%E7%BB%9C/WebSocket/springboot_websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/WebSocket/%E7%BD%91%E7%BB%9C/WebSocket/springboot_websocket/" class="post-title-link" itemprop="url">springboot websocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/WebSocket/" itemprop="url" rel="index"><span itemprop="name">WebSocket</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring Boot 提供了两种方式来实现 WebSocket 通信：</p>
<ol>
<li><strong>基于 WebSocketHandler 的底层开发方式</strong><ul>
<li>使用 <code>@EnableWebSocket</code> + <code>WebSocketConfigurer</code> 注册自定义 <code>WebSocketHandler</code>。</li>
<li>直接处理连接、消息、关闭等事件（文本或二进制）。</li>
<li>协议为原生 WebSocket（RFC 6455），性能高、控制细。</li>
<li>适用于语音转写、实时数据流、设备上报等<strong>点对点通信</strong>场景。</li>
</ul>
</li>
<li><strong>基于 STOMP 协议的上层消息代理方式</strong><ul>
<li>使用 <code>@EnableWebSocketMessageBroker</code> + <code>@MessageMapping</code> 实现。</li>
<li>在原生 WebSocket 之上增加 STOMP 消息协议，支持订阅、广播、点对点消息。</li>
<li>适用于聊天系统、消息推送、通知广播等<strong>多用户通信</strong>场景。</li>
</ul>
</li>
</ol>
<h1 id="Spring-MVC-和Spring-WebSocket-的关系"><a href="#Spring-MVC-和Spring-WebSocket-的关系" class="headerlink" title="Spring MVC 和Spring WebSocket 的关系"></a>Spring MVC 和Spring WebSocket 的关系</h1><table>
<thead>
<tr>
<th>模块</th>
<th>通信协议</th>
<th>特点</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Spring MVC</strong></td>
<td>HTTP（短连接）</td>
<td>请求-响应模式，同步阻塞</td>
<td>普通接口、表单提交、REST API</td>
</tr>
<tr>
<td><strong>Spring WebSocket</strong></td>
<td>WebSocket（长连接）</td>
<td>双向实时通信，异步事件驱动</td>
<td>聊天室、通知推送、语音流</td>
</tr>
</tbody></table>
<ol>
<li>Spring MVC 是同步阻塞模型（Thread-per-Request）</li>
</ol>
<ul>
<li>Spring MVC 基于 <strong>Servlet 同步模型</strong>：<br>每个 HTTP 请求都会占用一个线程，直到请求处理结束才释放。</li>
<li>特点：<ul>
<li>一次请求对应一次响应。</li>
<li>线程会在等待期间被“挂起”。</li>
<li>高并发下线程资源容易耗尽。</li>
</ul>
</li>
</ul>
<p> 关键点：<strong>同步、阻塞、短连接。</strong></p>
<ol start="2">
<li>WebSocket 是异步事件驱动模型</li>
</ol>
<ul>
<li>WebSocket 只在最开始的“握手”阶段使用 HTTP（同步）。</li>
<li>握手完成后，连接升级为 <strong>全双工长连接</strong>，交给容器（Tomcat&#x2F;Jetty）底层的 <strong>NIO 通道</strong> 管理。</li>
<li>后续的消息通信是通过事件异步触发的：<ul>
<li><code>afterConnectionEstablished</code> → 连接建立</li>
<li><code>handleMessage</code> → 收到消息</li>
<li><code>afterConnectionClosed</code> → 连接关闭</li>
</ul>
</li>
<li>每条连接不会一直占用线程，消息到来时容器会调度线程去处理。</li>
</ul>
<p>📌 关键点：<strong>异步、非阻塞、长连接、事件驱动。</strong></p>
<h1 id="WebSocketHandler"><a href="#WebSocketHandler" class="headerlink" title="WebSocketHandler"></a>WebSocketHandler</h1><h2 id="WebSocketHandler-是什么"><a href="#WebSocketHandler-是什么" class="headerlink" title="WebSocketHandler 是什么"></a>WebSocketHandler 是什么</h2><p>在 Spring 框架中，<code>WebSocketHandler</code> 是一个接口，用来定义 <strong>WebSocket 连接的生命周期</strong> 以及 <strong>消息处理逻辑</strong>。</p>
<h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><h3 id="启用-WebSocket-支持"><a href="#启用-WebSocket-支持" class="headerlink" title="启用 WebSocket 支持"></a>启用 WebSocket 支持</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761214978258-ca828be8-75b0-46e7-a0bb-8bdc4dc36ec0.png"></p>
<h3 id="编写-WebSocketHandler-实现类"><a href="#编写-WebSocketHandler-实现类" class="headerlink" title="编写 WebSocketHandler 实现类"></a>编写 WebSocketHandler 实现类</h3><p><code>WebSocketHandler</code> 是 Spring 框架定义的一个接口。它代表一个 <strong>WebSocket 连接处理器（Handler）</strong>， 它就是你写 WebSocket 服务的“控制器（Controller）”。  </p>
<p> Spring 提供了两个常用的抽象类：  </p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>TextWebSocketHandler</code></td>
<td>专门处理文本消息（<code>TextMessage</code><br/>）</td>
</tr>
<tr>
<td><code>BinaryWebSocketHandler</code></td>
<td>专门处理二进制消息（<code>BinaryMessage</code><br/>）</td>
</tr>
</tbody></table>
<h4 id="示例（文本消息）"><a href="#示例（文本消息）" class="headerlink" title="示例（文本消息）"></a>示例（文本消息）</h4><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761215353945-d8d13f4a-5bf6-417c-8c5a-914d067120bf.png"></p>
<p>核心概念</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
<th>类似</th>
</tr>
</thead>
<tbody><tr>
<td><strong>WebSocketSession</strong></td>
<td>表示一个客户端连接，会话对象。可以存用户信息、发消息。</td>
<td>JSR-356 的 <code>Session</code></td>
</tr>
<tr>
<td><strong>TextMessage &#x2F; BinaryMessage</strong></td>
<td>表示客户端发送的消息体。</td>
<td>WebSocket 数据帧</td>
</tr>
<tr>
<td><strong>afterConnectionEstablished()</strong></td>
<td>当客户端连接成功后调用。</td>
<td><code>@OnOpen</code></td>
</tr>
<tr>
<td><strong>handleTextMessage() &#x2F; handleBinaryMessage()</strong></td>
<td>收到消息时调用。</td>
<td><code>@OnMessage</code></td>
</tr>
<tr>
<td><strong>afterConnectionClosed()</strong></td>
<td>连接关闭时调用。</td>
<td><code>@OnClose</code></td>
</tr>
<tr>
<td><strong>handleTransportError()</strong></td>
<td>发生传输错误时调用。</td>
<td><code>@OnError</code></td>
</tr>
<tr>
<td><strong>WebSocketConfigurer</strong></td>
<td>注册 Handler，配置路径、跨域、拦截器等。</td>
<td>Servlet 注册机制</td>
</tr>
</tbody></table>
<h4 id="二进制消息（语音转写）"><a href="#二进制消息（语音转写）" class="headerlink" title="二进制消息（语音转写）"></a>二进制消息（语音转写）</h4><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761215536889-84f6dc43-bd5f-457d-b272-e7376b9ed5e9.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/IP/%E7%BD%91%E7%BB%9C/IP/localhost%E5%92%8C127.0.0.1%E5%92%8C0.0.0.0%E6%9C%89%E5%8C%BA%E5%88%AB%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/IP/%E7%BD%91%E7%BB%9C/IP/localhost%E5%92%8C127.0.0.1%E5%92%8C0.0.0.0%E6%9C%89%E5%8C%BA%E5%88%AB%E4%B9%88/" class="post-title-link" itemprop="url">localhost和127.0.0.1和0.0.0.0有区别么</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/IP/" itemprop="url" rel="index"><span itemprop="name">IP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>含义</th>
<th>数据包是否离开本机</th>
</tr>
</thead>
<tbody><tr>
<td><strong>127.0.0.1</strong></td>
<td>IP 地址</td>
<td>IPv4 回环地址 → 代表本机</td>
<td>❌ 永远不离开本机</td>
</tr>
<tr>
<td><strong>localhost</strong></td>
<td>域名（hostname）</td>
<td>通常解析为 127.0.0.1</td>
<td>❌ 不离开本机（如果解析成127.0.0.1）</td>
</tr>
<tr>
<td><strong>0.0.0.0</strong></td>
<td>特殊 IP（通配符）</td>
<td>代表本机所有 IPv4 网卡</td>
<td>✔️（绑定的服务可以被外部访问）</td>
</tr>
</tbody></table>
<h1 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h1><p> 127.0.0.1 是 IPv4 的“本地回环地址”，代表的就是本机，用它发送的流量永远不会离开本机</p>
<h1 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h1><p>localhost 是一个域名，默认会把它解析成127.0.0.1<font style="color:rgb(44, 62, 80);">在 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;/etc/hosts&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 文件下进行修改。所以默认请款下localhost和127.0.0.1 没有区别</font></p>
<h1 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a><font style="color:rgb(44, 62, 80);">0.0.0.0</font></h1><p> 0.0.0.0 表示“本机所有 IPv4 地址”</p>
<p>127.0.0.1 &#x3D; 只允许本机访问<br>0.0.0.0 &#x3D; 允许所有来源访问，只要绑定的机器有对应网卡</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">HTTP协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">HTTP协议</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP请求与响应"><a href="#HTTP请求与响应" class="headerlink" title="HTTP请求与响应"></a>HTTP请求与响应</h1><h2 id="HTTP请求包含三部分"><a href="#HTTP请求包含三部分" class="headerlink" title="HTTP请求包含三部分"></a>HTTP请求包含三部分</h2><table>
<thead>
<tr>
<th>部分</th>
<th>作用</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1️⃣</strong>** 请求行（Request Line）**</td>
<td>说明要干什么、对谁干、用什么协议</td>
<td><code>GET /user?id=1 HTTP/1.1</code></td>
</tr>
<tr>
<td><strong>2️⃣</strong>** 请求头（Request Headers）**</td>
<td>说明请求的附加信息（比如类型、认证、浏览器信息）</td>
<td><code>Host: api.example.com</code><br/>、<code>Content-Type: application/json</code></td>
</tr>
<tr>
<td><strong>3️⃣</strong>** 请求体（Request Body）**</td>
<td>真正要发送的数据（通常 POST&#x2F;PUT 才有）</td>
<td><code>{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:20}</code></td>
</tr>
</tbody></table>
<p>比如：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761273823127-78ab9840-498f-4eec-b451-5482a1f67970.png"></p>
<h2 id="HTTP响应也包含三部分"><a href="#HTTP响应也包含三部分" class="headerlink" title="HTTP响应也包含三部分"></a>HTTP响应也包含三部分</h2><table>
<thead>
<tr>
<th>部分</th>
<th>作用</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1️⃣</strong>** 状态行（Status Line）**</td>
<td>表明结果状态：协议版本 + 状态码 + 状态描述</td>
<td><code>HTTP/1.1 200 OK</code></td>
</tr>
<tr>
<td><strong>2️⃣</strong>** 响应头（Response Headers）**</td>
<td>告诉客户端这次响应的附加信息</td>
<td><code>Content-Type: application/json</code><br/>、<code>Set-Cookie: sessionId=abc123</code></td>
</tr>
<tr>
<td><strong>3️⃣</strong>** 响应体（Response Body）**</td>
<td>服务器返回的实际内容</td>
<td><code>{&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;}</code></td>
</tr>
</tbody></table>
<p>比如：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761273845130-e849950d-be83-4856-8b34-371bb6869eb6.png"></p>
<p><strong>HTTP 的请求或响应报文中，消息体（Body）部分并不是必需的。<strong>对于像 <strong>GET</strong>、<strong>DELETE</strong> 这样的请求，通常只需要请求行和请求头即可，不需要携带消息体；而像 <strong>POST</strong>、<strong>PUT</strong> 这类请求才会在消息体中携带要提交的数据。同样地，服务器响应中如果没有内容返回（例如状态码 204 No Content、304 Not Modified），响应报文也可以</strong>没有消息体</strong>。  </p>
<h2 id="HTTP的Post-等方法一定不能有消息体么？"><a href="#HTTP的Post-等方法一定不能有消息体么？" class="headerlink" title="HTTP的Post 等方法一定不能有消息体么？"></a>HTTP的Post 等方法一定不能有消息体么？</h2><p> 从规范上看可以，但实际应用中不会这样做，因为语义不明确且兼容性差， 浏览器、代理、中间件几乎都<strong>不会发送或处理</strong> GET 请求体   很多服务器框架（例如 Spring MVC）在解析 GET 请求时，会<strong>忽略请求体</strong>  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP_2_%E4%B8%8EHTTP_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP_2_%E4%B8%8EHTTP_3/" class="post-title-link" itemprop="url">HTTP 2 与HTTP 3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">HTTP协议</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP_1.1%E4%B8%8EHTTP_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/HTTP_1.1%E4%B8%8EHTTP_2/" class="post-title-link" itemprop="url">HTTP 1.1与HTTP 2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">HTTP协议</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="HTTP各版本对比"><a href="#HTTP各版本对比" class="headerlink" title="HTTP各版本对比"></a>HTTP各版本对比</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>HTTP&#x2F;1.1</th>
<th>HTTP&#x2F;2</th>
<th>HTTP&#x2F;3</th>
</tr>
</thead>
<tbody><tr>
<td><strong>发布时间</strong></td>
<td>1999 年（RFC 2616）</td>
<td>2015 年（RFC 7540）</td>
<td>2022 年（RFC 9114）</td>
</tr>
<tr>
<td><strong>传输协议</strong></td>
<td>TCP</td>
<td>TCP</td>
<td><strong>QUIC（UDP）</strong></td>
</tr>
<tr>
<td><strong>连接复用</strong></td>
<td>❌ 每次一个请求</td>
<td>✅ 多路复用</td>
<td>✅ 多路复用</td>
</tr>
<tr>
<td><strong>队头阻塞</strong></td>
<td>⚠️ 存在</td>
<td>⚠️ TCP 层仍存在</td>
<td>✅ 完全消除</td>
</tr>
<tr>
<td><strong>压缩</strong></td>
<td>❌ 无</td>
<td>✅ HPACK</td>
<td>✅ QPACK</td>
</tr>
<tr>
<td><strong>加密</strong></td>
<td>可选（HTTPS）</td>
<td>推荐使用 HTTPS</td>
<td>强制加密（内置 TLS）</td>
</tr>
<tr>
<td><strong>服务端推送</strong></td>
<td>❌ 无</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
</tr>
<tr>
<td><strong>目前使用情况</strong></td>
<td>🔸 仍广泛存在（低版本网站、内网系统）</td>
<td>🟢 主流标准（约占全球网站 70%+）</td>
<td>🧩 新兴主流（Chrome、Cloudflare、Google 全面支持）</td>
</tr>
</tbody></table>
<h2 id="HTTP2-相对于HTTP1-的五大核心优势"><a href="#HTTP2-相对于HTTP1-的五大核心优势" class="headerlink" title="HTTP2 相对于HTTP1 的五大核心优势"></a>HTTP2 相对于HTTP1 的五大核心优势</h2><table>
<thead>
<tr>
<th>序号</th>
<th>优势点</th>
<th>对应解决了 HTTP&#x2F;1.1 的什么问题</th>
<th>一句话理解</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1️⃣</strong>** 多路复用 (Multiplexing)**</td>
<td>HTTP&#x2F;1.1 同一连接只能排队处理一个请求，容易“队头阻塞”</td>
<td>✅ 一个连接可同时传多个请求和响应，互不干扰</td>
<td><strong>让多个请求在同一连接中并行传输，不再排队等待。</strong></td>
</tr>
<tr>
<td><strong>2️⃣</strong>** 二进制分帧 (Binary Framing)**</td>
<td>HTTP&#x2F;1.1 使用纯文本格式，解析和传输效率低</td>
<td>✅ 将消息拆成二进制帧，提高解析速度和可靠性</td>
<td><strong>把文本协议改为二进制帧结构，传输更快更稳。</strong></td>
</tr>
<tr>
<td><strong>3️⃣</strong>** 头部压缩 (HPACK)**</td>
<td>每次请求都要重复传很长的 Header（Cookie、User-Agent 等）</td>
<td>✅ 使用压缩算法和索引表，大幅减少头部开销</td>
<td><strong>通过压缩与索引减少重复头部传输，节省带宽。</strong></td>
</tr>
<tr>
<td><strong>4️⃣</strong>** 服务器推送 (Server Push)**</td>
<td>客户端只能被动请求资源</td>
<td>✅ 服务器可主动推送资源（如 CSS、JS），减少延迟</td>
<td><strong>服务器可提前推送依赖资源，但已被 HTTP&#x2F;3 废弃。</strong></td>
</tr>
<tr>
<td><strong>5️⃣</strong>** 单连接复用（减少 TCP 连接数）**</td>
<td>HTTP&#x2F;1.1 需要多个 TCP 连接并行，资源浪费</td>
<td>✅ 一个连接即可传所有请求，握手少、延迟低</td>
<td><strong>一个连接跑完所有请求，握手更少，传输更快。</strong></td>
</tr>
</tbody></table>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><font style="color:#DF2A3F;">一定要注意这里的多路复用和linux os 中的epoll 多路复用不是一个概念</font></p>
<p><font style="color:#DF2A3F;">它们的区别</font></p>
<table>
<thead>
<tr>
<th><font style="color:#000000;">对比点</font></th>
<th><strong><font style="color:#000000;">HTTP&#x2F;2 多路复用</font></strong></th>
<th><strong><font style="color:#000000;">epoll 多路复用</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:#000000;">所属层级</font></td>
<td><font style="color:#000000;">应用层（HTTP 协议）</font></td>
<td><font style="color:#000000;">操作系统内核层（I&#x2F;O 模型）</font></td>
</tr>
<tr>
<td><font style="color:#000000;">解决的问题</font></td>
<td><font style="color:#000000;">如何在一个 TCP 连接里同时传多个请求</font></td>
<td><font style="color:#000000;">如何让一个线程同时监听多个 socket</font></td>
</tr>
<tr>
<td><font style="color:#000000;">作用对象</font></td>
<td><font style="color:#000000;">一个 TCP 连接内的多个“流（stream）”</font></td>
<td><font style="color:#000000;">多个 TCP 连接（socket 文件描述符）</font></td>
</tr>
<tr>
<td><font style="color:#000000;">举例理解</font></td>
<td><font style="color:#000000;">在一条高速公路上开多条车道</font></td>
<td><font style="color:#000000;">一个交通指挥员同时盯着多条道路的红绿灯</font></td>
</tr>
</tbody></table>
<h4 id="HTTP2的多路复用解决了HTTP1-1的什么问题"><a href="#HTTP2的多路复用解决了HTTP1-1的什么问题" class="headerlink" title="HTTP2的多路复用解决了HTTP1.1的什么问题"></a>HTTP2的多路复用解决了HTTP1.1的什么问题</h4><p> 在 HTTP&#x2F;1.1 中：<br>● 一个 TCP 连接一次只能处理一个请求；<br>● 如果前一个请求没返回，下一个请求就得等；<br>● 对同一个域名，浏览器最多同时开 6 个连接来提升并发；<br>● 但开启过多连接会浪费资源、占用带宽，<strong>毕竟 TCP 连接的建立与销毁（握手、挥手）都十分昂贵。</strong></p>
<p><strong>HTTP2多路复用（Multiplexing）</strong>：<br>在 <strong>一个 TCP 连接</strong> 里，同时并行地发送多个 HTTP 请求和响应，<br>每个请求都有独立的 <strong>Stream ID（流编号）</strong>，互不干扰。</p>
<p>也就是说：</p>
<p>HTTP&#x2F;2 不再为每个请求都开新连接，而是让所有请求共享一个连接。<br>数据在同一个连接中被拆分成一帧一帧（Frame）交错发送，<br>浏览器和服务器根据 Stream ID 把属于同一个请求的帧重新组装起来。</p>
<p>解决的问题</p>
<table>
<thead>
<tr>
<th>HTTP&#x2F;1.1 的问题</th>
<th>HTTP&#x2F;2 的改进</th>
</tr>
</thead>
<tbody><tr>
<td>每个请求必须独占一个 TCP 连接（或排队等待）</td>
<td>✅ 所有请求共享一个连接</td>
</tr>
<tr>
<td>串行传输 → 队头阻塞严重</td>
<td>✅ 并行传输 → 不互相阻塞</td>
</tr>
<tr>
<td>建立多个连接浪费资源</td>
<td>✅ 一个连接复用 → 握手少、资源省</td>
</tr>
<tr>
<td>浏览器需要“域名分片”才能提高并发</td>
<td>✅ 不再需要域名分片</td>
</tr>
</tbody></table>
<h4 id="HTTP2的多路复用只会为每个域名建立一个连接么？"><a href="#HTTP2的多路复用只会为每个域名建立一个连接么？" class="headerlink" title="HTTP2的多路复用只会为每个域名建立一个连接么？"></a>HTTP2的多路复用只会为每个域名建立一个连接么？</h4><p> “HTTP&#x2F;2 一般会为同一个域名维持一个长连接，所有请求在该连接内通过多路复用并行传输；<br>不同域名、协议或端口的请求仍会建立各自的连接。”  </p>
<h4 id="什么是串行传输-队头阻塞"><a href="#什么是串行传输-队头阻塞" class="headerlink" title="什么是串行传输-&gt;队头阻塞"></a>什么是串行传输-&gt;队头阻塞</h4><h5 id="什么是串行输出"><a href="#什么是串行输出" class="headerlink" title="什么是串行输出"></a>什么是串行输出</h5><p>在 HTTP&#x2F;1.1 时代，一个 TCP 连接上：</p>
<p>一次只能处理一个请求。</p>
<p>也就是说：</p>
<ol>
<li>浏览器发一个请求（例如请求 <code>index.html</code>）；</li>
<li>必须等服务器返回完整响应后，</li>
<li>才能在同一个连接上发送下一个请求。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761189940349-a5fcddf8-16cb-49a2-b493-6a4362630c68.png"></p>
<h5 id="为什么会队头阻塞"><a href="#为什么会队头阻塞" class="headerlink" title="为什么会队头阻塞"></a>为什么会队头阻塞</h5><p>“队头阻塞”就是说：</p>
<p>当队列最前面的请求（队头）没有完成时，<br>后面的请求都<strong>被迫等待</strong>，哪怕它们其实可以先返回。</p>
<p>比如：</p>
<ul>
<li>浏览器开了一个连接；</li>
<li>第一个请求 <code>/index.html</code> 卡住（服务器慢、网络抖动）；</li>
<li>后面的 <code>/style.css</code>、<code>/app.js</code> 都得等；</li>
<li>整个页面加载被拖慢。</li>
</ul>
<p>就像排队买奶茶：第一个人犹豫半天不点单，后面的人都动不了。</p>
<h5 id="对于HTTP1-1的对头阻塞浏览器的临时补救策略"><a href="#对于HTTP1-1的对头阻塞浏览器的临时补救策略" class="headerlink" title="对于HTTP1.1的对头阻塞浏览器的临时补救策略"></a>对于HTTP1.1的对头阻塞浏览器的临时补救策略</h5><p>为了减轻这种队头阻塞，浏览器在 HTTP&#x2F;1.1 里做了“<strong>并发连接限制</strong>”：</p>
<ul>
<li>对同一域名最多开 <strong>6 个 TCP 连接</strong>；</li>
<li>每个连接上<strong>依然是串行的</strong>；</li>
<li>这样多个请求可以分配到不同连接中同时跑，但依然浪费资源。、</li>
</ul>
<h5 id="HTTP2为什么可以解决"><a href="#HTTP2为什么可以解决" class="headerlink" title="HTTP2为什么可以解决"></a>HTTP2为什么可以解决</h5><p>HTTP&#x2F;2 把这种「一根吸管排队」的模式，变成了「一根多通道吸管」：</p>
<ul>
<li>同一个连接里能并行发多个请求；</li>
<li>每个请求分配一个独立的流（Stream ID）；</li>
<li>互不影响，从根本上解决了应用层的队头阻塞。</li>
</ul>
<h4 id="HTTP2多路复用的实现原理"><a href="#HTTP2多路复用的实现原理" class="headerlink" title="HTTP2多路复用的实现原理"></a>HTTP2多路复用的实现原理</h4><h5 id="首先HTTP1-1的消息格式是纯文本，太过简单"><a href="#首先HTTP1-1的消息格式是纯文本，太过简单" class="headerlink" title="首先HTTP1.1的消息格式是纯文本，太过简单"></a>首先HTTP1.1的消息格式是纯文本，太过简单</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761190756619-2b4e761a-750f-4ca0-a08c-0fc538c7e079.png"></p>
<p> 这一串要完整传完、解析完，服务器才能处理。<br>所以——<strong>一个连接里不能同时传两个请求。</strong></p>
<p>HTTP&#x2F;2 的核心改进是：</p>
<p><strong>在 TCP 之上，引入一层 二进制分帧层（Binary Framing Layer）。</strong></p>
<h5 id="HTTP-2-的实现核心：二进制分帧-流（Stream）"><a href="#HTTP-2-的实现核心：二进制分帧-流（Stream）" class="headerlink" title="HTTP&#x2F;2 的实现核心：二进制分帧 + 流（Stream）"></a>HTTP&#x2F;2 的实现核心：二进制分帧 + 流（Stream）</h5><p>HTTP&#x2F;2 把通信过程切分成很多“帧（Frame）”：</p>
<ul>
<li>每个帧是最小的传输单位；</li>
<li>每个帧都包含一个 <strong>Stream ID（流 ID）</strong>；</li>
<li><strong>每个流代表一个独立的 HTTP 请求&#x2F;响应，一个流对应多个帧。</strong></li>
</ul>
<p>例如， 浏览器要发三个请求：  </p>
<p>Stream 1 -&gt; index.html</p>
<p>Stream 3 -&gt; style.css</p>
<p>Stream 5 -&gt; app.js</p>
<p>** HTTP&#x2F;2 会把它们的数据都拆成帧：  A1, B1, C1, A2, B2, C2 …  并在同一个 TCP 连接中交错发送。  **</p>
<h5 id="HTTP2提供的其他功能"><a href="#HTTP2提供的其他功能" class="headerlink" title="HTTP2提供的其他功能"></a>HTTP2提供的其他功能</h5><p>HTTP&#x2F;2 还提供了：</p>
<ul>
<li><strong>Stream 优先级（Priority）</strong>：告诉服务端哪个请求更重要；</li>
<li><strong>流量控制（Flow Control）</strong>：防止某个流独占带宽（用 WINDOW_UPDATE 帧调节）。</li>
</ul>
<h3 id="二级分帧"><a href="#二级分帧" class="headerlink" title="二级分帧"></a>二级分帧</h3><h4 id="为什么要引入二进制分帧"><a href="#为什么要引入二进制分帧" class="headerlink" title="为什么要引入二进制分帧"></a>为什么要引入二进制分帧</h4><p>在 HTTP&#x2F;1.1 中：</p>
<ul>
<li>所有数据（包括头、体）都是<strong>纯文本格式</strong>；</li>
<li>解析要靠换行符、空格等标识；</li>
<li>对计算机来说效率很低，也不容易并行。</li>
</ul>
<p>HTTP&#x2F;2 想要实现「多路复用」，就必须让通信内容能被精确地<strong>分割、标识、交错、重组</strong>。所以，它放弃文本格式，引入了一个新的层 ——👉 <strong>二进制分帧层（Binary Framing Layer）</strong>。</p>
<h4 id="它在协议中的位置"><a href="#它在协议中的位置" class="headerlink" title="它在协议中的位置"></a>它在协议中的位置</h4><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761202712642-98a3794b-5aab-4f7f-b00d-df92489ae964.png"></p>
<h4 id="帧是什么？"><a href="#帧是什么？" class="headerlink" title="帧是什么？"></a>帧是什么？</h4><p>HTTP&#x2F;2 规定，所有通信都是通过“帧”进行的。帧是 HTTP&#x2F;2 中<strong>最小的通信单位</strong>。一个帧大致结构如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761202772923-31c6e43c-517e-4d62-bde0-a462f7a8c665.png"></p>
<p>说明：</p>
<ul>
<li><strong>Length</strong>：帧体的字节长度；</li>
<li><strong>Type</strong>：帧类型（HEADERS、DATA、SETTINGS 等）；</li>
<li><strong>Flags</strong>：标志位（例如 END_HEADERS、END_STREAM）；</li>
<li><strong>Stream ID</strong>：表示此帧属于哪个流；</li>
<li><strong>Payload</strong>：真正的数据内容</li>
</ul>
<p> HTTP&#x2F;2 在传输过程中会将请求拆分为多条帧进行发送，服务端接收后再根据帧的标识（Stream ID）将这些帧重新组合，还原为<font style="background-color:#CEF5F7;">完整的 HTTP 消息</font>（包含请求头和请求体）。  </p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><h4 id="为什么要压缩头部"><a href="#为什么要压缩头部" class="headerlink" title="为什么要压缩头部"></a>为什么要压缩头部</h4><p> 在 HTTP&#x2F;1.1 中，每个请求都会重复携带大量相同的头部字段，例如：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761203086685-34f10817-2306-476f-bcd2-bd62e98f262e.png"></p>
<p>可以看到:</p>
<ul>
<li>这些头部几乎都一样；</li>
<li>只改变了很少的字段；</li>
<li>但每次都要全部发送，<strong>浪费带宽</strong>；</li>
<li>而且头部是文本格式，解析开销也大。</li>
</ul>
<p>所以 HTTP&#x2F;2 希望——只发变化的部分，重复的内容能被缓存或压缩。</p>
<h4 id="HPACK是怎么压缩的"><a href="#HPACK是怎么压缩的" class="headerlink" title="HPACK是怎么压缩的"></a>HPACK是怎么压缩的</h4><p> HTTP&#x2F;2 定义了一个专门的压缩算法 —— <strong>HPACK</strong>，它通过两种方式减少头部体积：</p>
<h5 id="静态表"><a href="#静态表" class="headerlink" title="静态表"></a>静态表</h5><p> 协议内置一个常见头部字段表，例如：    </p>
<table>
<thead>
<tr>
<th>索引</th>
<th>Header 字段</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>:method</td>
<td>GET</td>
</tr>
<tr>
<td>2</td>
<td>:method</td>
<td>POST</td>
</tr>
<tr>
<td>3</td>
<td>:path</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>8</td>
<td>:status</td>
<td>200</td>
</tr>
<tr>
<td>33</td>
<td>user-agent</td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>accept-encoding</td>
<td>gzip, deflate</td>
</tr>
</tbody></table>
<p> 客户端或服务端只需要发送（索引即可）：  </p>
<p>10000010</p>
<p>↑</p>
<p>│</p>
<p>└── 表示 “我引用了静态表中的第 2 项（:method GET）”</p>
<br/>

<p> 这样就不用传“GET”“:path”“user-agent”这些文字。  </p>
<h5 id="动态表"><a href="#动态表" class="headerlink" title="动态表"></a>动态表</h5><ul>
<li>通信双方可以在运行时维护一张“记忆表”；</li>
<li>每出现一个新的头部字段，就存进去；</li>
<li>之后再发送相同字段时，只需引用它的索引；</li>
<li>动态表是双向同步的（客户端和服务端共享状态）。</li>
</ul>
<p>所以静态表就是提前定义的，提供常见的固定头部字段索引，动态表就是通信过程中双方共同维护的，记录通信过程中出现的新头部字段</p>
<h3 id="服务器推送（很鸡肋，默认关闭）"><a href="#服务器推送（很鸡肋，默认关闭）" class="headerlink" title="服务器推送（很鸡肋，默认关闭）"></a>服务器推送（很鸡肋，默认关闭）</h3><p> 需要注意的是，HTTP&#x2F;2 的服务器推送是一个比较鸡肋的功能，在<font style="color:#DF2A3F;"> HTTP&#x2F;3 中已经被废弃</font>；而且像 Nginx、Cloudflare 等多数网关默认都关闭了这一特性。  </p>
<h4 id="什么是服务推送"><a href="#什么是服务推送" class="headerlink" title="什么是服务推送"></a>什么是服务推送</h4><p> 在 HTTP&#x2F;1.1 中，通信是严格的 <strong>请求 → 响应</strong> 模式：  浏览器必须先发送请求，服务器才能返回数据</p>
<p>而在HTTP&#x2F;2中，服务器可以主动推送某些资源给客户端，即使客户端还没请求它们</p>
<p><strong>举个例子</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761203914100-35225b1c-4226-4aad-acd5-2cb604cef39d.png"></p>
<h4 id="怎么实现推送的"><a href="#怎么实现推送的" class="headerlink" title="怎么实现推送的"></a>怎么实现推送的</h4><p> HTTP&#x2F;2 使用三种帧实现推送机制：  </p>
<table>
<thead>
<tr>
<th>帧类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PUSH_PROMISE</strong></td>
<td>告诉客户端：“我准备推送这个资源”</td>
</tr>
<tr>
<td><strong>HEADERS</strong></td>
<td>推送资源的响应头</td>
</tr>
<tr>
<td><strong>DATA</strong></td>
<td>推送资源的实际内容</td>
</tr>
</tbody></table>
<p> 推送的资源会有自己的 <strong>Stream ID</strong>（流编号），<br>例如：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761203963602-15e3c956-eef4-4eba-bbbf-32563e0c123f.png"></p>
<p> 这些流都在同一个 TCP 连接中多路复用。  </p>
<h4 id="客户端依然具有控制权"><a href="#客户端依然具有控制权" class="headerlink" title="客户端依然具有控制权"></a>客户端依然具有控制权</h4><p>客户端可以：</p>
<ul>
<li>通过 <code>SETTINGS_ENABLE_PUSH = 0</code> 禁用推送；</li>
<li>收到 <code>PUSH_PROMISE</code> 后，若已缓存该资源，可发送 <code>RST_STREAM</code> 拒收；</li>
<li>推送的内容仍然受缓存、同源策略、优先级控制。</li>
</ul>
<h4 id="很鸡肋，HTTP-3已经废弃"><a href="#很鸡肋，HTTP-3已经废弃" class="headerlink" title="很鸡肋，HTTP&#x2F;3已经废弃"></a>很鸡肋，HTTP&#x2F;3已经废弃</h4><p>因为：</p>
<ul>
<li>推送不好管理（容易推多或推错资源）；</li>
<li><strong><font style="color:#DF2A3F;">推送的东西如果浏览器并不需要，会造成资源浪费</font></strong></li>
<li>浏览器缓存、优先级机制复杂；</li>
<li>QUIC&#x2F;HTTP&#x2F;3 更推荐使用 <strong>“103 Early Hints” + preload header”</strong>。</li>
</ul>
<h3 id="单连接复用"><a href="#单连接复用" class="headerlink" title="单连接复用"></a>单连接复用</h3><p> HTTP&#x2F;2 的单连接复用机制就是通过“多路复用（Multiplexing）”实现的。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9E%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9E%E6%8E%A5/" class="post-title-link" itemprop="url">一个进程可以建立多少个连接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对于一个进程可以建立多少个网络连接，主要取决于一个进程可以打开多少个socket</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 是一种<strong>面向连接的协议</strong>。服务器启动后会先创建一个<strong>监听 socket</strong> 并绑定端口，它只负责接收新的连接请求，不负责数据传输。</p>
<p>当有客户端完成三次握手后，<strong>内核会为这个新连接创建一个独立的通信 socket（对应一个新的文件描述符 fd）</strong>。<br>因此：</p>
<ul>
<li><strong>监听 socket：只有一个，用来接客</strong></li>
<li><strong>通信 socket：有多少连接，就有多少个 fd</strong></li>
</ul>
<p>在 Linux 中“万物皆文件”，socket 也属于文件的一种。<br>所以：</p>
<p><strong>一个 TCP 进程最多能建立多少个连接，本质上受限于它能打开多少个文件描述符（FD）。</strong></p>
<h2 id="查看进程所能创建的最大文件描述符数量"><a href="#查看进程所能创建的最大文件描述符数量" class="headerlink" title="查看进程所能创建的最大文件描述符数量"></a>查看进程所能创建的最大文件描述符数量</h2><p><code>ulimit -n</code> </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763520794313-042fe9aa-9fb6-4dc4-ab92-f0faa9d4a43d.png"></p>
<h2 id="设置进程所能创建的最大文件描述符数量"><a href="#设置进程所能创建的最大文件描述符数量" class="headerlink" title="设置进程所能创建的最大文件描述符数量"></a>设置进程所能创建的最大文件描述符数量</h2><p>ulimit -n fd数量</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763520834172-f011ddd6-c485-4880-9ec9-f75d28230823.png"></p>
<h2 id="查看当前系统所能创建的最大文件描述符数量"><a href="#查看当前系统所能创建的最大文件描述符数量" class="headerlink" title="查看当前系统所能创建的最大文件描述符数量"></a>查看当前系统所能创建的最大文件描述符数量</h2><p>sysctl fs.file-max</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763521028263-97573b2e-0586-4d03-888d-e932dea945d5.png"></p>
<h1 id="设置当前系统所能创建的最大文件描述符数量"><a href="#设置当前系统所能创建的最大文件描述符数量" class="headerlink" title="设置当前系统所能创建的最大文件描述符数量"></a>设置当前系统所能创建的最大文件描述符数量</h1><ol>
<li>临时生效：<br><code>sudo sysctl -w fs.file-max=1000000</code></li>
<li>永久生效：<br>在 <code>/etc/sysctl.conf</code> 添加：<br><code>fs.file-max = 1000000</code><br>然后执行：<br><code>sudo sysctl -p</code></li>
</ol>
<h1 id="fs-file-max和ulimit-n-的区别"><a href="#fs-file-max和ulimit-n-的区别" class="headerlink" title="fs.file-max和ulimit -n 的区别"></a>fs.file-max和ulimit -n 的区别</h1><ul>
<li><code>**fs.file-max**</code> 限制的是：<br>整个 Linux 系统（所有进程加起来）最多能拥有多少个文件描述符（FD）。</li>
<li><code>**ulimit -n**</code> 限制的是：<br>单个进程最多能打开多少个文件描述符（FD）。</li>
</ul>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p> UDP 是无连接，因此不会像 TCP 那样为每个客户端创建一个新的 socket。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/TCP%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/TCP%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">TCP详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h1><p><font style="color:rgb(44, 62, 80);">TCP 是</font><strong><font style="color:rgb(48, 79, 254);">面向连接的、可靠的、基于字节流</font></strong><font style="color:rgb(44, 62, 80);">的传输层通信协议。</font></p>
<p><strong><font style="color:rgb(48, 79, 254);">面向连接</font></strong><font style="color:rgb(44, 62, 80);">：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</font></p>
<p><strong><font style="color:rgb(48, 79, 254);">可靠的</font></strong><font style="color:rgb(44, 62, 80);">：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</font></p>
<p><strong><font style="color:rgb(48, 79, 254);">字节流</font></strong><font style="color:rgb(44, 62, 80);">： TCP 传输数据时，会把消息拆成多个报文发送。接收方只看到连续的字节流，不知道原来消息的“边界”。TCP 会确保数据</font><strong>按顺序、无重复、无丢失</strong><font style="color:rgb(44, 62, 80);">地送达，如果前面的数据没到，即使后面的先到了也不会交给应用层处理。  </font></p>
<h1 id="TCP协议头部格式"><a href="#TCP协议头部格式" class="headerlink" title="TCP协议头部格式"></a>TCP协议头部格式<img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761987714872-5f5267cf-f7ab-45b9-b027-e3b4c6059421.png"></h1><p><strong><font style="color:rgb(48, 79, 254);">序列号</font></strong><font style="color:rgb(44, 62, 80);">：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。</font><strong><font style="color:rgb(48, 79, 254);">用来解决网络包乱序问题。</font></strong></p>
<p><strong><font style="color:rgb(48, 79, 254);">确认应答号</font></strong><font style="color:rgb(44, 62, 80);">：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。</font><strong><font style="color:rgb(48, 79, 254);">用来解决丢包的问题。</font></strong></p>
<p>举例说明</p>
<p>所以如果主机 A 发送的是：</p>
<ul>
<li>序列号 &#x3D; 1001</li>
<li>数据长度 &#x3D; 100 字节</li>
</ul>
<p>那么主机 B 收到后，说明它已经收到了 <strong>1001～1100（共100个字节）</strong> 的数据。<br>👉 此时它会发送的 <strong>确认号 &#x3D; 1101</strong>，意思是：“我已经收到 1100 之前的所有字节，请从 1101 开始发下一个。”</p>
<p><strong><font style="color:rgb(48, 79, 254);">控制位：</font></strong></p>
<ul>
<li><em><font style="color:rgb(200, 73, 255);">ACK</font></em><font style="color:rgb(44, 62, 80);">：该位为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 包之外该位必须设置为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 。	</font></li>
<li><em><font style="color:rgb(200, 73, 255);">RST</font></em><font style="color:rgb(44, 62, 80);">：该位为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 时，表示 TCP 连接中出现异常必须强制断开连接。</font></li>
<li><em><font style="color:rgb(200, 73, 255);">SYN</font></em><font style="color:rgb(44, 62, 80);">：该位为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</font></li>
<li><em><font style="color:rgb(200, 73, 255);">FIN</font></em><font style="color:rgb(44, 62, 80);">：该位为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 位为 1 的 TCP 段。</font></li>
</ul>
<h1 id="TCP连接的三次握手"><a href="#TCP连接的三次握手" class="headerlink" title="TCP连接的三次握手"></a>TCP连接的三次握手</h1><p>TCP是面向连接</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761988484148-db23c6b9-4d1f-47ff-aa13-4da6440d5736.png"></p>
<ol>
<li><font style="color:rgb(44, 62, 80);">一开始，客户端和服务端都处于 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;CLOSE&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。先是服务端主动监听某个端口，处于 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;LISTEN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态	</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761988731962-b4a0da45-2100-41b1-84d5-8856d4503863.png"></p>
<ol start="2">
<li>客户端发送三次握手的第一个报文: 客户端会先随机初始化tcp报文 的序列号（<font style="color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);">client_isn</font>）<font style="color:rgb(44, 62, 80);">同时把 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 标志位置为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);">，表示 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，</font><strong><font style="color:rgb(44, 62, 80);">该报文不包含应用层数据</font></strong><font style="color:rgb(44, 62, 80);">，之后客户端处于 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN-SENT&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761988837649-02ff9f13-bd7f-4718-a633-080c990077ea.png"></p>
<ol start="3">
<li>服务端发送三次握手的第二个报文：<font style="color:rgb(44, 62, 80);">服务端收到客户端的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文后，首先服务端也初始化自己的序列号（</font><font style="color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);">server_isn</font><font style="color:rgb(44, 62, 80);">），其次把 TCP 首部的「确认应答号」字段填入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;client_isn + 1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);">, 接着把 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 和 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 标志位置为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);">。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN-RCVD&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761988959715-52584adf-8edc-474d-a957-5de183fcb125.png"></p>
<ol start="4">
<li><font style="color:rgb(44, 62, 80);">客户端发送三次握手的第三个报文：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 标志位置为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);">  ，其次「确认应答号」字段填入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;server_isn + 1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ESTABLISHED&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。</font></li>
<li>服务端收到应答报文后，也进入<code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ESTABLISHED&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态</font></li>
</ol>
<p><font style="color:rgb(44, 62, 80);">从上面的过程可以发现</font><strong><font style="color:rgb(48, 79, 254);">第三次握手是可以携带数据的，前两次握手是不可以携带数据的</font></strong><font style="color:rgb(44, 62, 80);">。</font></p>
<h2 id="为什么是三次握手，而不是两次，四次"><a href="#为什么是三次握手，而不是两次，四次" class="headerlink" title="为什么是三次握手，而不是两次，四次"></a><font style="color:rgb(44, 62, 80);">为什么是三次握手，而不是两次，四次</font></h2><p><font style="color:rgb(44, 62, 80);"> 三次握手既能确保通信双方都具备</font><strong>发送和接收数据的能力</strong><font style="color:rgb(44, 62, 80);">，又能</font><strong>避免额外的握手次数造成资源浪费</strong></p>
<p><font style="color:rgb(44, 62, 80);">接下来，以三个方面分析三次握手的原因：</font></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">三次握手才可以阻止重复历史连接的初始化（主要原因）</font></li>
<li><font style="color:rgb(44, 62, 80);">三次握手才可以同步双方的初始序列号</font></li>
<li><font style="color:rgb(44, 62, 80);">三次握手才可以避免资源浪费</font></li>
</ul>
<h3 id="原因一：避免历史连接：三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。"><a href="#原因一：避免历史连接：三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。" class="headerlink" title="原因一：避免历史连接：三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。"></a><font style="color:rgb(200, 73, 255);">原因一：避免历史连接：</font><font style="color:rgb(44, 62, 80);">三次握手的</font><font style="color:rgb(48, 79, 254);">首要原因是为了防止旧的重复连接初始化造成混乱。</font></h3><p><font style="color:rgb(44, 62, 80);">我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（</font><em><font style="color:rgb(200, 73, 255);">注意！不是重传 SYN，重传的 SYN 的序列号是一样的</font></em><font style="color:rgb(44, 62, 80);">）。</font></p>
<p><font style="color:rgb(44, 62, 80);">看看三次握手是如何阻止历史连接的：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761989255345-e8e2e524-b67b-41fb-9d95-630a740947f7.png"></p>
<p><font style="color:rgb(44, 62, 80);">客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在</font><strong><font style="color:rgb(48, 79, 254);">网络拥堵</font></strong><font style="color:rgb(44, 62, 80);">情况下：一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，</font></p>
<ol>
<li><strong>旧 SYN 报文先到达服务器的情况</strong><br>当一个旧的 SYN 报文比新的 SYN 报文先到达服务器时，服务器会回复一个 <strong>SYN+ACK（确认号 &#x3D; 旧序列号 + 1）</strong>。<br>客户端收到后发现确认号与预期不符（应为新序列号 + 1），立即发送 <strong>RST 报文</strong> 断开连接。<br>之后新的 SYN 到达时，服务器可正常完成新的三次握手。</li>
<li><strong>服务器未收到 RST 就又收到新 SYN 的情况</strong><br>若服务器在收到旧 SYN 后、尚未等到客户端的 RST，又收到了新的 SYN，<br>它会先回复旧 SYN 的 ACK，再发送 <strong>Challenge ACK（挑战应答）</strong> 进行确认。<br>该 ACK 的确认号仍是旧序列号 + 1。<br>客户端收到后发现确认号不符（应为新序列号 + 1），于是发送 <strong>RST 报文</strong> 关闭旧连接。<br>此时服务器仅会释放旧连接资源，不会主动发起新的 SYN。<br>若客户端仍需通信，会<strong>重新发送新的 SYN 报文</strong>，<br>服务器再根据新的序列号返回 <strong>SYN+ACK</strong>，完成新的三次握手。</li>
</ol>
<p>✅ <strong>总结</strong></p>
<ul>
<li>两种情况的共同点：都能防止历史连接被误建立。</li>
<li>区别在于 RST 的时机：<ul>
<li>第一种是<strong>客户端主动发现错误后立即发送 RST</strong>；</li>
<li>第二种是<strong>服务器收到新 SYN 后发 Challenge ACK，再由客户端被动发送 RST</strong>。</li>
</ul>
</li>
<li><strong>服务器永远不会主动发 SYN</strong>，新连接必须由客户端重新发起。</li>
</ul>
<h3 id="原因二：同步双方初始序列号"><a href="#原因二：同步双方初始序列号" class="headerlink" title="原因二：同步双方初始序列号"></a><font style="color:rgb(200, 73, 255);">原因二：同步双方初始序列号</font></h3><p>在 TCP 通信中，双方都必须维护一个 <strong>序列号（Sequence Number）</strong>，<br>它是实现可靠传输的关键机制。序列号的作用包括：</p>
<ul>
<li><strong>去重</strong>：接收方可根据序列号丢弃重复的数据；</li>
<li><strong>按序重组</strong>：接收方可依据序列号将乱序的数据重新组装；</li>
<li><strong>确认机制</strong>：发送方通过 ACK 报文中的确认号得知哪些数据已被成功接收。</li>
</ul>
<p>序列号在 TCP 连接建立中也至关重要。<br>当客户端发送携带初始序列号的 <strong>SYN</strong> 报文时，服务器需回一个 <strong>SYN+ACK</strong> 报文，确认已成功接收客户端的序列号；<br>随后，服务器在发送自己的初始序列号时，也要等待客户端的 <strong>ACK</strong> 确认。</p>
<p>✅ <strong>只有经过这“一来一回”的确认，双方的初始序列号才能被可靠同步，从而保证通信的可靠性。</strong></p>
<h3 id="原因三：避免资源浪费"><a href="#原因三：避免资源浪费" class="headerlink" title="原因三：避免资源浪费"></a><font style="color:rgb(200, 73, 255);">原因三：避免资源浪费</font></h3><p><font style="color:rgb(44, 62, 80);">如果只有「两次握手」，当客户端发生的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文在网络中阻塞，客户端没有接收到 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文，就会重新发送 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> ，</font><strong><font style="color:rgb(48, 79, 254);">由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 </font></strong><code>**&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;**</code><strong><font style="color:rgb(48, 79, 254);"> 报文，所以服务端每收到一个 </font></strong><code>**&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;**</code><strong><font style="color:rgb(48, 79, 254);"> 就只能先主动建立一个连接</font></strong><font style="color:rgb(44, 62, 80);">，这会造成什么情况呢？</font></p>
<p><font style="color:rgb(44, 62, 80);">如果客户端发送的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文在网络中阻塞了，重复发送多次 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;SYN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文，那么服务端在收到请求后就会</font><strong><font style="color:rgb(48, 79, 254);">建立多个冗余的无效链接，造成不必要的资源浪费。</font></strong></p>
<h1 id="TCP断开连接四次挥手"><a href="#TCP断开连接四次挥手" class="headerlink" title="TCP断开连接四次挥手"></a>TCP断开连接四次挥手</h1><p><font style="color:rgb(44, 62, 80);">TCP 断开连接是通过</font><strong><font style="color:rgb(48, 79, 254);">四次挥手</font></strong><font style="color:rgb(44, 62, 80);">方式。双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1761991319368-e0be3e4c-a870-4dcf-acd8-fc7b0f50330a.png"></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">客户端打算关闭连接，此时会发送一个 TCP 首部 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 标志位被置为 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 的报文，也即 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文，之后客户端进入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN_WAIT_1&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。</font></li>
<li><font style="color:rgb(44, 62, 80);">服务端收到该报文后，就向客户端发送 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 应答报文，接着服务端进入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;CLOSE_WAIT&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。</font></li>
<li><font style="color:rgb(44, 62, 80);">客户端收到服务端的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 应答报文后，之后进入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN_WAIT_2&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。</font></li>
<li><font style="color:rgb(44, 62, 80);">等待服务端处理完数据后，也向客户端发送 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文，之后服务端进入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;LAST_ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态。</font></li>
<li><font style="color:rgb(44, 62, 80);">客户端收到服务端的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文后，回一个 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 应答报文，之后进入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;TIME_WAIT&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态</font></li>
<li><font style="color:rgb(44, 62, 80);">服务端收到了 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 应答报文后，就进入了 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;CLOSE&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态，至此服务端已经完成连接的关闭。</font></li>
<li><font style="color:rgb(44, 62, 80);">客户端在经过 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;2MSL&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 一段时间后，自动进入 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;CLOSE&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 状态，至此客户端也完成连接的关闭。</font></li>
</ul>
<p><font style="color:rgb(44, 62, 80);">这里一点需要注意是：</font><strong><font style="color:rgb(48, 79, 254);">主动关闭连接的，才有 TIME_WAIT 状态。</font></strong></p>
<h2 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h2><p><font style="color:rgb(44, 62, 80);">回顾下四次挥手双方发 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 包的过程，就能理解为什么需要四次了。</font></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">关闭连接时，客户端向服务端发送 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</font></li>
<li><font style="color:rgb(44, 62, 80);">服务端收到客户端的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文时，先回一个 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 报文给客户端来表示同意现在关闭连接。</font></li>
</ul>
<p><font style="color:rgb(44, 62, 80);">从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;ACK&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 和 </font><code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgba(27, 31, 35, 0.05);&quot;&gt;FIN&lt;/font&gt;</code><font style="color:rgb(44, 62, 80);"> 一般都会分开发送，因此是需要四次挥手。但是</font><strong><font style="color:rgb(48, 79, 254);">在特定情况下，四次挥手是可以变成三次挥手的</font></strong></p>
<h2 id="什么情况下TCP的四次挥手会变为三次"><a href="#什么情况下TCP的四次挥手会变为三次" class="headerlink" title="什么情况下TCP的四次挥手会变为三次"></a>什么情况下TCP的四次挥手会变为三次</h2><p><font style="color:rgb(44, 62, 80);">当被动关闭方（上图的服务端）在 TCP 挥手过程中，「</font><strong><font style="color:rgb(48, 79, 254);">没有数据要发送」并且「开启了 TCP 延迟确认机制」（默认开启），那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</font></strong></p>
<h3 id="什么是TCP延迟确认机制"><a href="#什么是TCP延迟确认机制" class="headerlink" title="什么是TCP延迟确认机制"></a>什么是TCP延迟确认机制</h3><p> 当发送的 ACK 报文<strong>不携带数据</strong>时，其网络开销较高（IP 头 + TCP 头约 40 字节），但却<strong>没有实际数据负载</strong>，效率较低。<br>为提高 ACK 的传输效率，TCP 引入了 <strong>延迟确认机制（Delayed ACK）</strong>。  </p>
<ul>
<li><font style="color:rgb(44, 62, 80);">当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</font></li>
<li><font style="color:rgb(44, 62, 80);">当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</font></li>
<li><font style="color:rgb(44, 62, 80);">如果在延迟等待发送 ACK 期间，</font><font style="color:rgb(44, 62, 80);">对方的第二个数据报文又到达了，这时就会立刻发送 ACK</font></li>
</ul>
<h2 id="为什么主动断开连接的一方会出现time-wait状态"><a href="#为什么主动断开连接的一方会出现time-wait状态" class="headerlink" title="为什么主动断开连接的一方会出现time_wait状态"></a>为什么主动断开连接的一方会出现time_wait状态</h2><ol>
<li>防止最后的ack丢失</li>
</ol>
<p><font style="color:rgb(25, 27, 31);">我们把主动断开连接的一方称为C端，被动断开连接的一方称为S端，由于网络不可靠，C端发送的最后一个ACK报文可能没成功发送到S端，那么S端就会重新发上一个报文即FIN，如果C端处于TIME_WAIT状态下，就可以重新发送报文ACK，然后重新计时2MSL时间才会进入CLOSED状态</font></p>
<ol start="2">
<li>防止网络中滞留的包影响新连接</li>
</ol>
<p> 如果因为网络延迟，旧连接中的 TCP 报文还滞留在网络中，而 <strong>客户端主动关闭连接后立即重连、且没有 TIME_WAIT 状态</strong>，那么它可能会 <strong>收到上一个连接遗留的旧包</strong>。<br>这些旧包的四元组（源 IP、源端口、目的 IP、目的端口）与新连接完全相同，且序号可能落入新连接的窗口范围，于是就会被误当成新连接的数据，造成<strong>数据混乱</strong>。  </p>
<h1 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h1><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763535019834-24d5c3eb-b0db-496e-9544-7bc5014e5fff.png"></p>
<ul>
<li>主机A发送数据给B之后，可能因为网络原因数据无法到达B</li>
<li>如果主机A在一个特定的<font style="color:#DF2A3F;">时间间隔</font>内没有收到B的确认应答，就会进行重发</li>
</ul>
<p>注意超时的时间间隔不是一个固定的数，而是会动态的计算的，因为网络环境是会变化的。比如以500ms作为一个单位，如果一次之后，仍然得不到应带，就等待2<em>500ms，4</em>500ms…</p>
<h1 id="TCP每次发送多少报文数据"><a href="#TCP每次发送多少报文数据" class="headerlink" title="TCP每次发送多少报文数据"></a>TCP每次发送多少报文数据</h1><p>TCP是面向字节流的，它每次发送的字节数并不是固定的，而是取决于当前可用窗口的大小，发送的时候会按MSS（最大报文段长度）进行拆分，比如当前MSS&#x3D;1460，字节，可用窗口为5000字节，那么发送端会一次发出5000字节，但拆成多个MSS大小的报文段</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p> 滑动窗口就是让 TCP 在没等 ACK 的情况下也能连续发好多数据，并随着 ACK 的到来把窗口往前推。  它解决了对每一个发送报文，都要等一个ack确认应答，收到ack 确认应答后才能再发送下一个数据段这样的问题</p>
<p>例如：主机A的滑动窗口大小是4000，假设它现在要发送四个MSS（醉倒报文长度）的报文 1 2 3 4，这是会出现两种情况</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763535448399-8caefdf5-97df-44fc-9ab5-cd350f3586ab.png"></p>
<ol>
<li>数据包已经抵达，但是ack 丢了</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763535788530-e7ae5fb2-0060-40e3-8597-552b3a64db7b.png"></p>
<p>部分ack 丢失不要紧，因为可以通过后续的ack 进行确认，如果ack 都丢了客户端则会认为是数据包丢失，会直接重传数据包也就是下面这种情况</p>
<ol start="2">
<li>数据包丢失</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763535885281-33e970f9-160d-4d23-a921-d8fc37e33c6f.png"></p>
<h2 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h2><ul>
<li>假设1001-2000数据包丢失了，这时候主机B在收到1-1000之后会发送ack&#x3D;1001，然后再收到2001-3000，30001-4000…数据包依旧会发送ack&#x3D;1001（ ACK 的含义：我已经收到所有序号小于 ACK 的数据，下一次想要收到的序号就是 ACK。   ）</li>
<li>如果发送端主机连续三次收到了同样⼀个”1001”这样的应答,就会将对应的数据1001-2000重 新发送; </li>
<li>这个时候接收端收到了1001之后,再次返回的ACK就是7001了(因为2001-7000)接收端其实之前 就已经收到了,被放到了接收端操作系统内核的接收缓冲区中</li>
</ul>
<p>即使没有连续收到相同的ack 应答触发快重传，tcp 也会进行超时重传来保证数据包的抵达  </p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p> TCP 流量控制用的是报文头的“窗口大小（Window Size）字段”，接收端通过调整该字段告诉发送端自己还能接收多少数据。  发送端会根据这个窗口大小适当调整自己的发送速度，如果接收端缓冲区满了，就会将窗口设置为0，发送端就会停止发送数据</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p> 拥塞控制的目的：防止网络本身被压垮。因为发送端不知道当前网络能承受多大流量，所以一开始先发少量数据试探，如果网络情况良好就快速（指数）增加发送速度<font style="color:#DF2A3F;">（慢启动，快增长）</font>；一旦出现丢包就减速。  </p>
<h1 id="滑动窗口与流量控制，拥塞控制之间的关系"><a href="#滑动窗口与流量控制，拥塞控制之间的关系" class="headerlink" title="滑动窗口与流量控制，拥塞控制之间的关系"></a>滑动窗口与流量控制，拥塞控制之间的关系</h1><p> 滑动窗口 &#x3D; 怎么发<br>流量控制 &#x3D; 接收端能不能扛住<br>拥塞控制 &#x3D; 网络能不能扛住  </p>
<p>滑动窗口的大小&#x3D;min（流量控制，拥塞控制）， 滑动窗口本质是一个概念，它的实际大小由拥塞控制和流量控制的最小值决定。  </p>
<h1 id="延迟应答与捎带应答"><a href="#延迟应答与捎带应答" class="headerlink" title="延迟应答与捎带应答"></a>延迟应答与捎带应答</h1><ol>
<li>延迟应答：为了减少 ACK 数量，TCP 会故意等一小段时间再发 ACK。</li>
<li>捎带应答：当需要发送数据时顺便把 ACK 一起带上，不单独发 ACK。</li>
</ol>
<h1 id="TCP和UDP可以同时使用同一个端口么？"><a href="#TCP和UDP可以同时使用同一个端口么？" class="headerlink" title="TCP和UDP可以同时使用同一个端口么？"></a><font style="color:rgb(44, 62, 80);">TCP和UDP可以同时使用同一个端口么？</font></h1><p><font style="color:rgb(44, 62, 80);">可以的，因为操作系统是按照协议(UDP&#x2F;TCP)+端口号来定位监听进程的，而不是只看端口号</font></p>
<h1 id=""><a href="#" class="headerlink" title=""></a><font style="color:rgb(44, 62, 80);"></h1><p></font><font style="color:rgb(44, 62, 80);"> 多个TCP 可以绑定同一个端口么？</font><br> 同一个端口能被多个进程绑定，但前提是它们绑定的 IP 必须不同；而 <code>0.0.0.0</code> 会占用所有 IP 的该端口，因此会与任何具体 IP 冲突。  </p>
<h1 id="半连接队列和全连接队列"><a href="#半连接队列和全连接队列" class="headerlink" title="半连接队列和全连接队列"></a>半连接队列和全连接队列</h1><ol>
<li>半连接队列： 也叫 <strong>SYN Queue</strong><br>在 <strong>客户端发来 SYN → 服务端回 SYN+ACK</strong> 之后、<strong>客户端 ACK 还没回来前</strong>，连接会被内核放到这个队列中。  </li>
<li>全连接队列：也叫 <strong>Accept Queue</strong><br>当服务端收到客户端的最后一个 ACK（第三次握手）后：内核把连接从 半连接队列移除，创建一个完全建立的连接，放入全连接队列，<strong>等待进程调用 accept 函数时把连接取出来。</strong></li>
</ol>
<h2 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h2><ol>
<li>查看半连接队列大小: <strong>sysctl net.ipv4.tcp_max_syn_backlog</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763607915016-15e8af44-a2eb-4f7f-a008-dd45fc32fd80.png"></p>
<p><em>说明半连接队列大小是 256。</em></p>
<ol start="2">
<li>修改半连接队列：</li>
</ol>
<p><strong>sudo sysctl -w net.ipv4.tcp_max_syn_backlog&#x3D;1024（临时）</strong></p>
<p><strong>写入 &#x2F;etc&#x2F;sysctl.conf 配置文件（永久生效）</strong></p>
<h2 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h2><p>全连接队列大小有两个因素控制</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>net.core.somaxconn</strong></td>
<td>全连接队列最大长度（accept queue 上限）</td>
</tr>
<tr>
<td><strong>listen(fd, backlog)</strong></td>
<td>程序在 listen() 时传入的 backlog 值</td>
</tr>
</tbody></table>
<p> 最终大小 &#x3D; <strong>min(somaxconn, listen backlog)</strong></p>
<ol>
<li>查看全连接队列大小：  <strong>sysctl net.core.somaxconn</strong></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763608052837-0b5b7bd6-43c0-4400-8336-d82755da6468.png"></p>
<p>_ 表示全连接队列最大长度是 128。  _</p>
<ol start="2">
<li>修改全连接队列大小：</li>
</ol>
<p><strong>sudo sysctl -w net.core.somaxconn&#x3D;1024 （临时）</strong></p>
<p><strong>写入&#x2F;etc&#x2F;sysctl.conf 配置文件（永久生效）</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/SSE%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/SSE%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93/" class="post-title-link" itemprop="url">SSE流式传输</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么时SSE，和websocket-的区别是什么"><a href="#什么时SSE，和websocket-的区别是什么" class="headerlink" title="什么时SSE，和websocket 的区别是什么"></a>什么时SSE，和websocket 的区别是什么</h1><ol>
<li><strong>SSE（Server-Sent Events）是单向通信</strong> —— 服务器可以主动向客户端推送消息，适合服务器主动推送消息但客户端不需要回传的场景（例如AI回复流式输出）</li>
<li><strong>WebSocket 是双向通信</strong> —— 客户端和服务器都能主动发送消息。 适合双向实时通信的场景比如语音通话</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/linux_%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/linux_%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">linux 网络常用命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ss 是一个查看网络连接、端口占用、路由表、网络状态的命令行工具。  它比netstat 更高效</p>
<ol>
<li>ss -tunlp</li>
</ol>
<p>含义</p>
<ul>
<li><code>t</code> &#x3D; TCP</li>
<li><code>u</code> &#x3D; UDP</li>
<li><code>n</code> &#x3D; <strong>不要把 IP&#x2F;端口 解析成域名&#x2F;服务名</strong>，直接用数字显示  不加 <code>-n</code> 时：可能把 <code>80</code> 显示成 <code>http</code></li>
<li><code>l</code> &#x3D;  只显示处于 <strong>监听状态</strong> 的 socket  </li>
<li><code>a</code> &#x3D; 显示所有socekt 状态（包括监听状态和非监听状态）</li>
<li><code>p</code> &#x3D; 显示进程名和 PID</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
