<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="刘翰霖">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">刘翰霖</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是java-中的注解"><a href="#什么是java-中的注解" class="headerlink" title="什么是java 中的注解"></a>什么是java 中的注解</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注解存活时间</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//注解贴在哪里</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">    //注解内部变量</span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Java 注解本质上就是一种特殊的 interface（继承 Annotation），编译后会存进类的“元信息”（class 文件的结构里），运行时可以被 JVM 或反射读取。  </p>
<ol>
<li>注解&#x3D;特殊的接口</li>
</ol>
<p>当写</p>
<p>public @interface MyAnno {}</p>
<br/>

<p>编译器实际上会帮你生成</p>
<p>public interface MyAnno extends java.lang.annotation.Annotation {</p>
<p>}</p>
<br/>

<ol start="2">
<li>注解存在class 的”元数据”中</li>
</ol>
<p>“元信息”&#x3D;class 文件里描述类的信息,比如</p>
<ul>
<li>类名</li>
<li>字段</li>
<li>方法</li>
<li>注解</li>
<li>泛型信息</li>
<li>访问修饰符</li>
</ul>
<p>因此，注解不是 Java 运行时对象，而是 class 文件的一部分。</p>
<h1 id="注解贴在哪里"><a href="#注解贴在哪里" class="headerlink" title="注解贴在哪里"></a>注解贴在哪里</h1><p>@Target 参数可以表示注解贴在什么位置，常见的有类，接口，成员变量，构造方法…,以下是最常用的</p>
<table>
<thead>
<tr>
<th>常用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>TYPE</code></td>
<td>类、接口上</td>
</tr>
<tr>
<td><code>METHOD</code></td>
<td>方法上</td>
</tr>
<tr>
<td><code>FIELD</code></td>
<td>字段上</td>
</tr>
<tr>
<td><code>PARAMETER</code></td>
<td>方法参数上</td>
</tr>
</tbody></table>
<p>@Target 也可以同时指定多个位置</p>
<p>@Target({ElementType.TYPE, ElementType.METHOD})</p>
<p>public @interface MyAnno {}</p>
<br/>

<h1 id="注解能活多久"><a href="#注解能活多久" class="headerlink" title="注解能活多久"></a>注解能活多久</h1><p>比如</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>public @interface MyAnno {}</p>
<br/>

<p>MyAnno会一直存在到运行时，因此可以通过反射取出来</p>
<p>而像@Override  </p>
<p>@Retention(SOURCE)</p>
<br/>

<p>意思是:编译后就没了，反射根本拿不到它</p>
<p>下面是常见的@Retention 参数</p>
<table>
<thead>
<tr>
<th><strong>RetentionPolicy</strong></th>
<th><strong>注解保留到什么阶段？</strong></th>
<th><strong>能否通过反射读取？</strong></th>
<th><strong>典型用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SOURCE</strong></td>
<td>只在源码中存在，编译后丢弃</td>
<td>❌ 不能</td>
<td><code>@Override</code><br/>、<code>@SuppressWarnings</code></td>
</tr>
<tr>
<td><strong>CLASS</strong>（默认）</td>
<td>编译后写进 class 文件，但运行时丢弃</td>
<td>❌ 不能</td>
<td>大部分普通注解，供编译器&#x2F;字节码工具用</td>
</tr>
<tr>
<td><strong>RUNTIME</strong></td>
<td>一直保留到运行时</td>
<td>✔ 可以</td>
<td>Spring、MyBatis、JUnit 的注解</td>
</tr>
</tbody></table>
<h1 id="通过反射获取注解信息"><a href="#通过反射获取注解信息" class="headerlink" title="通过反射获取注解信息"></a>通过反射获取注解信息</h1><ol>
<li>类上的</li>
</ol>
<p>Class&lt;?&gt; clazz &#x3D; User.class;</p>
<p>MyAnno anno &#x3D; clazz.getAnnotation(MyAnno.class);</p>
<br/>

<ol start="2">
<li>方法上的</li>
</ol>
<p>Method m &#x3D; clazz.getMethod(“test”);</p>
<p>MyAnno anno &#x3D; m.getAnnotation(MyAnno.class);</p>
<br/>

<ol start="3">
<li>字段上的</li>
</ol>
<p>Field f &#x3D; clazz.getDeclaredField(“name”);</p>
<p>MyAnno anno &#x3D; f.getAnnotation(MyAnno.class);</p>
<br/>

<ol start="4">
<li>参数上的</li>
</ol>
<p>Parameter p &#x3D; m.getParameters()[0];</p>
<p>MyAnno anno &#x3D; p.getAnnotation(MyAnno.class);</p>
<br/>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍反射之前，首先了解类对象（Class-对象）"><a href="#介绍反射之前，首先了解类对象（Class-对象）" class="headerlink" title="介绍反射之前，首先了解类对象（Class 对象）"></a>介绍反射之前，首先了解类对象（Class 对象）</h1><p>在Java 里，类（Class） 本身也是一个对象（注意这个类指的是类本身而不是类实例）</p>
<p>比如有个类</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line"><span class="code">    String name;</span></span><br><span class="line"><span class="code">    void sayHello() &#123;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Hi, I&#x27;m &quot; + name);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们平常会这样用：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student s = new Student();</span><br><span class="line">s.name = &quot;小明&quot;;</span><br><span class="line">s.sayHello();   // 输出：Hi, I&#x27;m 小明</span><br></pre></td></tr></table></figure>

<p>但实际上，JVM在运行时还会为每个类生成一个描述它的对象，类型是java.lang.Class</p>
<p>你可以这样拿到它</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Student.class;</span><br><span class="line">System.out.println(clazz.getName());  // 输出：Student</span><br></pre></td></tr></table></figure>

<p>这个clazz就是“类对象”，它保存了Student 类的所有信息，比如</p>
<ul>
<li>类名</li>
<li>字段（成员变量）</li>
<li>方法</li>
<li>构造方法</li>
<li>修饰符（public、private等）</li>
</ul>
<h1 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h1><p>反射指的是程序在运行时，可以动态地获取类的信息，并且操作这个类的属性和方法。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>假设你 只有类名“Student” 这个字符串，但你要创建对象并调用方法</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 根据类名加载类对象</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;Student&quot;);</span><br><span class="line"></span><br><span class="line">// 2. 创建对象（相当于 new Student()）</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">// 3. 获取属性并设置值</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);   // 暴力访问私有字段</span><br><span class="line">field.set(obj, &quot;小明&quot;);</span><br><span class="line"></span><br><span class="line">// 4. 调用方法</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;sayHello&quot;);</span><br><span class="line">method.invoke(obj);  // 输出：Hi, I&#x27;m 小明</span><br></pre></td></tr></table></figure>



<h1 id="反射和new的区别"><a href="#反射和new的区别" class="headerlink" title="反射和new的区别"></a>反射和new的区别</h1><h2 id="new-时编译器确定的"><a href="#new-时编译器确定的" class="headerlink" title="new 时编译器确定的"></a>new 时编译器确定的</h2><p>当你写 Student s&#x3D; new Student();</p>
<p>编译器要在编译阶段就知道:</p>
<ul>
<li>要创建的是 <code>Student</code>；</li>
<li>它有哪些构造方法；</li>
<li>它有哪些字段和方法。</li>
</ul>
<p> 所以编译器会<strong>生成固定的字节码</strong>，直接在运行时执行。   也就是说，“类名”在编译时是<strong>写死的</strong>。  </p>
<h2 id="反射是运行期决定的"><a href="#反射是运行期决定的" class="headerlink" title="反射是运行期决定的"></a>反射是运行期决定的</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String className = &quot;com.example.Student&quot;;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">Object obj = clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p> 假如你写一个“支付系统”，有两种支付方式：  </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class WechatPay &#123; void pay() &#123; System.out.println(&quot;微信支付&quot;); &#125; &#125;</span><br><span class="line">class Alipay   &#123; void pay() &#123; System.out.println(&quot;支付宝支付&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="用new"><a href="#用new" class="headerlink" title="用new"></a>用new</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WechatPay pay = new WechatPay();</span><br><span class="line">pay.pay();</span><br></pre></td></tr></table></figure>

<p>只能写死用微信</p>
<h3 id="🚀-用反射（根据配置）："><a href="#🚀-用反射（根据配置）：" class="headerlink" title="🚀 用反射（根据配置）："></a>🚀 用反射（根据配置）：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String className = &quot;Alipay&quot;; // 从配置文件里读出来的</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;pay&quot;);</span><br><span class="line">method.invoke(obj); // 输出：支付宝支付</span><br></pre></td></tr></table></figure>

<p> 你甚至不用改代码，只要改配置文件里的类名，系统就能自动用不同的支付方式。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E4%B9%9F%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E4%B9%9F%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>在java中直接&#x3D;&#x3D;比较的是两个对象的jvm内存地址(java没有运算符重载),因此若要实现逻辑比较需要重写equals方法，默认的equals也是比较的jvm内存地址</strong></p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>hashCode是一个hash摘要</p>
<p>它的工作是:</p>
<ol>
<li>输入一个对象</li>
<li>输出一个整数用于hash的取模运算（ 这个整数就是这个对象的哈希码（hash code）。它的主要目的，就是为了在 <code>HashMap</code> 和 <code>HashSet</code> 这样的集合中实现<strong>快速查找</strong>。  ）</li>
</ol>
<p>这里就体现了java和c++的设计思路不同</p>
<ul>
<li><strong>Java 的思路</strong>：Java 认为“万物皆对象”，并且任何对象都应该有可能被存放到哈希集合里。所以，它在所有对象的祖先 <code>Object</code> 类里直接内置了 hashCode方法用于hash的取模运算。</li>
<li><strong>C++ 的思路</strong>：C++ 遵循“你不需要为你不用的东西付出代价”的原则。它不强制每个类都继承自某个共同的基类。当你需要把你的自定义类（比如 <code>class Person</code>）放进 <code>std::unordered_map</code> 时，你需要<strong>另外</strong>为这个类提供一个哈希函数给容器，而不是在 <code>Person</code> 类里重写一个方法。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">publicinthashCode()&#123; </span><br><span class="line">return Objects.hash(id, name);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="为什么重写equals方法时也必须重写hashCode"><a href="#为什么重写equals方法时也必须重写hashCode" class="headerlink" title="为什么重写equals方法时也必须重写hashCode"></a>为什么重写equals方法时也必须重写hashCode</h2><p>因为在java中使用hash数据结构时,hash值的比较有以下规则</p>
<ol>
<li>先使用hashCode 比较</li>
<li>若hashCode方法比较结果相同在调用equals 方法比较</li>
</ol>
<h3 id="为什么会有这两个规则呢？"><a href="#为什么会有这两个规则呢？" class="headerlink" title="为什么会有这两个规则呢？"></a>为什么会有这两个规则呢？</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1759294316889-321c642f-14d4-4c88-a255-73635fa4a1d9.png"></p>
<h3 id="那么知道equals-的默认实现是比较jvm内存地址-那hashCode的默认实现呢？"><a href="#那么知道equals-的默认实现是比较jvm内存地址-那hashCode的默认实现呢？" class="headerlink" title="那么知道equals 的默认实现是比较jvm内存地址,那hashCode的默认实现呢？"></a>那么知道equals 的默认实现是比较jvm内存地址,那hashCode的默认实现呢？</h3><p>Java 语言规范<strong>并没有严格规定</strong>默认的 <code>hashCode()</code> 必须如何实现，所以不同的 JVM 版本或提供商（比如 Oracle, OpenJDK）可能会有不同的实现方式。</p>
<p>不过，通常情况下，默认的 <code>hashCode()</code> 方法返回的整数是根据对象的<strong>内存地址</strong>计算得出的。</p>
<h2 id="如何重写hashCode方法"><a href="#如何重写hashCode方法" class="headerlink" title="如何重写hashCode方法"></a>如何重写hashCode方法</h2><h3 id="使用Object-hash方法（推荐）"><a href="#使用Object-hash方法（推荐）" class="headerlink" title="使用Object.hash方法（推荐）"></a>使用Object.hash方法（推荐）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line"><span class="code">    private String name;</span></span><br><span class="line"><span class="code">    private int age;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 重写 equals 方法</span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="code">        if (this == o) return true;</span></span><br><span class="line"><span class="code">        if (!(o instanceof Person)) return false;</span></span><br><span class="line"><span class="code">        Person person = (Person) o;</span></span><br><span class="line"><span class="code">        return age == person.age &amp;&amp; Objects.equals(name, person.name);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 重写 hashCode 方法</span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    public int hashCode() &#123;</span></span><br><span class="line"><span class="code">        return Objects.hash(name, age);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Objects.hash(...)</code> 内部会自动组合字段值并生成稳定的哈希码，写法简洁安全。  </p>
<h4 id="objects-hash-方法"><a href="#objects-hash-方法" class="headerlink" title="objects.hash()方法"></a>objects.hash()方法</h4><ul>
<li><code>Objects.hash()</code> 方法可以接受 <strong>任意数量的参数</strong>（包括基本类型的包装类、<code>String</code>、自定义对象，甚至 <code>null</code>）。</li>
<li>当参数是对象类型时，会<strong>自动调用其 <strong><code>**hashCode()**</code></strong> 方法</strong>；若该对象内部也包含自定义字段，会<strong>递归计算哈希值</strong>。</li>
<li>因此，<strong>自定义对象应正确重写 <strong><code>**hashCode()**</code></strong> 方法</strong>，以确保整体哈希值的正确性与稳定性。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/volatile_%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/volatile_%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:42 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:42+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>volatile</code> 关键字的主要作用是 <strong>保证变量的可见性</strong>，并在一定程度上<strong>禁止指令重排序</strong>，从而在多线程环境中确保变量读写的正确性。  </p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p> 在现代多核CPU架构中，为了提高效率，每个线程可能会有自己的<strong>工作内存（CPU缓存）</strong>。当一个线程修改一个变量时，它可能只是先修改了自己缓存中的副本，并没有立刻写回到主内存中。这就导致其他线程看不到这个更新，它们还在使用自己缓存里那个旧的、过时的数据。  </p>
<p><code>**volatile**</code>** 如何解决？**<code>volatile</code> 就像一个“广播员”，它强制规定：</p>
<ul>
<li><strong>写操作</strong>：当一个线程修改一个<code>volatile</code>变量时，它必须<strong>立即</strong>将这个修改写回到主内存。</li>
<li><strong>读操作</strong>：当一个线程读取一个<code>volatile</code>变量时，它必须<strong>立即</strong>从主内存中读取最新值，而不是使用自己的缓存。</li>
</ul>
<p>通过这种方式，<code>volatile</code> 确保了一个线程对变量的修改对其他所有线程都是“可见”的。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Task implements Runnable &#123;</span><br><span class="line"><span class="code">    private boolean running = true; // 没有 volatile</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    public void stop() &#123;</span></span><br><span class="line"><span class="code">        this.running = false;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Stop method called. running is now &quot; + this.running);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    public void run() &#123;</span></span><br><span class="line"><span class="code">        while (running) &#123;</span></span><br><span class="line"><span class="code">            // ... 持续执行任务 ...</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Task finished.&quot;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">public class Main &#123;</span><br><span class="line"><span class="code">    public static void main(String[] args) throws InterruptedException &#123;</span></span><br><span class="line"><span class="code">        Task myTask = new Task();</span></span><br><span class="line"><span class="code">        Thread taskThread = new Thread(myTask);</span></span><br><span class="line"><span class="code">        taskThread.start();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        Thread.sleep(100); // 确保子线程已经开始运行</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        myTask.stop(); // 主线程请求停止</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Main thread finished.&quot;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>可能出现的问题：</strong><code>taskThread</code>可能将<code>running = true</code>缓存到了自己的工作内存中。当<code>main</code>线程调用<code>stop()</code>方法将主内存中的<code>running</code>改为<code>false</code>时，<code>taskThread</code>可能永远也看不到这个变化，导致<code>while (running)</code>循环变成死循环，程序无法结束。</p>
<p><strong>使用 <strong><code>**volatile**</code></strong> 修正：</strong> 只需要一个简单的修改： <code>private volatile boolean running = true;</code></p>
<p>加上<code>volatile</code>之后，<code>main</code>线程对<code>running</code>的修改会立刻同步到主内存，而<code>taskThread</code>在每次循环判断<code>running</code>时，都会从主内存读取最新值。因此，它一定能看到<code>running</code>变成了<code>false</code>，从而正常退出循环。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="1-什么是指令重排序？"><a href="#1-什么是指令重排序？" class="headerlink" title="1. 什么是指令重排序？"></a>1. 什么是指令重排序？</h3><p>为了提高处理性能，<strong>编译器</strong>和**处理器（CPU）**在不改变单线程程序执行结果的前提下，可能会对我们写的代码指令进行重新排序。</p>
<p>** 举个简单的单线程例子：  **</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;  // 指令1</span><br><span class="line">int b = 2;  // 指令2</span><br><span class="line">a = a + 5;  // 指令3</span><br><span class="line">b = b * b;  // 指令4</span><br></pre></td></tr></table></figure>

<p>在处理器看来，指令3依赖于指令1，指令4依赖于指令2，但指令1和2之间、3和4之间、1和4之间都没有依赖关系。为了优化，处理器完全可能按照 <code>1 -&gt; 2 -&gt; 4 -&gt; 3</code> 或者 <code>2 -&gt; 1 -&gt; 3 -&gt; 4</code> 的顺序来执行，只要最终结果和代码顺序执行的结果一致就行。</p>
<p>在<strong>单线程</strong>环境下，这种重排序是安全的，我们几乎感知不到。但在<strong>多线程</strong>环境下，它就是一颗“定时炸弹”。</p>
<h3 id="2-volatile-如何保证有序性？"><a href="#2-volatile-如何保证有序性？" class="headerlink" title="2. volatile 如何保证有序性？"></a>2. <code>volatile</code> 如何保证有序性？</h3><p><code>volatile</code>关键字通过引入<strong>内存屏障 (Memory Barriers)</strong> 来解决重排序问题。内存屏障可以理解为一个指令，它告诉CPU和编译器：</p>
<ol>
<li>屏障<strong>之前</strong>的所有读写操作都必须在屏障<strong>之后</strong>的读写操作之前完成。</li>
<li>禁止将屏障<strong>之后</strong>的指令重排序到屏障<strong>之前</strong>。</li>
</ol>
<p><code>volatile</code>通过以下两个方面的内存屏障来保证有序性：</p>
<ul>
<li><strong>当对一个</strong><code>**volatile**</code><strong>变量进行写操作时：</strong><ol>
<li>JIT编译器会在<strong>写操作之前</strong>插入一个<strong>StoreStore屏障</strong>，确保在此之前的所有普通写操作都已经完成。</li>
<li>JIT编译器会在<strong>写操作之后</strong>插入一个<strong>StoreLoad屏障</strong>，防止后面的读写操作被重排序到<code>volatile</code>写之前。</li>
</ol>
</li>
<li><strong>当对一个</strong><code>**volatile**</code><strong>变量进行读操作时：</strong><ol>
<li>JIT编译器会在<strong>读操作之后</strong>插入一个<strong>LoadLoad屏障</strong>和<strong>LoadStore屏障</strong>，确保在此之后的读写操作不会被重排序到<code>volatile</code>读之前。</li>
</ol>
</li>
</ul>
<p>简单来说，<code>volatile</code>就像在代码中画了一条线，这条线前后的指令不能随意跨越。</p>
<h3 id="3-经典案例：双重检查锁定-Double-Checked-Locking-的单例模式"><a href="#3-经典案例：双重检查锁定-Double-Checked-Locking-的单例模式" class="headerlink" title="3. 经典案例：双重检查锁定 (Double-Checked Locking) 的单例模式"></a>3. 经典案例：双重检查锁定 (Double-Checked Locking) 的单例模式</h3><p>这是解释<code>volatile</code>有序性最经典的例子。</p>
<p><strong>一个有问题的DCL单例实现（没有</strong><code>**volatile**</code><strong>）：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"><span class="code">    private static Singleton instance; // 没有 volatile</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    private Singleton() &#123;&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    public static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="code">        if (instance == null) &#123; // 第一次检查</span></span><br><span class="line"><span class="code">            synchronized (Singleton.class) &#123;</span></span><br><span class="line"><span class="code">                if (instance == null) &#123; // 第二次检查</span></span><br><span class="line"><span class="code">                    instance = new Singleton(); // 问题根源</span></span><br><span class="line"><span class="code">                &#125;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        return instance;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题出在哪里？</strong><code>instance = new Singleton();</code> 这行代码看起来是一步操作，但它在JVM中大致分为三步：</p>
<ol>
<li><strong>分配内存</strong>：为<code>Singleton</code>对象分配一块内存空间。</li>
<li><strong>初始化对象</strong>：调用<code>Singleton</code>的构造方法，初始化成员字段。</li>
<li><strong>建立引用</strong>：将<code>instance</code>变量指向刚刚分配的内存地址。</li>
</ol>
<p>由于指令重排序的存在，这三步的执行顺序可能是 <code>1 -&gt; 2 -&gt; 3</code>（正常顺序），也可能是 <code>1 -&gt; 3 -&gt; 2</code>（重排后的顺序）。</p>
<p><strong>多线程下的致命错误：</strong> 假设有两个线程A和B。</p>
<ol>
<li>线程A进入同步块，执行 <code>instance = new Singleton();</code>。</li>
<li>发生了重排序，JVM先执行了第1步（分配内存）和第3步（建立引用）。此时，<code>instance</code>变量已经<strong>不再是 <strong><code>**null**</code></strong> 了</strong>，但它指向的对象还<strong>没有被初始化</strong>（第2步还没执行）。</li>
<li>就在这一刻，线程B来了，它执行到第一次检查 <code>if (instance == null)</code>。</li>
<li>线程B发现<code>instance</code>不是<code>null</code>，于是跳过同步块，直接返回了<code>instance</code>。</li>
<li>但是，这个<code>instance</code>是一个<strong>没有被初始化完成的“半成品”对象</strong>。如果线程B此时去使用这个对象的任何成员变量，都可能会引发错误（比如空指针异常）。</li>
<li><strong>如何用</strong><code>**volatile**</code><strong>修正？</strong> 只需要一个简单的修改： <code>private volatile static Singleton instance;</code></li>
</ol>
<p>加上<code>volatile</code>之后，内存屏障会确保<code>instance = new Singleton();</code>这行代码的内部指令<strong>不会被重排序</strong>。它会强制保证第2步（初始化对象）一定在第3步（建立引用）之前完成。 这样，当其他线程看到<code>instance</code>不为<code>null</code>时，它们拿到的一定是一个已经完整构造好的对象，从而避免了上述问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/Stream/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:42 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:42+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h1><p>Stream 就像一条流水线，你把数据放进去，然后经过各种加步骤（filter&#x2F;map）,最后输出结果(forEach&#x2F;collect)</p>
<h1 id="Stream的三个核心点"><a href="#Stream的三个核心点" class="headerlink" title="Stream的三个核心点"></a>Stream的三个核心点</h1><ol>
<li>不会修改原集合,stream是”读取”,不是”改写”</li>
<li>一步一步串起来执行（像流水线）</li>
<li>最终必须有一个“终止操作”才能真正执行，没有终止操作，流水线不会运作</li>
</ol>
<h1 id="如何创建Stream"><a href="#如何创建Stream" class="headerlink" title="如何创建Stream"></a>如何创建Stream</h1><ol>
<li>从集合创建（最常用）</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List<span class="language-xml"><span class="tag">&lt;<span class="name">Integer</span>&gt;</span></span> list = List.of(1, 2, 3);</span><br><span class="line">Stream<span class="language-xml"><span class="tag">&lt;<span class="name">Integer</span>&gt;</span></span> stream = list.stream();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从数组创建</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">IntStream stream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>直接创建（开发里不太常用）</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="language-xml"><span class="tag">&lt;<span class="name">String</span>&gt;</span></span> stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="数据加工"><a href="#数据加工" class="headerlink" title="数据加工"></a>数据加工</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:42 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:42+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是运行时数据区？"><a href="#什么是运行时数据区？" class="headerlink" title="什么是运行时数据区？"></a>什么是运行时数据区？</h2><p> 当 Java 程序运行时，JVM 会在内存中划分出一块区域，用来管理执行所需的各种数据。<br>这块区域就叫 <strong>运行时数据区（Runtime Data Areas）</strong>。  </p>
<p>它包含了：</p>
<ul>
<li>程序计数器（Program Counter）</li>
<li>Java 虚拟机栈（JVM Stack）</li>
<li>本地方法栈（Native Method Stack）</li>
<li>堆（Heap）</li>
<li>方法区（Method Area &#x2F; 元空间 Metaspace）</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1762180009710-8f4cf25f-e7e7-4295-885c-0f620b6c2b6b.png"></li>
</ul>
<h1 id="区域详解"><a href="#区域详解" class="headerlink" title="区域详解"></a>区域详解</h1><h2 id="线程私有的"><a href="#线程私有的" class="headerlink" title="线程私有的"></a>线程私有的</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>程序计数器（PC Register）作用：<strong>用于记录</strong>下一条将要执行的指令位置</strong>。</p>
<ul>
<li><strong>CPU 的 PC 寄存器</strong>：指向<strong>下一条机器指令的内存地址</strong>。</li>
<li><strong>JVM 的程序计数器</strong>：指向<strong>下一条字节码指令的位置</strong>。</li>
</ul>
<p> 两者功能相同，但层级不同：CPU 的属于<strong>硬件层</strong>，JVM 的属于<strong>虚拟机软件层</strong>。  </p>
<h4 id="为什么cpu有pc-寄存器，jvm-还需要一个程序计数器呢"><a href="#为什么cpu有pc-寄存器，jvm-还需要一个程序计数器呢" class="headerlink" title="为什么cpu有pc 寄存器，jvm 还需要一个程序计数器呢"></a>为什么cpu有pc 寄存器，jvm 还需要一个程序计数器呢</h4><p>由于 <strong>JVM 字节码不能直接在 CPU 上执行</strong>，必须由 <strong>JVM 解释器或 JIT 编译器</strong> 翻译成机器码后再交给 CPU 执行。因此，JVM 需要<strong>模拟一套自己的指令执行环境</strong>，并在其中维护一个 <strong>程序计数器（PC）</strong>，用于记录<strong>当前线程下一条将要执行的字节码指令位置</strong>。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul>
<li><strong>Java 虚拟机栈</strong> 是 <strong>线程私有</strong> 的内存区域，用于<strong>方法调用和执行过程管理</strong>。</li>
<li><strong>每调用一个方法</strong>，JVM 都会创建一个 <strong>栈帧（Stack Frame）</strong> 压入当前线程的虚拟机栈中。</li>
<li>方法执行完毕后，该栈帧就会 <strong>弹出并销毁</strong>。</li>
<li><strong>局部变量（包括方法参数、临时变量）</strong> 都存放在这个栈帧里的 <strong>局部变量表（Local Variable Table）</strong> 中。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><font style="color:rgb(60, 60, 67);">和虚拟机栈所发挥的作用非常相似，区别是：</font><strong><font style="color:rgb(60, 60, 67);">虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</font></strong></p>
<h2 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a><font style="color:rgb(60, 60, 67);">线程共享</font></h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>堆（Heap）</strong> 是 JVM 内存中<strong>最大</strong>的一块区域，<br>用于存放：</p>
<p>✅ <strong>所有对象实例（new 出来的）</strong><br>✅ <strong>数组（int[]、String[] 等）</strong></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h2 id="本地内存（线程共享）"><a href="#本地内存（线程共享）" class="headerlink" title="本地内存（线程共享）"></a>本地内存（线程共享）</h2><p><strong>本地内存（Native Memory）</strong> 不属于 JVM 管理的 <strong>堆或方法区</strong>，而是 JVM 通过底层 <strong>C&#x2F;C++ 代码</strong> 直接向操作系统申请的 <strong>堆外内存</strong>，其分配与释放由底层代码自行管理，<strong>不受 GC 控制</strong>。  </p>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p><strong>方法区（Method Area）</strong> 是 JVM 规范中定义的一块<strong>逻辑内存区域</strong>，<br>主要用于存储：</p>
<ul>
<li>✅ <strong>类的元信息</strong>（类名、父类、字段、方法等结构）</li>
<li>✅ <strong>静态变量</strong>（<code>static</code> 修饰的字段）</li>
<li>✅ <strong>常量</strong>（<code>final</code> 常量、运行时常量池）</li>
<li>✅ <strong>类字节码</strong>（字段、方法、接口的描述信息）</li>
</ul>
<p>📌 <strong>简单理解</strong>：</p>
<p>“堆放对象，方法区放类。”</p>
<p>当类首次被加载（如 <code>User.class</code>）时，JVM 会将它的结构信息存入方法区。</p>
<p>在 <strong>JDK 8 之后</strong>，HotSpot 虚拟机使用 <strong>元空间（Metaspace）</strong> 来实现方法区，并将其放置在 <strong>本地内存（Native Memory）</strong> 中，以替代早期的永久代（PermGen）。</p>
<p><em>方法区是jvm的概念，元空间就是具体的实现</em></p>
<h4 id="为什么元空间放在本地内存不放在堆中"><a href="#为什么元空间放在本地内存不放在堆中" class="headerlink" title="为什么元空间放在本地内存不放在堆中"></a>为什么元空间放在本地内存不放在堆中</h4><ol>
<li>将元空间放在堆外，使类元数据与普通对象解耦，内存调优时可以分别控制堆与元空间的大小，配置更加灵活，也更不容易因类加载导致整体 OOM。</li>
<li>堆中的对象涉及到频繁的gc，但类元数据本质上很稳定，生命周期长不适合放在堆中</li>
</ol>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存（Direct Memory）</strong> 是 JVM 通过 <strong>本地方法（C&#x2F;C++）在操作系统本地内存中分配</strong> 的一块内存区域，不属于 Java 堆，也不受 GC 管理。  </p>
<p>主要用于高性能I&#x2F;O操作（文件读写，网络通信等）</p>
<p><strong>工作原理（以写为例）</strong></p>
<p><strong>传统堆内I&#x2F;O</strong></p>
<p>[Java 堆 byte[]] → (复制) → [临时 native 缓冲区（用户缓冲区）] → (复制) → [内核缓冲区] → (DMA) → [网卡&#x2F;磁盘]</p>
<br/>

<p><strong>使用直接内存后</strong></p>
<p>[直接内存] → (复制) → [内核缓冲区] → (DMA) → [网卡&#x2F;磁盘]</p>
<br/>

<p> ！少了一次 “堆内 → 临时 native 缓冲区（用户缓冲区）” 的中间拷贝。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:42 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:42+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:42 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:42+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是类加载？"><a href="#什么是类加载？" class="headerlink" title="什么是类加载？"></a>什么是类加载？</h1><p>当我们写好一个java 类，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个.java 	文件会被编译成.class 文件，而jvm不能直接读取.java文件，它要运行程序，就必须先把.class 文件里的字节码加载到内存中，并转换成jvm 能识别的结构，这整个过程就叫做类加载</p>
<h1 id="为什么需要多个类加载器？"><a href="#为什么需要多个类加载器？" class="headerlink" title="为什么需要多个类加载器？"></a>为什么需要多个类加载器？</h1><h3 id="1-隔离不同来源的类（核心原因）"><a href="#1-隔离不同来源的类（核心原因）" class="headerlink" title="1. 隔离不同来源的类（核心原因）"></a><strong>1. 隔离不同来源的类（核心原因）</strong></h3><p>在 JVM 中，一个类的真正身份由 <strong>“类加载器 + 全限定类名”</strong> 决定，而不是单独由类名决定。</p>
<p>也就是说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoaderA + com.example.User  → 类 X</span><br><span class="line">ClassLoaderB + com.example.User  → 类 Y</span><br></pre></td></tr></table></figure>

<p>虽然类名完全一样，但 JVM 会认为它们是两个不同的类。</p>
<p><strong>为什么要这样设计？</strong></p>
<ul>
<li><strong>避免命名冲突：</strong> 不同模块&#x2F;应用可以拥有同名类而互不干扰（比如 Tomcat 的不同 WebApp）。</li>
<li><strong>保证安全性：</strong> 核心类必须由系统级加载器加载，防止用户伪造同名的 <code>java.lang.String</code> 等关键类。</li>
<li><strong>实现模块隔离：</strong> 每个 ClassLoader 都有独立的命名空间，互相不影响。</li>
</ul>
<h3 id="2-让我们在”加载类”的时候加入自定义逻辑"><a href="#2-让我们在”加载类”的时候加入自定义逻辑" class="headerlink" title="2.让我们在”加载类”的时候加入自定义逻辑"></a>2.让我们在”加载类”的时候加入自定义逻辑</h3><p>比如加载加密类，网络类等</p>
<h1 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h1><p><strong>继承ClassLoader,重写findClass（不打破双亲委派机制）</strong></p>
<p>经典步骤：</p>
<ol>
<li>**继承 **<code>**ClassLoader**</code></li>
<li>**提供一个构造方法（可指定 parent），构造方法只要用于指定父加载器，默认系统类加载器（System ClassLoader） 作为父加载器。  **</li>
<li>**重写 **<code>**findClass(String name)**</code><ul>
<li>**把类名 <strong><code>**com.example.Hello**</code></strong> → 换成路径 **<code>**com/example/Hello.class**</code></li>
<li><strong>根据你的规则去读字节：</strong><code>**byte[] bytes = loadClassData(name);**</code></li>
<li>**调用 **<code>**defineClass(name, bytes, 0, bytes.length)**</code></li>
</ul>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    // 比如从这个目录下找 class 文件</span></span><br><span class="line"><span class="code">    private final String classPath;</span></span><br><span class="line"><span class="code">    //自定义父类加载器，默认系统类加载器（System ClassLoader） 作为父加载器。</span></span><br><span class="line"><span class="code">    public MyClassLoader(String classPath) &#123;</span></span><br><span class="line"><span class="code">        // 使用系统类加载器做 parent（也可以改成别的）</span></span><br><span class="line"><span class="code">        super(MyClassLoader.class.getClassLoader());</span></span><br><span class="line"><span class="code">        this.classPath = classPath;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line"><span class="code">        // 1. 把类名转成文件路径，比如 com.example.Hello -&gt; com/example/Hello.class</span></span><br><span class="line"><span class="code">        String fileName = name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 2. TODO: 在这里实现从 classPath + fileName 读取字节</span></span><br><span class="line"><span class="code">        byte[] classBytes = loadClassBytes(fileName);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        if (classBytes == null || classBytes.length == 0) &#123;</span></span><br><span class="line"><span class="code">            throw new ClassNotFoundException(name);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 3. 交给 JVM，把字节变成 Class 对象</span></span><br><span class="line"><span class="code">        return defineClass(name, classBytes, 0, classBytes.length);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 具体怎么读文件交给你实现 😊</span></span><br><span class="line"><span class="code">    private byte[] loadClassBytes(String fileName) &#123;</span></span><br><span class="line"><span class="code">        // TODO: 使用 FileInputStream / Files.readAllBytes 等读入字节</span></span><br><span class="line"><span class="code">        return null;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在自定义类加载器时：</p>
<ul>
<li><strong>只重写 <strong><code>**findClass()**</code></strong> 不会破坏双亲委派模型</strong><br>因为真正负责加载流程的是 <code>loadClass()</code>，它的默认实现仍然会先把加载任务交给父类加载器，只有父加载器无法加载时才回调 <code>findClass()</code>。</li>
<li><strong>重写 <strong><code>**loadClass()**</code></strong> 才能真正打破双亲委派</strong><br>因为你可以在 <code>loadClass()</code> 中自行决定：<ul>
<li>是先自己加载</li>
<li>还是先交给父加载器</li>
<li>或者按某种规则分别处理</li>
</ul>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    // 第 1 步：检查缓存，是否已经加载过</span></span><br><span class="line"><span class="code">    Class&lt;?&gt; c = findLoadedClass(name);</span></span><br><span class="line"><span class="code">    if (c == null) &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        try &#123;</span></span><br><span class="line"><span class="code">            // 第 2 步：先让父加载器尝试加载（双亲委派）</span></span><br><span class="line"><span class="code">            c = getParent().loadClass(name);</span></span><br><span class="line"><span class="code">        &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="code">            // 第 3 步：父加载器不行 → 由当前加载器自己加载</span></span><br><span class="line"><span class="code">            c = findClass(name);   // ★ 重要：这里调用 findClass</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 第 4 步：是否要解析</span></span><br><span class="line"><span class="code">    if (resolve) &#123;</span></span><br><span class="line"><span class="code">        resolveClass(c);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    return c;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760794761056-a95c62d3-a4fa-44ef-a19f-e007010837fc.png"></p>
<p>类从被加载到jvm开始，到卸载出内存，整个声明周期分为起个阶段，<font style="color:rgb(44, 62, 80);">分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。</font></p>
<p><font style="color:rgb(44, 62, 80);">除去使用和卸载，就是 Java 的类加载过程。这 5 个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后（我们随后来解释）。</font></p>
<ol>
<li>loading（载入）</li>
</ol>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="为什么会有双亲委派？"><a href="#为什么会有双亲委派？" class="headerlink" title="为什么会有双亲委派？"></a>为什么会有双亲委派？</h3><p>在JVM中有多个类加载器,Bootstrap（启动类加载器），Platform（拓展类加载器）…，问题是这些加载器都有能力加载类，所以当一个类被请求加载的时候，应该由谁来负责？所以由双亲委派机制来协调</p>
<p><strong>所以双亲委派机制就是当类加载器加载类的时候会先去问它们的父类能不能加载，如果父类不能加载的话会抛出异常然后这个类才会加载</strong></p>
<h3 id="为什么类加载器不直接自己加载，而要让父加载器先试一试？"><a href="#为什么类加载器不直接自己加载，而要让父加载器先试一试？" class="headerlink" title="为什么类加载器不直接自己加载，而要让父加载器先试一试？"></a>为什么类加载器不直接自己加载，而要让父加载器先试一试？</h3><p> 假设我们自己写了一个类加载器，它去加载 <code>java.lang.String</code> 这个类。  但是它的父加载器已经加载过这个类了， 那这样的话，这个加载器会重新加载一份新的 <code>String.class</code> 进内存。  系统里现在就会有两份不同的 <code>String</code> 类，虽然名字一样，但它们是由不同加载器加载的。<br>在 JVM 看来，它们就是两个完全不同的类型，互相不能转换，会导致类型混乱甚至安全问题。  、</p>
<p>所以 JVM 规定：</p>
<p>当某个加载器要加载一个类时，它必须<strong>先让父加载器尝试</strong>，<br>父加载器如果能加载，就直接使用父的结果；<br>如果父亲说“我也没有这个类”，那你再自己加载。</p>
<p>这样就能保证：</p>
<ul>
<li><code>java.lang.String</code>、<code>Object</code> 这些核心类只会被系统加载器（Bootstrap）加载；</li>
<li>你的应用层加载器不会“冒充”系统类；</li>
<li>类的唯一性与安全性都得到了保证。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/jvm/%E6%97%A0%E6%A0%87%E9%A2%98%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/jvm/%E6%97%A0%E6%A0%87%E9%A2%98%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:42 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:42+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/java/jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/java/jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:42 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:42+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、常量池（Constant-Pool）——静态的“字典”"><a href="#一、常量池（Constant-Pool）——静态的“字典”" class="headerlink" title="一、常量池（Constant Pool）——静态的“字典”"></a>一、常量池（Constant Pool）——静态的“字典”</h2><p>📍位置：每个 <code>.class</code> 文件里<br>📍作用：保存<strong>编译时</strong>就确定的各种“常量信息”</p>
<p>比如你写了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译成 <code>.class</code> 文件时，编译器会把这几个东西放进常量池：</p>
<ul>
<li><code>&quot;hello world&quot;</code> 这个字符串字面量</li>
<li><code>System.out</code> 这个字段的引用</li>
<li><code>println()</code> 这个方法的符号引用</li>
<li>类名 <code>Hello</code>、<code>java/lang/Object</code>、<code>java/lang/System</code> 等</li>
</ul>
<p>这些统统放进 <code>.class</code> 文件的 <strong>常量池表</strong>。</p>
<p>🧠 你可以把它想成一本“查字典”，记录了：</p>
<p>类中所有可能用到的常量、类名、方法名、字段名、描述符等。</p>
<p>它还不是内存里的对象，只是静态的数据表。</p>
<hr>
<h2 id="二、运行时常量池（Runtime-Constant-Pool）——内存里的副本"><a href="#二、运行时常量池（Runtime-Constant-Pool）——内存里的副本" class="headerlink" title="二、运行时常量池（Runtime Constant Pool）——内存里的副本"></a>二、运行时常量池（Runtime Constant Pool）——内存里的副本</h2><p>📍位置：在 <strong>方法区（method area）</strong> 中<br>📍作用：把 <code>.class</code> 文件里的常量池加载进内存，并把“符号引用”变成“真实引用”。</p>
<p>当 JVM 运行你的程序时，会把 <code>.class</code> 文件中的常量池<strong>加载进内存</strong>，<br>并创建一个“运行时常量池”，比如：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>常量池中是什么</th>
<th>运行时常量池变成什么</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;hello world&quot;</code></td>
<td>字面量符号</td>
<td>堆中字符串对象的引用</td>
</tr>
<tr>
<td><code>System.out</code></td>
<td>字段符号引用</td>
<td>指向真实的静态字段</td>
</tr>
<tr>
<td><code>println()</code></td>
<td>方法符号引用</td>
<td>指向真实方法地址</td>
</tr>
</tbody></table>
<p>✅ 也就是说：</p>
<p>“常量池”只是 <code>.class</code> 文件的原始数据，<br>“运行时常量池”才是 JVM 真正在运行时使用的东西。</p>
<h2 id="符号引用和和直接引用的区别"><a href="#符号引用和和直接引用的区别" class="headerlink" title="符号引用和和直接引用的区别"></a>符号引用和和直接引用的区别</h2><h3 id="直觉理解：符号引用-≠-真实地址"><a href="#直觉理解：符号引用-≠-真实地址" class="headerlink" title="直觉理解：符号引用 ≠ 真实地址"></a>直觉理解：符号引用 ≠ 真实地址</h3><p>我们先打个比方👇</p>
<p>假设你在 <code>.class</code> 文件里写了这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>这行代码在 <code>.class</code> 文件的常量池里，会记录为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Methodref #4.#5  // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<p>这里的：</p>
<ul>
<li><code>&quot;java/io/PrintStream&quot;</code> 是一个字符串</li>
<li><code>&quot;println&quot;</code> 也是字符串</li>
<li><code>&quot;(Ljava/lang/String;)V&quot;</code> 是方法描述符（代表“参数是 String，返回值是 void”）</li>
</ul>
<p>这些东西——<strong>都不是内存地址</strong>，只是名字、路径、描述。<br>它们告诉 JVM：“我要调用一个叫 <code>java/io/PrintStream.println</code> 的方法”。</p>
<p>这就叫：</p>
<p><strong>符号引用（Symbolic Reference）</strong><br>是一种用<strong>字符串、名字或符号</strong>表示类、字段、方法的“引用”，<br>而不是内存中的真实地址。</p>
<h3 id="符号引用到直接引用的转变（解析阶段发生）"><a href="#符号引用到直接引用的转变（解析阶段发生）" class="headerlink" title="符号引用到直接引用的转变（解析阶段发生）"></a>符号引用到直接引用的转变（解析阶段发生）</h3><p>当类被加载到内存后，JVM 会在“解析阶段”把这些符号引用变成真正的“内存地址”，也就是：</p>
<p><strong>直接引用（Direct Reference）</strong></p>
<p>举个例子👇</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>引用类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>.class</code><br/> 文件</td>
<td>符号引用</td>
<td><code>&quot;java/io/PrintStream.println:(Ljava/lang/String;)V&quot;</code></td>
</tr>
<tr>
<td>运行时内存</td>
<td>直接引用</td>
<td>指向真正的 <code>println()</code><br/> 方法在内存中的地址</td>
</tr>
</tbody></table>
<hr>
<h3 id="符号引用都有哪些？"><a href="#符号引用都有哪些？" class="headerlink" title="符号引用都有哪些？"></a>符号引用都有哪些？</h3><p>JVM 规范规定，符号引用主要有三类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>举例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>类或接口的符号引用</td>
<td><code>&quot;java/lang/String&quot;</code></td>
<td>告诉 JVM 我依赖哪个类</td>
</tr>
<tr>
<td>字段的符号引用</td>
<td><code>&quot;System.out:Ljava/io/PrintStream;&quot;</code></td>
<td>告诉 JVM 需要访问哪个字段</td>
</tr>
<tr>
<td>方法的符号引用</td>
<td><code>&quot;println:(Ljava/lang/String;)V&quot;</code></td>
<td>告诉 JVM 需要调用哪个方法</td>
</tr>
</tbody></table>
<p>这些在 <code>.class</code> 文件的常量池里都有编号，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#4 = Methodref #10.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="用一句话总结："><a href="#用一句话总结：" class="headerlink" title="用一句话总结："></a>用一句话总结：</h3><p><strong>符号引用</strong>：类文件中的“名字引用”，编译期生成，用来描述依赖关系。<br><strong>直接引用</strong>：运行期真正的内存地址或偏移量，用来让 JVM 真正访问对象、字段或方法。</p>
<h2 id="三、字符串常量池（String-Constant-Pool）——专为字符串优化"><a href="#三、字符串常量池（String-Constant-Pool）——专为字符串优化" class="headerlink" title="三、字符串常量池（String Constant Pool）——专为字符串优化"></a>三、字符串常量池（String Constant Pool）——专为字符串优化</h2><p>位置：堆<br>作用：存放程序中出现的所有字符串字面量（”abc”、”user” 等），<strong>避免重复创建字符串对象</strong></p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;hello&quot;;</span><br><span class="line">String s2 = &quot;hello&quot;;</span><br><span class="line">System.out.println(s1 == s2); // true</span><br></pre></td></tr></table></figure>

<p>为什么 <code>true</code>？<br>因为 <code>&quot;hello&quot;</code> 这个字符串在字符串常量池中只会有一个对象。</p>
<ul>
<li>第一次遇到 <code>&quot;hello&quot;</code> → 放入字符串常量池（堆中）</li>
<li>第二次再遇到 <code>&quot;hello&quot;</code> → JVM 检查池里已经有了，直接复用引用</li>
</ul>
<p>🧠 注意：</p>
<p>运行时常量池里存的是字符串对象的“引用”，<br>真正的字符串对象存在 <strong>字符串常量池（堆中）</strong>。</p>
<hr>
<h2 id="四、三者关系图（重点记忆）"><a href="#四、三者关系图（重点记忆）" class="headerlink" title="四、三者关系图（重点记忆）"></a>四、三者关系图（重点记忆）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────────┐</span><br><span class="line">│ .class 文件                  │</span><br><span class="line">│  └─ 常量池（符号引用）       │</span><br><span class="line">└──────────────────────────────┘</span><br><span class="line">              ↓  加载</span><br><span class="line">┌──────────────────────────────┐</span><br><span class="line">│ 方法区 (JDK7以前是永久代)     │</span><br><span class="line">│  └─ 运行时常量池（引用表）    │</span><br><span class="line">└──────────────────────────────┘</span><br><span class="line">              ↓  引用指向</span><br><span class="line">┌──────────────────────────────┐</span><br><span class="line">│ 堆内存                        │</span><br><span class="line">│  └─ 字符串常量池（StringTable）│</span><br><span class="line">│       存真正的 String 对象     │</span><br><span class="line">└──────────────────────────────┘</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、总结表"><a href="#五、总结表" class="headerlink" title="五、总结表"></a>五、总结表</h2><table>
<thead>
<tr>
<th>概念</th>
<th>阶段</th>
<th>位置</th>
<th>内容</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>常量池</td>
<td>编译时</td>
<td><code>.class</code><br/> 文件</td>
<td>符号引用</td>
<td><code>&quot;hello&quot;</code><br/>, 方法名等</td>
</tr>
<tr>
<td>运行时常量池</td>
<td>运行时</td>
<td>方法区</td>
<td>已解析的引用</td>
<td>指向堆对象的指针</td>
</tr>
<tr>
<td>字符串常量池</td>
<td>运行时</td>
<td>堆中</td>
<td>字符串对象</td>
<td><code>&quot;hello&quot;</code><br/> 对象本身</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
