<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="刘翰霖">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">刘翰霖</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/JVM/Java/jvm/%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/JVM/Java/jvm/%E5%A0%86/" class="post-title-link" itemprop="url">堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="堆内存中主要分为两个区域"><a href="#堆内存中主要分为两个区域" class="headerlink" title="堆内存中主要分为两个区域"></a>堆内存中主要分为两个区域</h2><h3 id="新生区（新生代）"><a href="#新生区（新生代）" class="headerlink" title="新生区（新生代）"></a>新生区（新生代）</h3><ul>
<li>专门用来存放 <strong>刚创建出来的新对象</strong>。</li>
<li>垃圾回收频繁（称为 <strong>Minor GC</strong>）。</li>
<li>采用 <strong>复制算法（Copying GC）</strong> 来回收。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760798443149-e8100739-2374-41f3-a06b-d452a6f9bce8.png"></p>
<ul>
<li>大量新对象进入 Eden；</li>
<li>当 Eden 满时，触发 <strong>Minor GC</strong>；</li>
<li>仍然存活的对象会被复制到一个 幸存区；</li>
<li>多次 Minor GC 后还存活的对象，会被移动到老年代（称为 **晋升 **）。</li>
</ul>
<h3 id="养老区（老年代）"><a href="#养老区（老年代）" class="headerlink" title="养老区（老年代）"></a>养老区（老年代）</h3><ul>
<li>存放“寿命较长”的对象或者大对象。</li>
<li><font style="color:rgb(60, 60, 67);">大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</font></li>
<li>当对象在新生代经历多次 GC 仍未被回收时，会被晋升到老年代。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/JVM/Java/jvm/jvm_%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/JVM/Java/jvm/jvm_%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">jvm 初识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/JVM/Java/jvm/jdk8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/JVM/Java/jvm/jdk8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">jdk8垃圾收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table>
<thead>
<tr>
<th>GC 名称</th>
<th>负责代</th>
<th>算法</th>
<th>是否 STW</th>
<th>特点（优点&#x2F;缺点）</th>
<th>搭配关系 &#x2F; 组合</th>
<th>JDK 可用版本</th>
<th>是否默认 GC</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>新生代</td>
<td><strong>标记-复制</strong></td>
<td>是（单线程）</td>
<td>✔ 实现简单✔ 单核最快✘ STW 长✘ 单线程</td>
<td>搭配 <strong>Serial Old</strong></td>
<td>JDK1.3+（一直可用）</td>
<td>否</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>老年代</td>
<td><strong>标记-整理</strong></td>
<td>是（单线程）</td>
<td>✔ 稳定可靠✘ 老年代整理时停顿极长</td>
<td>搭配 Serial（默认搭档）CMS Full GC fallback</td>
<td>JDK1.3+</td>
<td>否</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>新生代</td>
<td><strong>多线程标记-复制</strong></td>
<td>是</td>
<td>✔ 多线程年轻代 GC✔ CMS 默认搭档✘ 线程切换成本</td>
<td><strong>ParNew + CMS</strong></td>
<td>JDK1.4+</td>
<td>否</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>新生代</td>
<td><strong>多线程标记-复制</strong></td>
<td>是</td>
<td>✔ 高吞吐量 GC✔ 自适应调参（APS）✘ 不关注停顿延迟</td>
<td>搭配 <strong>Parallel Old</strong></td>
<td>JDK1.4+</td>
<td>JDK8 默认新生代</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>老年代</td>
<td><strong>多线程标记-整理</strong></td>
<td>是</td>
<td>✔ 多线程整理老年代✔ 吞吐量最高✘ 停顿时间较长</td>
<td><strong>Parallel Scavenge + Parallel Old</strong></td>
<td>JDK6+</td>
<td><strong>JDK8 默认老年代</strong></td>
</tr>
<tr>
<td><strong>CMS（Concurrent Mark Sweep）</strong></td>
<td>老年代</td>
<td><strong>并发标记-清除</strong></td>
<td>初始标记 &amp; 重新标记 STW</td>
<td>✔ 并发 → 低停顿✘ 碎片化✘ 晋升失败&#x2F; CMS失败✘ CPU 压力高</td>
<td><strong>ParNew + CMS</strong></td>
<td>JDK5+</td>
<td>否</td>
</tr>
<tr>
<td><strong>G1（Garbage First）</strong></td>
<td>整个堆（Region 化）</td>
<td><strong>分区 + 标记-整理（复制式整理）</strong></td>
<td>仅初始标记&#x2F;最终标记&#x2F;筛选回收 STW</td>
<td>✔ 可预测停顿✔ 无碎片✔ 按 Region 局部回收✔ 适合大堆✘ 调参稍复杂</td>
<td>单独使用（年轻 + 老年代一体）</td>
<td>JDK7u4+（可生产）JDK8 完全成熟</td>
<td><strong>JDK9+ 默认 GC</strong></td>
</tr>
</tbody></table>
<h1 id="一-Serial-Serial-Old"><a href="#一-Serial-Serial-Old" class="headerlink" title="一.Serial&#x2F;Serial Old"></a>一.Serial&#x2F;Serial Old</h1><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763000887298-17e69bb4-3b01-4a0a-b45a-3852f02104c2.png"></p>
<p><strong><font style="color:rgb(60, 60, 67);">新生代采用标记-复制算法，老年代采用标记-整理算法。</font></strong></p>
<p>Serial&#x2F;Serial Old GC 是 <strong>JDK8 最基础的垃圾回收器</strong>，特点非常鲜明：</p>
<ul>
<li><strong>单线程 GC</strong>（只用 1 个线程来做回收）</li>
<li><strong>新生代使用复制算法(Serial负责新生代)</strong></li>
<li>老年代用标记整理算法（Serial Old 负责老年代）</li>
<li><strong>整个过程都会 Stop-The-World（暂停所有用户线程）</strong></li>
</ul>
<ol>
<li>优点</li>
</ol>
<ul>
<li>实现简单，可靠性高</li>
<li>单线程，没有线程切换成本，因此在单核cpu下，反而比并发GC更快</li>
</ul>
<ol start="2">
<li>缺点</li>
</ol>
<ul>
<li>Stop-The-World 时间长</li>
<li>单线程 → 无法利用多核优势</li>
</ul>
<h1 id="二-ParNew"><a href="#二-ParNew" class="headerlink" title="二.ParNew"></a>二.ParNew</h1><p>ParNew就是多线程版的Serial，就是把Serial的新生代复制算法，换成多线程并行执行（和Serial 一样只负责新生代），同时ParNew是CMS的默认新生代收集器</p>
<ol>
<li>优点</li>
</ol>
<ul>
<li>多线程-&gt;GC速度更快</li>
</ul>
<ol start="2">
<li>缺点</li>
</ol>
<ul>
<li>GC期间仍然会stop-the-world</li>
<li>线程切换成本高，cpu核数少时性能提升有限</li>
</ul>
<h1 id="三-Parallel-Scavenge"><a href="#三-Parallel-Scavenge" class="headerlink" title="三.Parallel Scavenge"></a>三.Parallel Scavenge</h1><p><strong>ParNew 和 Parallel Scavenge 虽然都是新生代的多线程、标记复制、需要暂停（STW）的收集器，但它们的优化目标完全不同：</strong></p>
<h3 id="ParNew：追求“低停顿”"><a href="#ParNew：追求“低停顿”" class="headerlink" title="ParNew：追求“低停顿”"></a><strong>ParNew：追求“低停顿”</strong></h3><ul>
<li>新生代通常会配置得更小，以缩短每次年轻代回收的暂停时间。</li>
<li>因为老年代使用 CMS，ParNew 会把 <strong>Survivor 区适当加大</strong>，让更多对象在年轻代多存活几轮、减少过早晋升老年代，从而降低 CMS 的压力，减少Full GC。</li>
</ul>
<h3 id="Parallel-Scavenge：追求“高吞吐量”"><a href="#Parallel-Scavenge：追求“高吞吐量”" class="headerlink" title="Parallel Scavenge：追求“高吞吐量”"></a><strong>Parallel Scavenge：追求“高吞吐量”</strong></h3><ul>
<li>新生代通常会配置得更大，以减少回收次数、提升程序整体执行效率。</li>
<li>同时依靠 <strong>自动调节机制</strong>（JVM 会自动调整新生代大小、Eden&#x2F;Survivor 比例、晋升阈值等）来获得尽可能高的吞吐量。</li>
</ul>
<h2 id="如何理解高吞吐量和低停顿"><a href="#如何理解高吞吐量和低停顿" class="headerlink" title="如何理解高吞吐量和低停顿"></a>如何理解高吞吐量和低停顿</h2><p>**吞吐量 &#x3D; 业务代码运行时间 ÷（业务代码时间 + GC 时间）<br>**<strong>吞吐量越高，说明程序真正干活的时间越多，GC 花的时间越少。</strong></p>
<p>吞吐量关注的是 <strong>GC 的总时间</strong>，不是一次 GC 的暂停时长。<br>因此 <strong>Parallel Scavenge 的目标不是缩短每次 GC 的暂停时间，而是减少 GC 的触发次数，让整体执行更快。</strong></p>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>低停顿（ParNew）</strong></th>
<th><strong>高吞吐量（Parallel Scavenge）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>关注点</strong></td>
<td><strong>每次暂停时间短</strong></td>
<td><strong>GC 总时间少</strong></td>
</tr>
<tr>
<td><strong>常用场景</strong></td>
<td><strong>需要让用户感觉不卡顿（例如 Web）</strong></td>
<td><strong>追求整体速度（如批处理、大数据计算）</strong></td>
</tr>
<tr>
<td><strong>策略</strong></td>
<td><strong>新生代小，GC 更快但更频繁</strong></td>
<td><strong>新生代大，GC 更慢但次数更少</strong></td>
</tr>
</tbody></table>
<h1 id="四-Parallel-Old"><a href="#四-Parallel-Old" class="headerlink" title="四. Parallel Old"></a>四. Parallel Old</h1><p>Parallel Old：老年代的“高吞吐量并行 GC”</p>
<ul>
<li>是 Parallel Scavenge 的专属搭档。</li>
<li>多线程的 <strong>标记-整理（Mark-Compact）</strong> 算法。</li>
<li>注重整体吞吐量，不在乎暂停时间。</li>
</ul>
<h1 id="五-CMS"><a href="#五-CMS" class="headerlink" title="五.CMS"></a>五.CMS</h1><p> CMS &#x3D; 老年代并发收集器，目标是减少停顿  ，也就是ParNew的默认搭档，采用标记-清除算法</p>
<p>CMS的运行过程分为四步：</p>
<ol>
<li><font style="color:rgb(60, 60, 67);"> 初始标记：短暂停顿，标记直接与 root 相连的对象（根对象）</font></li>
<li><font style="color:rgb(60, 60, 67);"> 并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</font></li>
<li><strong><font style="color:rgb(60, 60, 67);">重新标记：</font></strong><font style="color:rgb(60, 60, 67);"> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</font></li>
<li><strong><font style="color:rgb(60, 60, 67);">并发清除：</font></strong><font style="color:rgb(60, 60, 67);"> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</font></li>
</ol>
<p><em>只有第一步和第三步会stop-the-world暂停</em></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763003370465-8950ed1d-7ebe-4888-9c46-e86c79e74949.png"></p>
<p>优点:</p>
<ol>
<li><strong><font style="color:rgb(60, 60, 67);">并发收集、低停顿</font></strong></li>
</ol>
<p>缺点:</p>
<ol>
<li>采用标记-清除算法会产生内存碎片</li>
<li>并发阶段占用cpu</li>
<li>可能出现  出现CMS失败（CMS Failure）或晋升失败（Promotion Failed）</li>
</ol>
<h2 id="什么是晋升失败（Promotion-Failed）"><a href="#什么是晋升失败（Promotion-Failed）" class="headerlink" title="什么是晋升失败（Promotion Failed）"></a>什么是晋升失败（Promotion Failed）</h2><p><strong>晋升失败 &#x3D; 新生代幸存对象想晋升到老年代，但老年代放不下。</strong></p>
<p>触发于 <strong>新生代 GC（Young GC）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eden + Survivor → 复制存活对象 → Survivor / 老年代</span><br></pre></td></tr></table></figure>

<p>当：</p>
<ul>
<li>Survivor 装不下，或</li>
<li>对象年龄达到阈值（默认 15）</li>
</ul>
<p>对象会晋升老年代。</p>
<p>如果老年代剩余空间不足，就发生：</p>
<p>✔ <strong>晋升失败（Promotion Failed）</strong><br>→ Young GC 无法完成<br>→ JVM 立即触发 <strong>Full GC（Serial Old 单线程）</strong><br>→ 出现 <strong>超长暂停（STW）</strong></p>
<p><strong>一句话：晋升失败 &#x3D; 年轻代往老年代“塞不进去”。</strong></p>
<h3 id="为什么在-CMS-体系下-Full-GC-一定是-Serial-Old？"><a href="#为什么在-CMS-体系下-Full-GC-一定是-Serial-Old？" class="headerlink" title="为什么在 CMS 体系下 Full GC 一定是 Serial Old？"></a>为什么在 CMS 体系下 Full GC 一定是 Serial Old？</h3><p>因为：</p>
<ul>
<li><strong>CMS &#x3D; 标记-清除（Mark-Sweep）</strong></li>
<li>不做 <strong>整理&#x2F;压缩</strong></li>
<li>会产生碎片，不适合 Full GC</li>
</ul>
<p>Full GC 的要求：</p>
<ol>
<li>回收整个堆</li>
<li><strong>整理老年代（压缩碎片）</strong></li>
</ol>
<p>CMS 没有压缩能力，也不能和 Parallel Old 混用。<br>因此：</p>
<p><strong>CMS 体系的 Full GC 必须由 Serial Old（单线程、标记-整理）执行。</strong></p>
<p><strong>一句话：CMS 清得了，但整理不了；整理只能靠 Serial Old。</strong></p>
<h2 id="为什么-CMS-更容易发生晋升失败？"><a href="#为什么-CMS-更容易发生晋升失败？" class="headerlink" title="为什么 CMS 更容易发生晋升失败？"></a><strong>为什么 CMS 更容易发生晋升失败？</strong></h2><p><strong>虽然晋升失败不是 CMS 独有，但 CMS <strong><strong>尤其容易触发</strong></strong>，原因有 4 个：</strong></p>
<h3 id="①-CMS-不压缩-→-老年代更容易碎片化"><a href="#①-CMS-不压缩-→-老年代更容易碎片化" class="headerlink" title="① CMS 不压缩 → 老年代更容易碎片化"></a><strong>① CMS 不压缩 → 老年代更容易碎片化</strong></h3><p>总空间看着够，但连续空间不足 → 大对象放不下 → 晋升失败。</p>
<h3 id="②-CMS-是并发清理-→-清理速度跟不上业务分配速度"><a href="#②-CMS-是并发清理-→-清理速度跟不上业务分配速度" class="headerlink" title="② CMS 是并发清理 → 清理速度跟不上业务分配速度"></a><strong>② CMS 是并发清理 → 清理速度跟不上业务分配速度</strong></h3><p>业务线程不断往老年代塞对象，<br>CMS 一边清一边跑 → 很容易老年代突然被撑满。</p>
<h3 id="③-CMS-启动太晚（默认老年代-68-才启动）"><a href="#③-CMS-启动太晚（默认老年代-68-才启动）" class="headerlink" title="③ CMS 启动太晚（默认老年代 68% 才启动）"></a><strong>③ CMS 启动太晚（默认老年代 68% 才启动）</strong></h3><p>CMS 并发清理速度慢，等它真正清完时可能已经 90%+。<br>而晋升在 Young GC 一瞬间发生，很容易把剩余空间挤爆。</p>
<h3 id="④-CMS-必须预留更多“安全空闲区”"><a href="#④-CMS-必须预留更多“安全空闲区”" class="headerlink" title="④ CMS 必须预留更多“安全空闲区”"></a><strong>④ CMS 必须预留更多“安全空闲区”</strong></h3><p>因为：</p>
<ul>
<li>无压缩</li>
<li>清理速度慢</li>
<li>晋升浪潮不可控</li>
</ul>
<p>老年代可用空间必须留得比其他 GC 更多，<br>否则极易晋升失败。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>晋升失败不是 CMS 独有的问题，但因为 CMS 不压缩、并发速度慢、触发回收偏晚、需要更大空闲区，所以 CMS 最容易发生晋升失败，从而触发 Serial Old Full GC（长暂停）。</p>
<h2 id="什么是CMS失败"><a href="#什么是CMS失败" class="headerlink" title="什么是CMS失败"></a>什么是CMS失败</h2><p><strong>CMS Failure &#x3D; CMS 并发清理过程中，老年代被填满，CMS 来不及回收，导致清理失败。</strong></p>
<p>发生地点：<strong>老年代 CMS 回收阶段</strong></p>
<p>结果非常严重：</p>
<ul>
<li>JVM 被迫触发 Full GC</li>
<li>Full GC 会使用 Serial Old（单线程）</li>
<li>导致一次非常长的 STW（卡顿明显）</li>
</ul>
<p><strong>一句话：CMS 清得不够快，被业务线程塞爆了。</strong></p>
<h3 id="CMS失败发生在哪一步？"><a href="#CMS失败发生在哪一步？" class="headerlink" title="CMS失败发生在哪一步？"></a>CMS失败发生在哪一步？</h3><p>CMS 的 4 步：</p>
<ol>
<li>初始标记（STW）  </li>
<li>并发标记（并发）  </li>
<li>重新标记（STW）  </li>
<li>并发清除（并发） ← 出问题的地方</li>
</ol>
<br/>

<p>CMS Failure 发生在：</p>
<p>步骤 4：并发清除，因为这一步业务线程仍然在创建对象并往老年代塞。</p>
<h2 id="为什么CMS会清不及时"><a href="#为什么CMS会清不及时" class="headerlink" title="为什么CMS会清不及时"></a>为什么CMS会清不及时</h2><p> CMS 会清理不及时，是因为它在“并发清除”阶段业务线程仍在运行，不断向老年代分配对象；当分配速度快于 CMS 清理速度时，老年代会被迅速填满，导致 CMS 来不及回收。  </p>
<h2 id="晋升失败和CMS失败的区别"><a href="#晋升失败和CMS失败的区别" class="headerlink" title="晋升失败和CMS失败的区别"></a>晋升失败和CMS失败的区别</h2><h3 id="晋升失败（Promotion-Failed）"><a href="#晋升失败（Promotion-Failed）" class="headerlink" title="晋升失败（Promotion Failed）"></a><strong>晋升失败（Promotion Failed）</strong></h3><ul>
<li>发生在 新生代 GC（Young GC） 阶段</li>
<li>年轻代的存活对象需要晋升到老年代，但老年代空间不足</li>
<li>结果：新生代 GC 无法完成 → 触发 Full GC（Serial Old）</li>
</ul>
<p><strong>一句话：新生代往老年代“塞不进去”。</strong></p>
<h3 id="CMS-失败（CMS-Failure）"><a href="#CMS-失败（CMS-Failure）" class="headerlink" title="CMS 失败（CMS Failure）"></a><strong>CMS 失败（CMS Failure）</strong></h3><ul>
<li>发生在 CMS 的并发清除阶段</li>
<li>业务线程持续分配对象，CMS 清理速度赶不上 → 老年代被塞满</li>
<li>结果：CMS 放弃回收 → 触发 Full GC（Serial Old）</li>
</ul>
<p><strong>一句话：CMS 在清理时“清不出来”。</strong></p>
<h3 id="两者的关系：有关联但不是同一件事"><a href="#两者的关系：有关联但不是同一件事" class="headerlink" title="两者的关系：有关联但不是同一件事"></a><strong>两者的关系：有关联但不是同一件事</strong></h3><ul>
<li>晋升失败会导致老年代瞬间被撑爆</li>
<li>老年代被撑爆就会导致 CMS 也无法继续清理</li>
<li>所以 晋升失败 经常会“带崩” CMS → 引发 CMS Failure</li>
</ul>
<p> 一句话总结：晋升失败是“塞不进去”，CMS 失败是“清不出来”；两者可以单独发生，也可能连环触发。</p>
<h1 id="六-G1"><a href="#六-G1" class="headerlink" title="六.G1"></a>六.G1</h1><p> G1 采用“分区 + 标记-整理”算法，统一管理整个堆，通过优先回收垃圾最多的 Region 来降低停顿，并避免 CMS 的碎片化与突然的长停顿（Full Gc），从而实现可预测的低延迟 GC。</p>
<p>G1的运行流程也是分为4个阶段</p>
<ol>
<li><p><strong><font style="color:rgb(60, 60, 67);">初始标记</font></strong><font style="color:rgb(60, 60, 67);">：标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象（短暂停顿SWT）</font></p>
</li>
<li><p><strong><font style="color:rgb(60, 60, 67);">并发标记</font></strong><font style="color:rgb(60, 60, 67);">：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</font></p>
</li>
<li><p><strong><font style="color:rgb(60, 60, 67);">最终标记</font></strong><font style="color:rgb(60, 60, 67);">：处理并发标记阶段结束后残留的少量未处理的引用变更。(短暂停顿SWT)</font></p>
</li>
<li><p><strong><font style="color:rgb(60, 60, 67);">筛选回收</font></strong><font style="color:rgb(60, 60, 67);">：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿，具体取决于回收的复杂度。（SWT）</font></p>
</li>
</ol>
<p>初始标记vs并发标记</p>
<p><strong>初始标记（Initial Mark）</strong></p>
<ul>
<li>只标记 <strong>GC Roots 直接引用的对象</strong></li>
<li>例如对象链：<code>Thread Stack → A → B → C → D</code><br>初始标记只会标记到：<code>A</code></li>
<li>这是一次非常快的 STW</li>
</ul>
<p><strong>并发标记（Concurrent Mark）</strong></p>
<ul>
<li>从初始标记到的 A 出发，<strong>继续遍历整个可达链</strong></li>
<li>标记所有可达对象：<code>B、C、D</code></li>
<li>这一步是并发执行，不会长时间阻塞业务</li>
</ul>
<h2 id="G1分区"><a href="#G1分区" class="headerlink" title="G1分区"></a>G1分区</h2><h3 id="什么是-Region？"><a href="#什么是-Region？" class="headerlink" title="什么是 Region？"></a>什么是 Region？</h3><p>G1 不再把堆分成固定的年轻代&#x2F;老年代，而是把整个堆切成许多 <strong>等大小的小块（Region）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ R ][ R ][ R ][ R ][ R ][ R ]...</span><br></pre></td></tr></table></figure>

<p>Region 大小一致（如 1MB~32MB），但功能不同。</p>
<hr>
<h3 id="Region-的动态角色"><a href="#Region-的动态角色" class="headerlink" title="Region 的动态角色"></a>Region 的动态角色</h3><p>G1 会动态决定每个 Region 的角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Region → Eden</span><br><span class="line">Region → Survivor（S0/S1）</span><br><span class="line">Region → Old</span><br><span class="line">Region → Humongous（大对象）</span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<ul>
<li><strong>年轻代 &#x3D; 多个 Region 拼出来的</strong></li>
<li><strong>老年代 &#x3D; 多个 Region 拼出来的</strong></li>
<li><strong>不再是连续的固定大块</strong></li>
</ul>
<h3 id="为什么要分成-Region？（G1-的核心优势）"><a href="#为什么要分成-Region？（G1-的核心优势）" class="headerlink" title="为什么要分成 Region？（G1 的核心优势）"></a>为什么要分成 Region？（G1 的核心优势）</h3><ol>
<li>只回收部分 Region → 停顿极短（Garbage-First）</li>
</ol>
<p>传统 GC：</p>
<p>老年代 3000MB → 必须整块处理 → 暂停长</p>
<br/>

<p>G1：</p>
<p>只处理垃圾最多的 10~20 个 Region → 暂停短</p>
<br/>

<hr>
<ol start="2">
<li>Region 独立 → 可以做标记-整理，彻底避免碎片</li>
</ol>
<p>CMS 不能整理 → 老年代碎片严重<br>G1 可以整理单个 Region → 移动对象少 → 成本低</p>
<ol start="3">
<li>Region 化 → 停顿可预测</li>
</ol>
<p>你可以告诉 JVM：</p>
<p>我希望每次停顿 ≤ 30ms</p>
<br/>

<p>G1 会计算：</p>
<ul>
<li>30ms 能复制多少对象？</li>
<li>能回收多少 Region？</li>
<li>本次 GC 应该挑哪些 Region？</li>
</ul>
<p>这就是 <strong>可预测停顿（Predictable Pause Time）</strong>。</p>
<ol start="4">
<li>Region 化 → 支持同时管理年轻代 + 老年代</li>
</ol>
<p>因为所有区域都是 Region：</p>
<ul>
<li>Young GC：只处理年轻代 Region</li>
<li>Mixed GC：处理年轻代 + “老年代垃圾最多的 Region”</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p> G1 将堆拆成多个等大小的 Region，年轻代与老年代由 Region 动态组合。通过分区回收、优先处理垃圾最多的 Region，并使用标记-整理避免碎片，从而实现可预测的低停顿 GC。  </p>
<h2 id="筛选回收"><a href="#筛选回收" class="headerlink" title="筛选回收"></a><font style="color:rgb(60, 60, 67);">筛选回收</font></h2><h3 id="筛选回收是什么？"><a href="#筛选回收是什么？" class="headerlink" title="筛选回收是什么？"></a>筛选回收是什么？</h3><p><strong>G1 会挑选垃圾最多、回收价值最高的 Region，把里面的存活对象复制到其他 Region，然后将旧 Region 整块回收。</strong></p>
<h3 id="为什么叫“标记-整理”，却在复制？"><a href="#为什么叫“标记-整理”，却在复制？" class="headerlink" title="为什么叫“标记-整理”，却在复制？"></a>为什么叫“标记-整理”，却在复制？</h3><p>因为：</p>
<ul>
<li><strong>整理（Compaction）</strong> &#x3D; 消除碎片、让对象变连续</li>
<li>G1 的整理方式不是“原地压缩”，<br>而是 <strong>按 Region 复制存活对象到新 Region 来实现整理</strong></li>
<li>不需要像传统“复制算法”那样准备双倍空间</li>
</ul>
<p><strong>G1 &#x3D; 分区 + 标记-整理（通过局部复制实现整理）</strong></p>
<h3 id="G1-如何挑选要回收的-Region？"><a href="#G1-如何挑选要回收的-Region？" class="headerlink" title="G1 如何挑选要回收的 Region？"></a>G1 如何挑选要回收的 Region？</h3><p>核心思路：</p>
<p><strong>回收价值最高的 Region 优先（Garbage First）。</strong></p>
<p>具体流程：</p>
<p>① 并发标记阶段，G1 收集每个 Region 的信息：</p>
<ul>
<li><strong>垃圾比例</strong>（垃圾越多回收越值）</li>
<li><strong>存活对象数量</strong>（复制成本）</li>
<li><strong>能回收多少空间</strong>（收益）</li>
<li><strong>预计复制时间</strong>（停顿成本）</li>
</ul>
<p>② 计算“回收价值”评分：</p>
<p>价值 &#x3D; 回收收益 &#x2F; 复制成本（STW 时间）</p>
<br/>

<p>③ 评分排序：垃圾最多、成本最低的 Region 优先</p>
<p>④ 根据目标停顿时间选择回收多少 Region</p>
<p>例如：</p>
<p>-XX:MaxGCPauseMillis&#x3D;30</p>
<br/>

<p><strong>G1 会估算：</strong></p>
<ul>
<li>30ms 能复制多少对象？</li>
<li>30ms 能整理多少 Region？</li>
</ul>
<p> 只选择能在目标停顿时间内处理完的 Region</p>
<p><strong>一句话总结</strong></p>
<p>G1 通过“按 Region 的复制式整理”避免碎片，并根据垃圾比例与复制成本挑选出最值得回收的 Region，在目标停顿时间内完成回收，从而实现可预测的低停顿 GC。</p>
<h1 id="七-ZGC"><a href="#七-ZGC" class="headerlink" title="七.ZGC"></a>七.ZGC</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/JVM/Java/jvm/GC_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/JVM/Java/jvm/GC_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">GC 垃圾回收</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法（Reference Counting）是一种 <strong>简单直接的垃圾回收策略</strong>：</p>
<p>每个对象维护一个“引用计数器”，<br>每当有一个引用指向它时，计数 +1；</p>
<p> 当计数为 0 时，说明该对象“不可再被访问”，可以被回收。  </p>
<h4 id="最大问题：无法处理循环引用"><a href="#最大问题：无法处理循环引用" class="headerlink" title="最大问题：无法处理循环引用"></a>最大问题：无法处理循环引用</h4><p> 这是引用计数法被 JVM 淘汰的关键原因。  </p>
<p>如果a和b互相引用，此时即使我们把外界对a和b的引用都置null，它们也不会被gc因为它们相互引用，引用计数不为0</p>
<p>所以jvm不采用引用计数法因为循环引用在java中太常见了比如说双向链表</p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760800710065-b073ab4e-2f87-4128-9d4d-41ebebcb4305.png"></p>
<p>标记清除算法就是分两步</p>
<ul>
<li>标记活着的对象</li>
<li>对死亡的对象进行清除</li>
</ul>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法就是优化标记清除算法的内存碎片问题，分三步</p>
<ul>
<li>标记活着的对象</li>
<li>把所有活着的对象往一端移动</li>
<li>清理边界外的空间（死亡对象）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/JVM/Java/jvm/full_gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/JVM/Java/jvm/full_gc/" class="post-title-link" itemprop="url">full gc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-什么是full-gc"><a href="#一-什么是full-gc" class="headerlink" title="一.什么是full gc"></a>一.什么是full gc</h1><p><strong>Full GC（Full Garbage Collection）<strong>是一次</strong>针对整个堆（新生代 + 老年代）以及方法区（JDK8 以后是元空间）的完全垃圾回收</strong>。  </p>
<h2 id="元空间在直接内存中为什么还会被gc呢？"><a href="#元空间在直接内存中为什么还会被gc呢？" class="headerlink" title="元空间在直接内存中为什么还会被gc呢？"></a>元空间在直接内存中为什么还会被gc呢？</h2><p>元空间在直接内存中，直接内存不受jvm 管理不会发生gc，那为什么full gc 还会回收它呢？</p>
<p>直接内存本身不会被gc扫描，但JVM会在GC过程中，通过类卸载机制间接释放元空间</p>
<h3 id="如何理解类卸载"><a href="#如何理解类卸载" class="headerlink" title="如何理解类卸载"></a>如何理解类卸载</h3><p>首先类加载器<code>lassLoader</code> 本质上就是一个普通的 Java 对象，只不过它的职责是“加载类”。 它也在 <strong>Java 堆（Heap）</strong> 里分配内存，也会被 GC 管理。   JVM 会把每个类与它的 ClassLoader 绑定起来。只要你还在用这个 ClassLoader 加载的类、对象、静态变量……它就活着。</p>
<p>所以类卸载的步骤如下：</p>
<ol>
<li>full gc 触发（minor gc 不会触发类卸载）</li>
<li>发现某个类加载器不可达</li>
<li>卸载该ClassLoader</li>
<li>卸载它所加载的所有class（元空间中的），注意元数据空间中类卸载释放内存一定不是通过gc完成的因为直接内存中没有gc，是通过元空间管理器完成的</li>
<li>释放元空间内存</li>
</ol>
<h1 id="二-什么时候会发生full-gc"><a href="#二-什么时候会发生full-gc" class="headerlink" title="二.什么时候会发生full gc"></a>二.什么时候会发生full gc</h1><table>
<thead>
<tr>
<th>触发原因</th>
<th>说明</th>
<th>示例 &#x2F; 场景</th>
</tr>
</thead>
<tbody><tr>
<td>老年代空间不足</td>
<td>新生代对象晋升时，老年代放不下，触发 Full GC</td>
<td>长生命周期对象太多、缓存未及时清理</td>
</tr>
<tr>
<td>调用 <code>System.gc()</code></td>
<td>显式调用请求一次完整 GC（通常会触发）</td>
<td>代码中手动调用 <code>System.gc()</code><br/> 或框架触发</td>
</tr>
<tr>
<td>元空间（Metaspace）不足</td>
<td>类加载太多导致元空间耗尽</td>
<td>大量动态代理类、频繁热加载 JSP 或插件</td>
</tr>
</tbody></table>
<h1 id="三-常见导致频繁full-gc的场景"><a href="#三-常见导致频繁full-gc的场景" class="headerlink" title="三.常见导致频繁full gc的场景"></a>三.常见导致频繁full gc的场景</h1><ol>
<li>内存泄露</li>
</ol>
<p><font style="color:rgb(77, 77, 77);">应用长时间运行后，老年代内存占用持续增长，即使经过多次Full GC也无法有效释放空间，最终可能导致OOM</font></p>
<ol start="2">
<li>高并发场景</li>
</ol>
<p><font style="color:rgb(77, 77, 77);">在高并发、高吞吐量的服务中，大量对象在短时间内被创建并快速晋升到老年代，导致老年代空间不足，触发频繁Full GC。</font></p>
<ol start="3">
<li>大对象分配场景</li>
</ol>
<p><strong><font style="color:rgb(77, 77, 77);">场景描述</font></strong><font style="color:rgb(77, 77, 77);">：应用程序中频繁创建大对象或大数组，这些对象直接分配在老年代，导致老年代空间不足，触发Full GC。</font></p>
<ol start="4">
<li>内存碎片化场景</li>
</ol>
<p><strong><font style="color:rgb(77, 77, 77);">场景描述</font></strong><font style="color:rgb(77, 77, 77);">：老年代中虽然有足够的空闲空间总量，但由于空间碎片化，无法找到足够大的连续空间来分配对象，导致Full GC。</font></p>
<ol start="5">
<li>元空间溢出</li>
</ol>
<p><font style="color:rgb(77, 77, 77);">在JDK 8及以上版本中，Metaspace空间不足导致频繁Full GC，最终可能引发OutOfMemoryError: Metaspace。</font></p>
<ol start="6">
<li>jvm 参数配置不合理</li>
</ol>
<p><font style="color:rgb(77, 77, 77);">由于JVM参数配置不合理，导致GC策略不适合当前应用特性，引发频繁Full GC。</font></p>
<ol start="7">
<li>频繁调用gc方法</li>
</ol>
<p><font style="color:rgb(77, 77, 77);">应用代码中直接调用System.gc()或Runtime.getRuntime().gc()方法，或者RMI等机制定期触发Full GC。</font></p>
<h1 id="四-full-gc-的排查方案"><a href="#四-full-gc-的排查方案" class="headerlink" title="四.full gc 的排查方案"></a><font style="color:rgb(77, 77, 77);">四.full gc 的排查方案</font></h1><h2 id="开启分析gc-日志"><a href="#开启分析gc-日志" class="headerlink" title="开启分析gc 日志"></a>开启分析gc 日志</h2><p><font style="color:rgb(77, 77, 77);">GC日志是排查Full GC问题的最基本和最重要的工具。通过分析GC日志，可以了解GC的频率、持续时间、内存使用情况等关键信息。</font></p>
<h2 id="通过工具分析gc日志"><a href="#通过工具分析gc日志" class="headerlink" title="通过工具分析gc日志"></a>通过工具分析gc日志</h2><p>使用工具（如  GCViewer    ） 分析GC日志，关注一下</p>
<p>Full GC频率</p>
<p>每次Full GC耗时</p>
<p>老年代使用情况（full gc前和full gc 后）</p>
<h2 id="监控jvm-内存使用情况"><a href="#监控jvm-内存使用情况" class="headerlink" title="监控jvm 内存使用情况"></a>监控jvm 内存使用情况</h2><p>使用如VisualVm工具+Visual GC插件实时监控JVM内存使用情况，注意观察</p>
<ul>
<li>Eden 区</li>
<li>Survivor 区</li>
<li>Old Gen</li>
</ul>
<h2 id="分析jvm-堆中的对象实例"><a href="#分析jvm-堆中的对象实例" class="headerlink" title="分析jvm 堆中的对象实例"></a>分析jvm 堆中的对象实例</h2><p>使用jmap 命令把jvm 堆里的所有对象实例完整导出到一个文件中，进行分析。</p>
<p>当执行jamp 命令后，jvm会</p>
<ul>
<li><strong>暂停所有线程（安全点，Safepoint）</strong>，保证堆在一个稳定状态；<font style="color:#DF2A3F;">会造成业务的停滞</font></li>
<li><strong>遍历整个堆（年轻代 + 老年代 + Survivor 区）</strong>；</li>
<li><strong>把所有对象的：</strong></li>
<li>类名（Class）</li>
<li>对象大小</li>
<li>对象引用关系（谁引用了谁）</li>
<li>字段值（基本类型值、对象引用）</li>
<li>类加载器等元信息<br>全部写入 <code>.hprof</code> 文件。</li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>之后根据以上步骤的排查，我们可以开始进行代码优化，看看有没有内存泄露，或者调整jvm 参数来缓解问题</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Java/%E7%B1%BB%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/Java/%E7%B1%BB%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">类信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="为什么java-一直在谈论类信息，而c-就没有这么显示的谈论"><a href="#为什么java-一直在谈论类信息，而c-就没有这么显示的谈论" class="headerlink" title="为什么java 一直在谈论类信息，而c++就没有这么显示的谈论"></a>为什么java 一直在谈论类信息，而c++就没有这么显示的谈论</h1><h2 id="什么是类信息"><a href="#什么是类信息" class="headerlink" title="什么是类信息"></a>什么是类信息</h2><p> 类信息（Class Metadata）就是 JVM 对“类本身”的描述数据。  </p>
<p>比如：<br>当 JVM 加载一个类（例如 <code>User.class</code>）时，它需要知道：</p>
<ul>
<li>这个类的名字是什么？（<code>User</code>）</li>
<li>它的父类是谁？（<code>Object</code>）</li>
<li>实现了哪些接口？</li>
<li>有哪些字段？（<code>id</code>, <code>name</code>）</li>
<li>有哪些方法？（<code>getName()</code>, <code>setName()</code>）</li>
</ul>
<h2 id="为什么java-需要类信息"><a href="#为什么java-需要类信息" class="headerlink" title="为什么java 需要类信息"></a>为什么java 需要类信息</h2><p> 因为 <strong>Java 是运行在虚拟机上的语言</strong>，所有对象、方法调用、反射、动态加载都要靠 JVM 去调度。JVM 必须知道每个类的完整结构，才能执行它的字节码。</p>
<p>比如反射</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = User.class;</span><br><span class="line">Field field = cls.getDeclaredField(&quot;name&quot;);</span><br><span class="line">System.out.println(field.getType());  </span><br></pre></td></tr></table></figure>

<p> JVM 就是根据**类信息表（Class Metadata）**去查找 <code>User</code> 类里有哪些字段、类型是什么。   如果没有“类信息”，反射根本做不到。  </p>
<h2 id="那为什么c-中很少谈论类信息呢"><a href="#那为什么c-中很少谈论类信息呢" class="headerlink" title="那为什么c++中很少谈论类信息呢"></a>那为什么c++中很少谈论类信息呢</h2><p>因为 C++：</p>
<ul>
<li>是<strong>直接编译成机器码</strong>的语言（没有虚拟机），</li>
<li>类结构在编译期就确定，</li>
<li>编译器直接把方法、字段的偏移地址写进二进制文件。</li>
</ul>
<p>换句话说：**C++ 的类信息是“编译器自己知道的”，不需要运行时保存。**比如c++要调用类方法直接通过地址偏移量就找到了，不需要再查什么类信息，因为 编译器在生成机器码时，已经计算好了“函数或变量的内存偏移地址”。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Java/%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/Java/%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是java-中的注解"><a href="#什么是java-中的注解" class="headerlink" title="什么是java 中的注解"></a>什么是java 中的注解</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注解存活时间</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//注解贴在哪里</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">    //注解内部变量</span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Java 注解本质上就是一种特殊的 interface（继承 Annotation），编译后会存进类的“元信息”（class 文件的结构里），运行时可以被 JVM 或反射读取。  </p>
<ol>
<li>注解&#x3D;特殊的接口</li>
</ol>
<p>当写</p>
<p>public @interface MyAnno {}</p>
<br/>

<p>编译器实际上会帮你生成</p>
<p>public interface MyAnno extends java.lang.annotation.Annotation {</p>
<p>}</p>
<br/>

<ol start="2">
<li>注解存在class 的”元数据”中</li>
</ol>
<p>“元信息”&#x3D;class 文件里描述类的信息,比如</p>
<ul>
<li>类名</li>
<li>字段</li>
<li>方法</li>
<li>注解</li>
<li>泛型信息</li>
<li>访问修饰符</li>
</ul>
<p>因此，注解不是 Java 运行时对象，而是 class 文件的一部分。</p>
<h1 id="注解贴在哪里"><a href="#注解贴在哪里" class="headerlink" title="注解贴在哪里"></a>注解贴在哪里</h1><p>@Target 参数可以表示注解贴在什么位置，常见的有类，接口，成员变量，构造方法…,以下是最常用的</p>
<table>
<thead>
<tr>
<th>常用</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>TYPE</code></td>
<td>类、接口上</td>
</tr>
<tr>
<td><code>METHOD</code></td>
<td>方法上</td>
</tr>
<tr>
<td><code>FIELD</code></td>
<td>字段上</td>
</tr>
<tr>
<td><code>PARAMETER</code></td>
<td>方法参数上</td>
</tr>
</tbody></table>
<p>@Target 也可以同时指定多个位置</p>
<p>@Target({ElementType.TYPE, ElementType.METHOD})</p>
<p>public @interface MyAnno {}</p>
<br/>

<h1 id="注解能活多久"><a href="#注解能活多久" class="headerlink" title="注解能活多久"></a>注解能活多久</h1><p>比如</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>public @interface MyAnno {}</p>
<br/>

<p>MyAnno会一直存在到运行时，因此可以通过反射取出来</p>
<p>而像@Override  </p>
<p>@Retention(SOURCE)</p>
<br/>

<p>意思是:编译后就没了，反射根本拿不到它</p>
<p>下面是常见的@Retention 参数</p>
<table>
<thead>
<tr>
<th><strong>RetentionPolicy</strong></th>
<th><strong>注解保留到什么阶段？</strong></th>
<th><strong>能否通过反射读取？</strong></th>
<th><strong>典型用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SOURCE</strong></td>
<td>只在源码中存在，编译后丢弃</td>
<td>❌ 不能</td>
<td><code>@Override</code><br/>、<code>@SuppressWarnings</code></td>
</tr>
<tr>
<td><strong>CLASS</strong>（默认）</td>
<td>编译后写进 class 文件，但运行时丢弃</td>
<td>❌ 不能</td>
<td>大部分普通注解，供编译器&#x2F;字节码工具用</td>
</tr>
<tr>
<td><strong>RUNTIME</strong></td>
<td>一直保留到运行时</td>
<td>✔ 可以</td>
<td>Spring、MyBatis、JUnit 的注解</td>
</tr>
</tbody></table>
<h1 id="通过反射获取注解信息"><a href="#通过反射获取注解信息" class="headerlink" title="通过反射获取注解信息"></a>通过反射获取注解信息</h1><ol>
<li>类上的</li>
</ol>
<p>Class&lt;?&gt; clazz &#x3D; User.class;</p>
<p>MyAnno anno &#x3D; clazz.getAnnotation(MyAnno.class);</p>
<br/>

<ol start="2">
<li>方法上的</li>
</ol>
<p>Method m &#x3D; clazz.getMethod(“test”);</p>
<p>MyAnno anno &#x3D; m.getAnnotation(MyAnno.class);</p>
<br/>

<ol start="3">
<li>字段上的</li>
</ol>
<p>Field f &#x3D; clazz.getDeclaredField(“name”);</p>
<p>MyAnno anno &#x3D; f.getAnnotation(MyAnno.class);</p>
<br/>

<ol start="4">
<li>参数上的</li>
</ol>
<p>Parameter p &#x3D; m.getParameters()[0];</p>
<p>MyAnno anno &#x3D; p.getAnnotation(MyAnno.class);</p>
<br/>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Java/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E4%B9%9F%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/Java/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E4%B9%9F%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode/" class="post-title-link" itemprop="url">为什么重写equals方法时也必须重写hashCode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>在java中直接&#x3D;&#x3D;比较的是两个对象的jvm内存地址(java没有运算符重载),因此若要实现逻辑比较需要重写equals方法，默认的equals也是比较的jvm内存地址</strong></p>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>hashCode是一个hash摘要</p>
<p>它的工作是:</p>
<ol>
<li>输入一个对象</li>
<li>输出一个整数用于hash的取模运算（ 这个整数就是这个对象的哈希码（hash code）。它的主要目的，就是为了在 <code>HashMap</code> 和 <code>HashSet</code> 这样的集合中实现<strong>快速查找</strong>。  ）</li>
</ol>
<p>这里就体现了java和c++的设计思路不同</p>
<ul>
<li><strong>Java 的思路</strong>：Java 认为“万物皆对象”，并且任何对象都应该有可能被存放到哈希集合里。所以，它在所有对象的祖先 <code>Object</code> 类里直接内置了 hashCode方法用于hash的取模运算。</li>
<li><strong>C++ 的思路</strong>：C++ 遵循“你不需要为你不用的东西付出代价”的原则。它不强制每个类都继承自某个共同的基类。当你需要把你的自定义类（比如 <code>class Person</code>）放进 <code>std::unordered_map</code> 时，你需要<strong>另外</strong>为这个类提供一个哈希函数给容器，而不是在 <code>Person</code> 类里重写一个方法。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">publicinthashCode()&#123; </span><br><span class="line">return Objects.hash(id, name);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="为什么重写equals方法时也必须重写hashCode"><a href="#为什么重写equals方法时也必须重写hashCode" class="headerlink" title="为什么重写equals方法时也必须重写hashCode"></a>为什么重写equals方法时也必须重写hashCode</h2><p>因为在java中使用hash数据结构时,hash值的比较有以下规则</p>
<ol>
<li>先使用hashCode 比较</li>
<li>若hashCode方法比较结果相同在调用equals 方法比较</li>
</ol>
<h3 id="为什么会有这两个规则呢？"><a href="#为什么会有这两个规则呢？" class="headerlink" title="为什么会有这两个规则呢？"></a>为什么会有这两个规则呢？</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1759294316889-321c642f-14d4-4c88-a255-73635fa4a1d9.png"></p>
<h3 id="那么知道equals-的默认实现是比较jvm内存地址-那hashCode的默认实现呢？"><a href="#那么知道equals-的默认实现是比较jvm内存地址-那hashCode的默认实现呢？" class="headerlink" title="那么知道equals 的默认实现是比较jvm内存地址,那hashCode的默认实现呢？"></a>那么知道equals 的默认实现是比较jvm内存地址,那hashCode的默认实现呢？</h3><p>Java 语言规范<strong>并没有严格规定</strong>默认的 <code>hashCode()</code> 必须如何实现，所以不同的 JVM 版本或提供商（比如 Oracle, OpenJDK）可能会有不同的实现方式。</p>
<p>不过，通常情况下，默认的 <code>hashCode()</code> 方法返回的整数是根据对象的<strong>内存地址</strong>计算得出的。</p>
<h2 id="如何重写hashCode方法"><a href="#如何重写hashCode方法" class="headerlink" title="如何重写hashCode方法"></a>如何重写hashCode方法</h2><h3 id="使用Object-hash方法（推荐）"><a href="#使用Object-hash方法（推荐）" class="headerlink" title="使用Object.hash方法（推荐）"></a>使用Object.hash方法（推荐）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line"><span class="code">    private String name;</span></span><br><span class="line"><span class="code">    private int age;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 重写 equals 方法</span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="code">        if (this == o) return true;</span></span><br><span class="line"><span class="code">        if (!(o instanceof Person)) return false;</span></span><br><span class="line"><span class="code">        Person person = (Person) o;</span></span><br><span class="line"><span class="code">        return age == person.age &amp;&amp; Objects.equals(name, person.name);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 重写 hashCode 方法</span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    public int hashCode() &#123;</span></span><br><span class="line"><span class="code">        return Objects.hash(name, age);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Objects.hash(...)</code> 内部会自动组合字段值并生成稳定的哈希码，写法简洁安全。  </p>
<h4 id="objects-hash-方法"><a href="#objects-hash-方法" class="headerlink" title="objects.hash()方法"></a>objects.hash()方法</h4><ul>
<li><code>Objects.hash()</code> 方法可以接受 <strong>任意数量的参数</strong>（包括基本类型的包装类、<code>String</code>、自定义对象，甚至 <code>null</code>）。</li>
<li>当参数是对象类型时，会<strong>自动调用其 <strong><code>**hashCode()**</code></strong> 方法</strong>；若该对象内部也包含自定义字段，会<strong>递归计算哈希值</strong>。</li>
<li>因此，<strong>自定义对象应正确重写 <strong><code>**hashCode()**</code></strong> 方法</strong>，以确保整体哈希值的正确性与稳定性。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Java/volatile_%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/Java/volatile_%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">volatile 关键字详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>volatile</code> 关键字的主要作用是 <strong>保证变量的可见性</strong>，并在一定程度上<strong>禁止指令重排序</strong>，从而在多线程环境中确保变量读写的正确性。  </p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p> 在现代多核CPU架构中，为了提高效率，每个线程可能会有自己的<strong>工作内存（CPU缓存）</strong>。当一个线程修改一个变量时，它可能只是先修改了自己缓存中的副本，并没有立刻写回到主内存中。这就导致其他线程看不到这个更新，它们还在使用自己缓存里那个旧的、过时的数据。  </p>
<p><code>**volatile**</code>** 如何解决？**<code>volatile</code> 就像一个“广播员”，它强制规定：</p>
<ul>
<li><strong>写操作</strong>：当一个线程修改一个<code>volatile</code>变量时，它必须<strong>立即</strong>将这个修改写回到主内存。</li>
<li><strong>读操作</strong>：当一个线程读取一个<code>volatile</code>变量时，它必须<strong>立即</strong>从主内存中读取最新值，而不是使用自己的缓存。</li>
</ul>
<p>通过这种方式，<code>volatile</code> 确保了一个线程对变量的修改对其他所有线程都是“可见”的。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Task implements Runnable &#123;</span><br><span class="line"><span class="code">    private boolean running = true; // 没有 volatile</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    public void stop() &#123;</span></span><br><span class="line"><span class="code">        this.running = false;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Stop method called. running is now &quot; + this.running);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    public void run() &#123;</span></span><br><span class="line"><span class="code">        while (running) &#123;</span></span><br><span class="line"><span class="code">            // ... 持续执行任务 ...</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Task finished.&quot;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">public class Main &#123;</span><br><span class="line"><span class="code">    public static void main(String[] args) throws InterruptedException &#123;</span></span><br><span class="line"><span class="code">        Task myTask = new Task();</span></span><br><span class="line"><span class="code">        Thread taskThread = new Thread(myTask);</span></span><br><span class="line"><span class="code">        taskThread.start();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        Thread.sleep(100); // 确保子线程已经开始运行</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        myTask.stop(); // 主线程请求停止</span></span><br><span class="line"><span class="code">        System.out.println(&quot;Main thread finished.&quot;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>可能出现的问题：</strong><code>taskThread</code>可能将<code>running = true</code>缓存到了自己的工作内存中。当<code>main</code>线程调用<code>stop()</code>方法将主内存中的<code>running</code>改为<code>false</code>时，<code>taskThread</code>可能永远也看不到这个变化，导致<code>while (running)</code>循环变成死循环，程序无法结束。</p>
<p><strong>使用 <strong><code>**volatile**</code></strong> 修正：</strong> 只需要一个简单的修改： <code>private volatile boolean running = true;</code></p>
<p>加上<code>volatile</code>之后，<code>main</code>线程对<code>running</code>的修改会立刻同步到主内存，而<code>taskThread</code>在每次循环判断<code>running</code>时，都会从主内存读取最新值。因此，它一定能看到<code>running</code>变成了<code>false</code>，从而正常退出循环。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="1-什么是指令重排序？"><a href="#1-什么是指令重排序？" class="headerlink" title="1. 什么是指令重排序？"></a>1. 什么是指令重排序？</h3><p>为了提高处理性能，<strong>编译器</strong>和**处理器（CPU）**在不改变单线程程序执行结果的前提下，可能会对我们写的代码指令进行重新排序。</p>
<p>** 举个简单的单线程例子：  **</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;  // 指令1</span><br><span class="line">int b = 2;  // 指令2</span><br><span class="line">a = a + 5;  // 指令3</span><br><span class="line">b = b * b;  // 指令4</span><br></pre></td></tr></table></figure>

<p>在处理器看来，指令3依赖于指令1，指令4依赖于指令2，但指令1和2之间、3和4之间、1和4之间都没有依赖关系。为了优化，处理器完全可能按照 <code>1 -&gt; 2 -&gt; 4 -&gt; 3</code> 或者 <code>2 -&gt; 1 -&gt; 3 -&gt; 4</code> 的顺序来执行，只要最终结果和代码顺序执行的结果一致就行。</p>
<p>在<strong>单线程</strong>环境下，这种重排序是安全的，我们几乎感知不到。但在<strong>多线程</strong>环境下，它就是一颗“定时炸弹”。</p>
<h3 id="2-volatile-如何保证有序性？"><a href="#2-volatile-如何保证有序性？" class="headerlink" title="2. volatile 如何保证有序性？"></a>2. <code>volatile</code> 如何保证有序性？</h3><p><code>volatile</code>关键字通过引入<strong>内存屏障 (Memory Barriers)</strong> 来解决重排序问题。内存屏障可以理解为一个指令，它告诉CPU和编译器：</p>
<ol>
<li>屏障<strong>之前</strong>的所有读写操作都必须在屏障<strong>之后</strong>的读写操作之前完成。</li>
<li>禁止将屏障<strong>之后</strong>的指令重排序到屏障<strong>之前</strong>。</li>
</ol>
<p><code>volatile</code>通过以下两个方面的内存屏障来保证有序性：</p>
<ul>
<li><strong>当对一个</strong><code>**volatile**</code><strong>变量进行写操作时：</strong><ol>
<li>JIT编译器会在<strong>写操作之前</strong>插入一个<strong>StoreStore屏障</strong>，确保在此之前的所有普通写操作都已经完成。</li>
<li>JIT编译器会在<strong>写操作之后</strong>插入一个<strong>StoreLoad屏障</strong>，防止后面的读写操作被重排序到<code>volatile</code>写之前。</li>
</ol>
</li>
<li><strong>当对一个</strong><code>**volatile**</code><strong>变量进行读操作时：</strong><ol>
<li>JIT编译器会在<strong>读操作之后</strong>插入一个<strong>LoadLoad屏障</strong>和<strong>LoadStore屏障</strong>，确保在此之后的读写操作不会被重排序到<code>volatile</code>读之前。</li>
</ol>
</li>
</ul>
<p>简单来说，<code>volatile</code>就像在代码中画了一条线，这条线前后的指令不能随意跨越。</p>
<h3 id="3-经典案例：双重检查锁定-Double-Checked-Locking-的单例模式"><a href="#3-经典案例：双重检查锁定-Double-Checked-Locking-的单例模式" class="headerlink" title="3. 经典案例：双重检查锁定 (Double-Checked Locking) 的单例模式"></a>3. 经典案例：双重检查锁定 (Double-Checked Locking) 的单例模式</h3><p>这是解释<code>volatile</code>有序性最经典的例子。</p>
<p><strong>一个有问题的DCL单例实现（没有</strong><code>**volatile**</code><strong>）：</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"><span class="code">    private static Singleton instance; // 没有 volatile</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    private Singleton() &#123;&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    public static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="code">        if (instance == null) &#123; // 第一次检查</span></span><br><span class="line"><span class="code">            synchronized (Singleton.class) &#123;</span></span><br><span class="line"><span class="code">                if (instance == null) &#123; // 第二次检查</span></span><br><span class="line"><span class="code">                    instance = new Singleton(); // 问题根源</span></span><br><span class="line"><span class="code">                &#125;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        return instance;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题出在哪里？</strong><code>instance = new Singleton();</code> 这行代码看起来是一步操作，但它在JVM中大致分为三步：</p>
<ol>
<li><strong>分配内存</strong>：为<code>Singleton</code>对象分配一块内存空间。</li>
<li><strong>初始化对象</strong>：调用<code>Singleton</code>的构造方法，初始化成员字段。</li>
<li><strong>建立引用</strong>：将<code>instance</code>变量指向刚刚分配的内存地址。</li>
</ol>
<p>由于指令重排序的存在，这三步的执行顺序可能是 <code>1 -&gt; 2 -&gt; 3</code>（正常顺序），也可能是 <code>1 -&gt; 3 -&gt; 2</code>（重排后的顺序）。</p>
<p><strong>多线程下的致命错误：</strong> 假设有两个线程A和B。</p>
<ol>
<li>线程A进入同步块，执行 <code>instance = new Singleton();</code>。</li>
<li>发生了重排序，JVM先执行了第1步（分配内存）和第3步（建立引用）。此时，<code>instance</code>变量已经<strong>不再是 <strong><code>**null**</code></strong> 了</strong>，但它指向的对象还<strong>没有被初始化</strong>（第2步还没执行）。</li>
<li>就在这一刻，线程B来了，它执行到第一次检查 <code>if (instance == null)</code>。</li>
<li>线程B发现<code>instance</code>不是<code>null</code>，于是跳过同步块，直接返回了<code>instance</code>。</li>
<li>但是，这个<code>instance</code>是一个<strong>没有被初始化完成的“半成品”对象</strong>。如果线程B此时去使用这个对象的任何成员变量，都可能会引发错误（比如空指针异常）。</li>
<li><strong>如何用</strong><code>**volatile**</code><strong>修正？</strong> 只需要一个简单的修改： <code>private volatile static Singleton instance;</code></li>
</ol>
<p>加上<code>volatile</code>之后，内存屏障会确保<code>instance = new Singleton();</code>这行代码的内部指令<strong>不会被重排序</strong>。它会强制保证第2步（初始化对象）一定在第3步（建立引用）之前完成。 这样，当其他线程看到<code>instance</code>不为<code>null</code>时，它们拿到的一定是一个已经完整构造好的对象，从而避免了上述问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Java/Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Java/Java/Stream/" class="post-title-link" itemprop="url">Stream</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h1><p>Stream 就像一条流水线，你把数据放进去，然后经过各种加步骤（filter&#x2F;map）,最后输出结果(forEach&#x2F;collect)</p>
<h1 id="Stream的三个核心点"><a href="#Stream的三个核心点" class="headerlink" title="Stream的三个核心点"></a>Stream的三个核心点</h1><ol>
<li>不会修改原集合,stream是”读取”,不是”改写”</li>
<li>一步一步串起来执行（像流水线）</li>
<li>最终必须有一个“终止操作”才能真正执行，没有终止操作，流水线不会运作</li>
</ol>
<h1 id="如何创建Stream"><a href="#如何创建Stream" class="headerlink" title="如何创建Stream"></a>如何创建Stream</h1><ol>
<li>从集合创建（最常用）</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List<span class="language-xml"><span class="tag">&lt;<span class="name">Integer</span>&gt;</span></span> list = List.of(1, 2, 3);</span><br><span class="line">Stream<span class="language-xml"><span class="tag">&lt;<span class="name">Integer</span>&gt;</span></span> stream = list.stream();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从数组创建</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">IntStream stream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>直接创建（开发里不太常用）</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="language-xml"><span class="tag">&lt;<span class="name">String</span>&gt;</span></span> stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="数据加工"><a href="#数据加工" class="headerlink" title="数据加工"></a>数据加工</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
