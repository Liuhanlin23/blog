<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="刘翰霖">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">刘翰霖</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>_ 数据库与缓存的强一致性其实是一个伪命题。既然引入缓存是为了提高系统的并发性能，就必须接受两者之间__<strong>可能存在短暂不一致</strong><strong>的事实。<br>因此，我们的目标不是追求完全一致，而是</strong><strong>尽可能保证最终一致性</strong><strong>。<br>在当前实践中，最稳妥、通用的做法是：</strong><strong>先更新数据库，再删除缓存（Cache-Aside 模式）</strong>__，这样可以最大程度地降低数据不一致的风险。  _</p>
<h2 id="先更新数据库还是先更新缓存"><a href="#先更新数据库还是先更新缓存" class="headerlink" title="先更新数据库还是先更新缓存"></a>先更新数据库还是先更新缓存</h2><p> 当执行写操作时，无论是<strong>先更新数据库再更新缓存</strong>，还是<strong>先更新缓存再更新数据库</strong>，都可能导致<strong>数据库与缓存数据不一致</strong>的问题。  </p>
<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760857257593-45414a73-5251-4100-ae53-01c13ed45062.png"></p>
<p>举个例子，比如有A,B两个请求同时更新同一条数据，则可能出现这样的顺序</p>
<p>A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。</p>
<p>此时，数据库中的数据是 2，而缓存中的数据却是 1，<strong>出现了缓存和数据库中的数据不一致的现象。</strong></p>
<h3 id="先更新缓存再更新数据库"><a href="#先更新缓存再更新数据库" class="headerlink" title="先更新缓存再更新数据库"></a>先更新缓存再更新数据库</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760857381327-125861e6-888d-4faf-b492-47d0122254cb.png">A 请求先将缓存的数据更新为 1，然后在更新数据库前，B 请求来了，将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 A 请求将数据库的数据更新为 1。</p>
<p>此时，数据库中的数据是 1，而缓存中的数据却是 2，<strong>出现了缓存和数据库中的数据不一致的现象。</strong></p>
<p>所以，<strong>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」</strong>，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p>
<h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><p><strong>最好的方式还是先更新数据库再删除缓存</strong></p>
<h3 id="先更新数据库再删除缓存"><a href="#先更新数据库再删除缓存" class="headerlink" title="先更新数据库再删除缓存"></a>先更新数据库再删除缓存</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760858210694-457dfc38-b9eb-4a05-8643-25787beaea1c.png"></p>
<p><font style="color:rgb(44, 62, 80);">假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。</font><strong><font style="color:rgb(48, 79, 254);">但是在实际中，这个问题出现的概率并不高</font></strong><font style="color:rgb(44, 62, 80);">。</font></p>
<p><strong><font style="color:rgb(48, 79, 254);">因为缓存的写入通常要远远快于数据库的写入</font></strong><font style="color:rgb(44, 62, 80);">，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</font></p>
<p><font style="color:rgb(44, 62, 80);">而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</font></p>
<p><font style="color:rgb(44, 62, 80);">所以，</font><strong><font style="color:rgb(48, 79, 254);">「先更新数据库 + 再删除缓存」的方案，是可以很大程度保证数据一致性的</font></strong><font style="color:rgb(44, 62, 80);">。</font></p>
<p><font style="color:rgb(44, 62, 80);">并且实际中我们也会为缓存加上过期时间，如果出现数据库和缓存不一致，也是再这个时间呢，最终还是可以实现一致性</font></p>
<h4 id="如何应对缓存删除失败"><a href="#如何应对缓存删除失败" class="headerlink" title="如何应对缓存删除失败"></a><font style="color:rgb(44, 62, 80);">如何应对缓存删除失败</font></h4><p>假设我么再更新完数据库后删除缓存失败了，导致缓存还是旧值，不又会出现缓存数据不一致么？所以针对这个问题有两个解决方案</p>
<h5 id="1-消息队列重试机制"><a href="#1-消息队列重试机制" class="headerlink" title="1.消息队列重试机制"></a>1.消息队列重试机制</h5><p><font style="color:rgb(44, 62, 80);">我们可以引入</font><strong><font style="color:rgb(48, 79, 254);">消息队列</font></strong><font style="color:rgb(44, 62, 80);">，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。保证并发能力的同时又一定程度的避免缓存删除失败出现的缓存数据不一致</font></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">如果应用</font><strong><font style="color:rgb(48, 79, 254);">删除缓存失败</font></strong><font style="color:rgb(44, 62, 80);">，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是</font><strong><font style="color:rgb(48, 79, 254);">重试机制</font></strong><font style="color:rgb(44, 62, 80);">。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</font></li>
<li><font style="color:rgb(44, 62, 80);">如果</font><strong><font style="color:rgb(48, 79, 254);">删除缓存成功</font></strong><font style="color:rgb(44, 62, 80);">，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</font></li>
</ul>
<p>缺点：<font style="color:rgb(44, 62, 80);">对代码入侵性比较强，因为需要改造原本业务的代码。</font></p>
<h5 id="订阅mysql-binlog，再操作删除"><a href="#订阅mysql-binlog，再操作删除" class="headerlink" title="订阅mysql binlog，再操作删除"></a>订阅mysql binlog，再操作删除</h5><p><font style="color:rgb(44, 62, 80);">「</font><strong><font style="color:rgb(48, 79, 254);">先更新数据库，再删缓存</font></strong><font style="color:rgb(44, 62, 80);">」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</font></p>
<h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a><font style="color:rgb(44, 62, 80);">先删除缓存，再更新数据库</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760858396753-dfbe5a38-281c-45fc-bf86-d07ff31fe8ea.png"></p>
<p>再来看看先删除缓存，再更新数据库</p>
<p><font style="color:rgb(44, 62, 80);">假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</font></p>
<p><font style="color:rgb(44, 62, 80);">最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</font></p>
<p><font style="color:rgb(44, 62, 80);">可以看到，</font><strong><font style="color:rgb(48, 79, 254);">先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</font></strong><font style="color:rgb(44, 62, 80);">。</font></p>
<h4 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a><font style="color:rgb(44, 62, 80);">延迟双删</font></h4><p><em>这个方案是有待商榷的，知识网上有这样的言论，在实际开发中可以忽略这个方案</em></p>
<p><font style="color:rgb(44, 62, 80);">针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「</font><strong><font style="color:rgb(48, 79, 254);">延迟双删</font></strong><font style="color:rgb(44, 62, 80);">」。</font></p>
<p><font style="color:rgb(44, 62, 80);">延迟双删实现的伪代码如下：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760858663392-a7a0e5d3-72b5-4955-b3d6-a1ffa7830af4.png"></p>
<p><font style="color:rgb(44, 62, 80);">加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。</font></p>
<p><font style="color:rgb(44, 62, 80);">所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。</font></p>
<p><font style="color:rgb(44, 62, 80);">但是这个睡眠时间就很难设定，设定太大了会导致并发能力下降，太小了就又会容易出现数据库缓存不一致问题，所以还是建议采用像更新数据库，再删除缓存的方案</font></p>
<p><font style="color:rgb(44, 62, 80);"></font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/%E6%8C%81%E4%B9%85%E5%8C%96/RDB_%E5%BF%AB%E7%85%A7%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/%E6%8C%81%E4%B9%85%E5%8C%96/RDB_%E5%BF%AB%E7%85%A7%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>RDB快照就是记录的某一瞬间的内存数据，记录的是实际数据，而AOF文件记录的是写操作命令，所以redis在回复数据的时候RDB恢复数据的效率比AOF高</p>
<h2 id="快照怎么用"><a href="#快照怎么用" class="headerlink" title="快照怎么用"></a>快照怎么用</h2><ol>
<li>redis 提供了两个命令来生成RDB文件，分别是save 和 bgsave</li>
</ol>
<ul>
<li>save就是在主线程中执行快照操作，可能会阻塞主线程</li>
<li>bgsave就是在子进程中执行快照操作，可以避免主线程的阻塞</li>
</ul>
<ol start="2">
<li>可以通过配置文件来实现每隔一段时间自动执行一次bgsave命令</li>
</ol>
<h2 id="如何执行bgsave-快照（写时复制）"><a href="#如何执行bgsave-快照（写时复制）" class="headerlink" title="如何执行bgsave 快照（写时复制）"></a>如何执行bgsave 快照（写时复制）</h2><ul>
<li><strong>主进程</strong> 收到 <code>BGSAVE</code> 命令后，检查当前是否已有子进程在执行 <code>BGSAVE</code> 或 <code>BGREWRITEAOF</code>（两者不能并行）</li>
<li><strong>主进程</strong> 调用 <code>fork()</code> 创建 <strong>RDB 保存子进程</strong></li>
<li><strong>子进程</strong> 通过 <strong>写时复制（Copy-On-Write, COW）</strong> 技术，扫描当前数据库中的所有数据，并将数据序列化写入临时文件（如 <code>temp-12345.rdb</code>）</li>
<li>在写入期间，<strong>主进程</strong> 仍然可以正常处理客户端请求（读写不受阻塞）</li>
<li><strong>子进程</strong> 写入完成后，将临时文件重命名为正式的 <code>dump.rdb</code> 文件</li>
<li><strong>子进程</strong> 向主进程发送完成信号</li>
</ul>
<p>主进程在执行bgsave可以正常处理客户端请求的关键就是写实复制</p>
<ul>
<li>创建子进程后，父进程和子进程共享相同的数据页  </li>
<li>当主进程或子进程对共享数据进行<strong>写操作</strong>时，操作系统才会复制出该数据页的副本，写操作在副本上完成。  </li>
<li>这样既保证了子进程读取的是快照时刻的数据，又避免了在创建时整体复制内存导致的性能消耗。</li>
</ul>
<p> 需要注意的是，<strong>RDB 快照没有类似 AOF 的重写缓冲区</strong>。<br>因此，RDB 快照只会保存<strong>快照开始那一刻的内存数据</strong>，而在快照生成过程中发生的任何数据修改，都不会被记录进当前的 RDB 文件中。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="AOF持久化是如何实现的"><a href="#AOF持久化是如何实现的" class="headerlink" title="AOF持久化是如何实现的"></a>AOF持久化是如何实现的</h2><p>AOF持久化本质就是借助AOF日志保存Redis 执行的写操作命令（注意只会记录写操作命令,读操作命令不会记录没有意义）,当Redis 重启的时候,先去读取这个文件里的命令并执行,就实现了保存数据的功能</p>
<p><em>Redis中的AOF持久化功能默认是不开启的,需要我们修改该redis.conf配置文件中的一下参数</em></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760771191162-5b9c1f9e-cfaa-4702-9891-d581b5ea65ea.png"></p>
<p><em>AOF日志文件本也就是普通文本，不过它保存的不是原生的reids 命令，而是RESP协议格式,这种格式对机器更友好,执行效率更高并且不会产生歧义</em></p>
<h2 id="Redis-的AOF日志写入在什么时候？为什么？"><a href="#Redis-的AOF日志写入在什么时候？为什么？" class="headerlink" title="Redis 的AOF日志写入在什么时候？为什么？"></a>Redis 的AOF日志写入在什么时候？为什么？</h2><p><strong>redis 是在写入操作之后才执行AOF日志写入</strong></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><font style="color:#DF2A3F;">避免额外的检查开销</font></li>
<li>.+,如果先写入日志再执行写操作命令的话,还需要检查命令是否执行成功,不成功的话还要进行日志的回退</li>
<li><font style="color:#DF2A3F;">不会阻塞当前写操作命令的执行</font>,因为是写操作成功才会执行AOF日志写入</li>
</ol>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol>
<li><font style="color:#DF2A3F;">丢失风险</font><font style="color:#000000;">,执行写操作和记录日志是两个过程,如果写操作后redis还没来得即将命令写入硬盘，服务器发生宕机就会出现丢失风险</font></li>
<li><font style="color:#DF2A3F;">给下一个命令带来阻塞</font><font style="color:#000000;">，前面说到由于是再写操作后才执行AOF日志写入,所以不会阻塞当前的写操作命令,但可能会阻塞下一个命令</font></li>
</ol>
<h2 id="三种回写策略"><a href="#三种回写策略" class="headerlink" title="三种回写策略"></a>三种回写策略</h2><p><font style="color:rgb(44, 62, 80);">Redis 写入 AOF 日志的过程，如下图：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760772039086-de8c9f2a-efec-4b93-a323-8fd3676a7432.png"></p>
<ol>
<li>reids 执行写操作的时候,会将命令追加到用户缓冲区</li>
<li>然后通过write()系统调用将命令写入到内核缓冲区</li>
<li>之后os内核自主决定什么时候将内核缓冲区的数据写入到硬盘</li>
</ol>
<p>所以此时redis 就会出现三种回写策略</p>
<ol>
<li>Always <font style="color:rgb(44, 62, 80);">每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</font></li>
<li><font style="color:rgb(44, 62, 80);">Everysec，（每秒）每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</font></li>
<li><font style="color:rgb(44, 62, 80);">No， 不由redis控制写回硬盘的时机，转交给os控制写回的时机，也就是每次写操作命令执行后,先将命令写入到AOF文件的内核缓冲区,再由OS决定何时将缓冲区内容写回硬盘</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760772797212-2e76b6c0-92c8-4592-b6e5-6f3d80bdc90e.png"></p>
<p>Redis 的三种 AOF 写回策略，本质上都是用来控制 <code>fsync()</code> 的调用时机——也就是<strong>何时将内核缓冲区（Page Cache）中的数据真正写入磁盘</strong>。</p>
<p>需要注意的是，Redis 的 AOF 写入过程包含两层缓冲：</p>
<ul>
<li><strong>用户态缓冲区（aof_buf）</strong>：Redis 进程内部维护，用于暂存命令文本。</li>
<li><strong>内核态缓冲区（Page Cache）</strong>：操作系统层面的文件缓存。</li>
</ul>
<p>虽然这三种写回策略直接控制的是“内核缓冲区 → 磁盘”的刷新频率，但 Redis 在语义层面也保证了用户缓冲区的安全：<br>在调用 <code>fsync()</code> 之前，它会先调用 <code>write()</code>，确保用户态缓冲区的数据已经写入内核态缓冲区。</p>
<p>换句话说，三种写回策略控制的是<strong>数据何时真正落盘</strong>，<br>而 Redis 自身的实现逻辑确保了在触发 <code>fsync()</code> 之前，用户态缓冲区中的数据已经被安全送入内核态缓冲区。</p>
<h2 id="write（）和fsync（）的调用线程"><a href="#write（）和fsync（）的调用线程" class="headerlink" title="write（）和fsync（）的调用线程"></a>write（）和fsync（）的调用线程</h2><p> AOF 三种写回策略中，执行 write() 将 AOF 缓冲区写入内核页缓存的步骤始终由主线程完成，write() 很快，几乎不会阻塞。<br>差异在于执行 fsync() 的方式：<br>Always 模式下，由<font style="color:#DF2A3F;">主线程同步执行 fsync()</font>，必须等磁盘落盘完成才继续，速度慢，遇到大 key 会明显阻塞。<br>Everysec 模式下，由<font style="color:#DF2A3F;">后台的慢 IO 线程异池</font>异步执行 fsync()，主线程只负责 write，不会因磁盘 IO 被阻塞，最多丢 1 秒数据。<br>No 模式下，主线程仅 write，不主动 fsync，刷盘完全由操作系统自行处理，性能最好，但可能丢较多数据。  </p>
<h2 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h2><p><strong>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。</strong></p>
<p>如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完成后，就将新的 AOF 文件替换现有的 AOF 文件。</p>
<p>例如，在没有重写前，假如先后执行了set name a 和 set name b，这两个命令，就会将这两个记录写入到AOF中，但是其实只有最后一个命令set name 是有效的,所以再进行AOF重写之后就会大大压缩AOF文件，同时再AOF日志恢复数据的时候效率也会提高</p>
<h3 id="AOF如何进行重写"><a href="#AOF如何进行重写" class="headerlink" title="AOF如何进行重写"></a>AOF如何进行重写</h3><p>AOF的写入操作是在主进程完成的，因为它写入的命令不多，但是再触发AOF重写的时候需要创建子进程完成，因为很耗时会阻塞redis</p>
<h3 id="重写过程"><a href="#重写过程" class="headerlink" title="重写过程"></a>重写过程</h3><ul>
<li>主进程创建AOF重写子进程</li>
<li>子进程扫描数据库中的所有数据,逐一把内存数据的键值对转换成一条命令，再将命令记录到新的重写日志中，完成后会向主进程发送信号</li>
<li>主进程接收到这个信号后将<strong>AOF重写缓冲区</strong>中的所有内容追加到新的AOF日志中，使得新旧两个AOF文件所保存的数据库状态一直</li>
<li>最后将新AOF文件替换旧的AOF文件</li>
</ul>
<h3 id="AOF重写缓冲区VS-AOF缓冲区"><a href="#AOF重写缓冲区VS-AOF缓冲区" class="headerlink" title="AOF重写缓冲区VS AOF缓冲区"></a>AOF重写缓冲区VS AOF缓冲区</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760850284564-1e7b07e8-170f-4a37-8a13-4c254706de10.png"></p>
<p><strong>AOF 缓冲区</strong>是 Redis 在正常运行时用于暂存写命令的用户态内存区域，这些命令会被定期写入磁盘形成 AOF 日志；<br>而 <strong>AOF 重写缓冲区</strong> 仅在执行 AOF 重写（rewrite）时存在，用于临时保存重写过程中产生的新写命令，保证重写完成后数据不丢失。<br>两者都属于 <strong>用户态缓冲区</strong>，位于 Redis 进程内部内存中。  </p>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><p> 假设你在运行中的 Redis 中执行以下操作：  </p>
<p>SET name Alice</p>
<p>SET age 20</p>
<br/>

<p>这两条命令会先写入 <strong>AOF 缓冲区（aof_buf）</strong>，然后根据 <code>appendfsync</code> 策略被写入磁盘。</p>
<p>此时如果 Redis 触发了 <strong>AOF 重写</strong>（为了压缩日志文件），后台子进程会创建一个新文件来重写旧日志；<br>在这段时间你又执行了：</p>
<p>SET city Beijing</p>
<br/>

<p>这条新命令会被同时写入：</p>
<ul>
<li>普通的 <strong>AOF 缓冲区</strong>（保持旧文件正确性）；</li>
<li>以及 <strong>AOF 重写缓冲区</strong>（保证新文件重写完成后也包含这条命令，防止数据不一致）。</li>
</ul>
<p>当重写结束后，Redis 会把重写缓冲区中的 <code>SET city Beijing</code> 追加到新文件末尾，然后替换旧 AOF 文件。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/%E6%8C%81%E4%B9%85%E5%8C%96/AOF+RDB%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/%E6%8C%81%E4%B9%85%E5%8C%96/AOF+RDB%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><font style="color:rgb(44, 62, 80);">如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</font></p>
<p>aof-use-rdb-preamble yes</p>
<br/>

<p>混合持久化可以兼顾RDB的恢复速度，以及解决RDB快照生成时丢失进行快照生成过程的数据修改</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>当开启混合持久化时，执行 <strong>AOF 重写</strong> 会由主进程 <code>fork</code> 出一个 <strong>重写子进程</strong>。</li>
<li>子进程会将当前内存中的数据以 <strong>RDB 格式</strong> 写入新的 AOF 文件（即写入时是全量数据）。</li>
<li>在此过程中，主进程仍可处理新的写命令；这些命令会被记录到 <strong>AOF 重写缓冲区</strong> 中。</li>
<li>重写完成后，主进程将缓冲区中的增量命令以 <strong>AOF 格式</strong> 追加到新文件末尾。</li>
<li>最终，新 AOF 文件由两部分组成：</li>
<li><strong>前半部分：RDB 格式的全量数据</strong></li>
<li><strong>后半部分：AOF 格式的增量命令</strong></li>
<li>写入完成后，Redis 会用新的混合格式 AOF 文件替换旧文件，实现高效且数据一致的持久化。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>redis 中的hash表数据结构就是一个正常的哈希表采用<strong>链式哈希</strong>来解决哈希冲突</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539193121-5c42e9fe-e3e5-4db4-a7f2-ba3afe433d1c.png">如图dictht 指向一个哈希表的数组,数组中每个元素都是一个哈希表节点的链表</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>redis的哈希表有一个 特点就是一个哈希表结构体中定义了两个哈希表，<font style="color:rgb(44, 62, 80);">之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539292770-805ea47d-cbd6-4894-9afe-272a166d6f28.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539328496-c26f66ec-9eca-4646-a7ab-6fac98d90ad1.png"></p>
<h3 id="渐进式hash"><a href="#渐进式hash" class="headerlink" title="渐进式hash"></a>渐进式hash</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539601585-aa657ad0-eca8-41a2-81d6-d9e289855d27.png"></p>
<h3 id="rehash的触发条件"><a href="#rehash的触发条件" class="headerlink" title="rehash的触发条件"></a>rehash的触发条件</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539624416-d50fac17-c054-44b3-a616-ec241a4307a7.png"></p>
<p><strong><font style="color:rgb(48, 79, 254);"></font></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/ZSET/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/ZSET/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-什么是zset"><a href="#一-什么是zset" class="headerlink" title="一.什么是zset"></a>一.什么是zset</h1><p> Redis 中的 **ZSet（Sorted Set，有序集合） ,它在集合（Set）的基础上，为每个元素关联了一个 score（分数），并且所有元素会根据这个分数自动 从小到大排序。  **</p>
<p>** 非常适合用来做排行榜、延时队列、优先级任务、推荐系统等场景。  **</p>
<h1 id="二-zset的常用命令"><a href="#二-zset的常用命令" class="headerlink" title="二.zset的常用命令"></a>二.zset的常用命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member [score member ...]</code></td>
<td>添加元素及其分数</td>
<td><code>ZADD rank 100 user1 90 user2</code></td>
</tr>
<tr>
<td><code>ZRANGE key start stop [WITHSCORES]</code></td>
<td>按排名升序取值</td>
<td><code>ZRANGE rank 0 2 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZREVRANGE key start stop [WITHSCORES]</code></td>
<td>按排名降序取值</td>
<td><code>ZREVRANGE rank 0 2 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>查询指定成员的分数</td>
<td><code>ZSCORE rank user1</code></td>
</tr>
<tr>
<td><code>ZINCRBY key increment member</code></td>
<td>增加某个成员的分数</td>
<td><code>ZINCRBY rank 10 user1</code></td>
</tr>
<tr>
<td><code>ZREM key member [member ...]</code></td>
<td>删除元素</td>
<td><code>ZREM rank user2</code></td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取集合中元素个数</td>
<td><code>ZCARD rank</code></td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>获取成员的升序排名</td>
<td><code>ZRANK rank user1</code></td>
</tr>
<tr>
<td><code>ZREVRANK key member</code></td>
<td>获取成员的降序排名</td>
<td><code>ZREVRANK rank user1</code></td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></td>
<td>按分数范围取值</td>
<td><code>ZRANGEBYSCORE rank 50 100 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZREMrangeByScore key min max</code></td>
<td>删除某个分数区间的成员</td>
<td><code>ZREMRANGEBYSCORE rank 0 50</code></td>
</tr>
</tbody></table>
<p>三.zset的底层数据结构</p>
<p><strong>ZSet 底层使用跳表（SkipList）实现，而不是平衡树。</strong><br>跳表通过多层索引结构实现平均 O(log n) 的查找效率，与平衡树相同，但结构更简单、插入删除更高效。  </p>
<h2 id="redis-中zset为什么使用跳表而不是平衡树"><a href="#redis-中zset为什么使用跳表而不是平衡树" class="headerlink" title="redis 中zset为什么使用跳表而不是平衡树"></a>redis 中zset为什么使用跳表而不是平衡树</h2><ol>
<li>从内存角度看，跳表比平衡树更省空间：跳表节点平均仅需约两个指针（前后），而平衡树节点通常要维护三个指针（左、右、父）  </li>
<li>跳表底层是<strong>有序链表</strong>，范围查询可从起点一路向后遍历，<br>复杂度 O(log n + k)，实现简单；平衡树则需进行<strong>中序遍历</strong>。</li>
<li><strong>实现更简单、维护成本低</strong>：跳表更新删除只需要变动指针即可；平衡树必须通过<strong>旋转操作</strong>维持结构平衡，逻辑繁琐、实现复杂。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/ZipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/ZipList/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">压缩列表</font></strong></a><strong><font style="color:rgb(25, 27, 31);">（</font></strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=ziplist&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">ziplist</font></strong></a><strong><font style="color:rgb(25, 27, 31);">）本质上就是一个字节数组，是</font></strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=Redis&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">Redis</font></strong></a><strong><font style="color:rgb(25, 27, 31);">为了节约内存而设计的一种线性数据结构</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760537667649-decf9823-34b3-449a-997e-315d61f152ec.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760537684492-157cd6b7-4198-4169-8ffb-7d15c239aada.png"></p>
<p><strong><font style="color:rgb(25, 27, 31);">而压缩列表节点又有三个属性组成，分别是previous_entry_length，encoding，content</font></strong><font style="color:rgb(25, 27, 31);">。</font></p>
<ol>
<li><strong><font style="color:rgb(25, 27, 31);">previous_entry_length</font></strong></li>
</ol>
<p><font style="color:rgb(25, 27, 31);">这个属性记录了压缩列表前一个节点的长度，用于实现“链表的向前查找”</font></p>
<p><font style="color:rgb(25, 27, 31);">这个属性记录了压缩列表前一个节点的长度，</font><strong><font style="color:rgb(25, 27, 31);">该属性根据前一个节点的大小不同可以是1个字节或者5个字节。</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">如果前一个节点的长度小于254个字节，那么previous_entry_length的大小为1个字节，</font><strong><font style="color:rgb(25, 27, 31);">即前一个节点的长度可以使用1个字节表示</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">如果前一个节点的长度大于等于254个字节，那么previous_entry_length的大小为5个字节</font><strong><font style="color:rgb(25, 27, 31);">，第一个字节会被设置为0xFE(十进制的254），之后的四个字节则用于保存前一个节点的长度。</font></strong></p>
<ol start="2">
<li><strong><font style="color:rgb(25, 27, 31);">encoding</font></strong></li>
</ol>
<p><strong>当前节点的数据类型与长度编码信息</strong><strong><font style="color:rgb(25, 27, 31);">。  </font></strong></p>
<p>它的作用是告诉 Redis：</p>
<p><strong><font style="color:rgb(25, 27, 31);">“当前节点的内容（content）是字符串还是整数？如果是字符串，它的长度是多少？如果是整数，是哪种整数类型？”</font></strong></p>
<ol start="3">
<li><strong><font style="color:rgb(25, 27, 31);">content</font></strong></li>
</ol>
<p><strong><font style="color:rgb(25, 27, 31);">content属性负责保存节点的值，值的具体类型由上一个字段encoding来决定。</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760538093497-b652385b-6c44-454b-a413-24fbd791ee9b.png"></p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p><strong><font style="color:rgb(25, 27, 31);">当添加或删除节点时，可能就会因为previous_entry_length的变化导致发生连锁的更新操作。</font></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/redis_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/redis_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>主线程：唯一负责命令解析&#x2F;执行、数据结构操作、事件循环调度、AOF&#x2F;RDB 触发等“核心逻辑”。（也就是真正执行读写操作的线程）</li>
<li>网络io线程，多个网络io线程处理网络io</li>
<li>BIO 线程池（处理慢io的线程池）：固定几个后台线程处理慢 IO（aof fsync、close&#x2F;open、lazy-free 等），避免主线程被阻塞。比如说当写回策略是Everysec 的时候就由慢io线程池调用fsync 方法将AOF内核缓冲区刷新到磁盘中</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/redis_%E5%A4%A7key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/redis_%E5%A4%A7key/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis-的大key-会引发什么问题"><a href="#redis-的大key-会引发什么问题" class="headerlink" title="redis 的大key 会引发什么问题"></a>redis 的大key 会引发什么问题</h1><h2 id="大key-对AOF的影响"><a href="#大key-对AOF的影响" class="headerlink" title="大key 对AOF的影响"></a>大key 对AOF的影响</h2><ol>
<li>如果使用always写回策略，那么由主线程同步调用fsync（）方法，对于大key的写入很耗时，会造成阻塞</li>
<li>如果是Everysec或no 策略则不会影响主线程，因为Everysec 由慢IO线程池异步调用fsync，no策略是由OS自主调用fsync</li>
</ol>
<h2 id="大Key对AOF重写和RDB的影响"><a href="#大Key对AOF重写和RDB的影响" class="headerlink" title="大Key对AOF重写和RDB的影响"></a>大Key对AOF重写和RDB的影响</h2><h3 id="容易触发AOF重写-当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写"><a href="#容易触发AOF重写-当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写" class="headerlink" title="容易触发AOF重写:当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写"></a><font style="color:#DF2A3F;">容易触发AOF重写:</font>当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写</h3><h3 id="创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；"><a href="#创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；" class="headerlink" title="创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；"></a><font style="color:rgb(44, 62, 80);">创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</font></h3><p>Redis 在执行 AOF 重写或 RDB 快照时需要 <code>fork()</code> 创建子进程。<code>fork()</code> 会将父进程的整张页表复制一份给子进程，因此当实例中存在大量大 key、占用内存页很多时，页表规模会变得很大，导致页表复制过程耗时严重，从而使 <code>fork()</code> 阻塞主线程。</p>
<p>例如你用一个 <strong>大 key</strong> 存了 500MB 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET bigkey &lt;500MB value&gt;</span><br></pre></td></tr></table></figure>

<p>那么 Redis 进程就会多出 <strong>500MB 内存占用</strong>。</p>
<p>而操作系统管理内存的单位是 <strong>页（page）</strong>，一般是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 页 = 4KB</span><br></pre></td></tr></table></figure>

<p>那么 500MB 大概需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500MB / 4KB ≈ 128,000 个页</span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<p>Redis 必须创建 <strong>128,000 个页表项</strong> 来记录这些映射关系。</p>
<p>因此：</p>
<p><strong>大 Key 必然导致页表变大，因为大 Key 占用更多内存页，而每一个页都要一个页表项。</strong></p>
<h3 id="创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长"><a href="#创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长" class="headerlink" title="创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长"></a><font style="color:rgb(44, 62, 80);">创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长</font></h3><h2 id="大key-除了影响持久化外，还会有一下影响"><a href="#大key-除了影响持久化外，还会有一下影响" class="headerlink" title="大key 除了影响持久化外，还会有一下影响"></a>大key 除了影响持久化外，还会有一下影响</h2><ol>
<li><font style="color:rgb(44, 62, 80);">客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</font></li>
<li><font style="color:rgb(44, 62, 80);">引发网络阻塞。每次获取大 key 产生的网络流量较大，引发网络阻塞。每次获取大 key 产生的网络流量较大，这对于普通千兆网卡的服务器来说是灾难性的。</font></li>
<li><font style="color:rgb(44, 62, 80);">使用del删除大 key 时，会阻塞工作线程（建议使用unlink 命令删除大key）</font></li>
</ol>
<h1 id="如何避免大key呢"><a href="#如何避免大key呢" class="headerlink" title="如何避免大key呢"></a><font style="color:rgb(44, 62, 80);">如何避免大key呢</font></h1><ol>
<li>在设计阶段，尽量把大key 拆成很多小key</li>
<li>不要使用del命令删除大key，该命令会阻塞主线程，使用unlink（redis4.0）命令删除（ 主线程只负责将 key 从字典中移除，不会阻塞  ，真正的内存释放由后台慢IO线程池完成）</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/redis/redis/redis_%E4%B8%AD%E7%9A%84LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/redis/redis/redis_%E4%B8%AD%E7%9A%84LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-11-25 20:31:43 / 修改时间：20:27:21" itemprop="dateCreated datePublished" datetime="2025-11-25T20:31:43+08:00">2025-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>LRU算法全称是Latest Recently Used 最近最少使用，最选择淘汰最近最少使用的数据</p>
<h3 id="传统LRU的实现"><a href="#传统LRU的实现" class="headerlink" title="传统LRU的实现"></a>传统LRU的实现</h3><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<h3 id="redis-如何实现LRU"><a href="#redis-如何实现LRU" class="headerlink" title="redis 如何实现LRU"></a>redis 如何实现LRU</h3><p>redis 实现的是一种近似的LRU算法，目的是为了更好的节约内存，它的实现方式是在Redis的对象结构体中添加一个额外的字段，用于记录数据的最后一次访问时间</p>
<p>当Redis 进行内存淘汰的时候，会使用<strong>随机采样</strong>的方法来淘汰数据，就是随机取5个值（此值可配），然后淘汰最久没有使用的那个</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p>
<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>LFU 全称是 Least Frequently Used，翻译为<strong>最近最不常用</strong>。<br>LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是：“如果数据过去被访问得多次，那么将来被访问的频率也更高。”</p>
<p> 所以，LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据仍然在缓存中长期占用的问题。**所以作为缓存数据库，相比于 LRU 算法，LFU 算法更加合理。 ** </p>
<h3 id="redisLFU的实现"><a href="#redisLFU的实现" class="headerlink" title="redisLFU的实现"></a>redisLFU的实现</h3><p> LFU 算法相对于 LRU 算法的实现，多记录了「<strong>数据的访问频次</strong>」的信息（<font style="color:#DF2A3F;">是访问频次不是访问次数！！！</font>）。<br>Redis 对象的结构如下：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760854468519-f5cc7c5a-4549-4b63-ae0d-d1109e89c61e.png"></p>
<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis 可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长短，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt（Last Decrement Time），低 8bit 存储 logc（Logistic Counter）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760854505771-8999f755-382a-4261-9426-e1f99c6476df.png"></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">ldt 是用来记录 key 的访问时间戳；</font></li>
<li><strong>logc</strong><font style="color:rgb(44, 62, 80);"> 是用来记录 key 的</font><font style="color:#DF2A3F;">访问频次</font><font style="color:rgb(44, 62, 80);">，它的值越小表示使用频率越低，越容易淘汰。每个新加入的 key 的 logc 初始值为 5。  </font></li>
</ul>
<p><font style="color:#DF2A3F;">注意，logc 并不是单纯的访问次数，而是访问</font><strong><font style="color:#DF2A3F;">频次（访问频率）</font></strong><font style="color:#DF2A3F;">，因为 </font><strong><font style="color:#DF2A3F;">logc 会随时间推移而衰减</font></strong><font style="color:#DF2A3F;">。</font></p>
<p><font style="color:#000000;">在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关：<br></font><font style="color:#000000;">如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大。<br></font><font style="color:#000000;">这种实现的 LFU 算法是根据</font><strong><font style="color:#000000;">访问频率</font></strong><font style="color:#000000;">来淘汰数据的，而不只是访问次数。<br></font><font style="color:#000000;">访问频率需要考虑 key 的访问是多长时间段内发生的。<br></font><font style="color:#000000;">key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地就会降低，这样被淘汰的概率也会更大。</font></p>
<p><font style="color:#000000;">对 logc 做完衰减操作后，就开始对 logc 进行增加操作。<br></font><font style="color:#000000;">增加操作并不是单纯的 +1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</font></p>
<p><font style="color:#000000;">所以，Redis 在访问 key 时，对于 logc 是这样变化的：<br></font><font style="color:#000000;">1️⃣</font><font style="color:#000000;"> 先按照上次访问间隔当前的时长，来对 logc 进行衰减；<br></font><font style="color:#000000;">2️⃣</font><font style="color:#000000;"> 然后，再按照一定概率增加 logc 的值。</font></p>
<p><code>&lt;font style=&quot;color:#000000;&quot;&gt;redis.conf&lt;/font&gt;</code><font style="color:#000000;"> 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</font></p>
<ul>
<li><strong><font style="color:#000000;">lfu-decay-time</font></strong><font style="color:#000000;">：用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为 1；lfu-decay-time 越大，衰减越慢。</font></li>
<li><strong><font style="color:#000000;">lfu-log-factor</font></strong><font style="color:#000000;">：用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</font></li>
</ul>
<p><font style="color:#DF2A3F;">  </font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
