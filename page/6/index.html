<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="刘翰霖">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">刘翰霖</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/%E6%85%A2%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/%E6%85%A2%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">慢日志</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>MySQL提供了一个慢日志机制</p>
<p>SET GLOBAL slow_query_log &#x3D; ON;           – 开启慢日志</p>
<p>SET GLOBAL long_query_time &#x3D; 1;           – 超过 1 秒的记录</p>
<br/>

<p> 之后所有执行时间超过 1s 的 SQL 都会被写入 <code>slow_query.log</code>。  </p>
<h1 id="如何查看慢日志"><a href="#如何查看慢日志" class="headerlink" title="如何查看慢日志"></a>如何查看慢日志</h1><p>SHOW VARIABLES LIKE ‘slow_query_log’;</p>
<p>SHOW VARIABLES LIKE ‘long_query_time’;</p>
<br/>

<p><strong>先执行这个命令看看有没有打开慢日志</strong></p>
<p>结果示例</p>
<p>+———————+——-+</p>
<p>| Variable_name       | Value |</p>
<p>+———————+——-+</p>
<p>| slow_query_log      | ON    |</p>
<p>| long_query_time     | 1.000 |</p>
<p>+———————+——-+</p>
<br/>

<p> 🔸 <code>slow_query_log=ON</code> 表示已开启<br>🔸 <code>long_query_time=1</code> 表示执行时间超过 1 秒的 SQL 会被记录  </p>
<p><strong>然后执行SHOW VARIABLES LIKE ‘slow_query_log_file’查看慢日志的文件存放路径</strong></p>
<p>然后用pt-query-digest [慢日志文件名]  查看慢日志内容（运行pt-query-digest命令需安装工具）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/%E6%85%A2sql%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/%E6%85%A2sql%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">慢sql优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-查询慢sql"><a href="#一-查询慢sql" class="headerlink" title="一. 查询慢sql"></a>一. 查询慢sql</h2><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760780370624-4cfac036-21fa-4e6a-b24c-3e328e969e9f.png"></p>
<p>先开开启mysql 慢sql 查询的相关参数进行慢sql的语句 </p>
<h3 id="然后用explain-进行分析"><a href="#然后用explain-进行分析" class="headerlink" title="然后用explain 进行分析"></a>然后用explain 进行分析</h3><p>explain是查看sql的执行计划,主要用来分析sql 语句的执行过程，比如有没有走索引，有没有外部排序,有没有索引覆盖等</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760780590298-d1cc4087-1058-4ac4-8eb1-d3ad5da2ed0f.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760780605016-80cadc47-9c7e-4582-8289-629b5b9491b4.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760780624903-a2a9188b-7970-4d92-932f-2f56c6c90ae1.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760780632797-abf2fab8-ce3e-42de-b382-9b1259228a7c.png"></p>
<h2 id="二-优化慢sql"><a href="#二-优化慢sql" class="headerlink" title="二. 优化慢sql"></a>二. 优化慢sql</h2><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760780779321-c04d8982-4389-4d0a-ae91-d84ff408355d.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/mysql/" class="post-title-link" itemprop="url">mysql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>定义: 索引就像目录,可以帮助快速定位找到数据,同时维护索引也需要额外的空间,所以索引是一种空间换时间的方式</p>
<h4 id="聚簇索引与非聚簇索引的不同"><a href="#聚簇索引与非聚簇索引的不同" class="headerlink" title="聚簇索引与非聚簇索引的不同"></a>聚簇索引与非聚簇索引的不同</h4><p>聚簇索引中数据和索引是放到一起的找到了索引也就找到了数据</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1758192103494-bedc0fe8-ccd9-4c9e-86df-63bdedc28283.png"></p>
<p>非聚簇索引数据与索引分开存放,索引指向数据,所以找到索引还要再额外找一次才能找到是数据</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1758192179508-172062d2-036d-4fc3-834f-793af8912dae.png"></p>
<p>相比于非聚簇索引,聚簇索引的有点肯定是查找是速度更快,缺点是当更新索引的时候代价更大因为要移动整个数据</p>
<h3 id="为什么mysql-喜欢b-树"><a href="#为什么mysql-喜欢b-树" class="headerlink" title="为什么mysql 喜欢b+树"></a>为什么mysql 喜欢b+树</h3><ol>
<li>b+树相对于b树: b+树只有叶子节点存储数据,所以对于非叶子节点每次进行磁盘io 的时候b+树总能查询更多节点,效率更高,另外b+树的叶子节点用双链表链接,很适合进行顺序查找</li>
<li>b+树相对于二叉树: 二叉树的高度太高,磁盘io的次数更多效率十分低下</li>
<li>b+树相对与hash: hash 在做等值查询的时候效率很快是o(1)，但是hash 不能做范围查找,只能做等值查找</li>
</ol>
<h3 id="索引的优点和缺点"><a href="#索引的优点和缺点" class="headerlink" title="索引的优点和缺点"></a>索引的优点和缺点</h3><ol>
<li>优点:查找效率更快</li>
<li>缺点:缺点是维护索引需要成本,占用空间,同时删除更新索引也要进行维护</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/EXPLAIN_%E4%B8%8EEXPLAIN_ANALYZE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/EXPLAIN_%E4%B8%8EEXPLAIN_ANALYZE/" class="post-title-link" itemprop="url">EXPLAIN 与EXPLAIN ANALYZE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-Explain是什么"><a href="#一-Explain是什么" class="headerlink" title="一.Explain是什么"></a>一.Explain是什么</h1><p>EXPLAIN用来分析MySQL查询语句的执行计划，它不会真正的执行SQL，只会展示执行步骤，包括</p>
<ul>
<li>表的访问顺序（谁先谁后）</li>
<li>使用的索引</li>
<li>是否全表扫描</li>
<li>每一步大约扫描多少行</li>
</ul>
<h1 id="二-EXPLAIN输出字段解释"><a href="#二-EXPLAIN输出字段解释" class="headerlink" title="二.EXPLAIN输出字段解释"></a>二.EXPLAIN输出字段解释</h1><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>id</strong></td>
<td>查询中每个 <code>SELECT</code><br/> 的执行顺序标识</td>
<td>1, 2</td>
<td>id 越大优先级越高（先执行）</td>
</tr>
<tr>
<td><strong>select_type</strong></td>
<td>查询类型</td>
<td>SIMPLE, PRIMARY, SUBQUERY</td>
<td>表示是否是子查询、联合查询等</td>
</tr>
<tr>
<td><strong>table</strong></td>
<td>当前访问的表名</td>
<td>user, orders</td>
<td>MySQL 处理的具体表或临时表</td>
</tr>
<tr>
<td><strong>partitions</strong></td>
<td>表分区信息</td>
<td>NULL</td>
<td>通常不用关注</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>连接类型（访问方式）</td>
<td>index, range, ref, const, ALL</td>
<td><strong>最关键指标之一</strong>，越靠前性能越好</td>
</tr>
<tr>
<td><strong>possible_keys</strong></td>
<td>可能用到的索引</td>
<td>idx_age, idx_name</td>
<td>优化器考虑过的索引</td>
</tr>
<tr>
<td><strong>key</strong></td>
<td>实际使用的索引</td>
<td>idx_age</td>
<td>如果为 NULL 表示未使用索引</td>
</tr>
<tr>
<td><strong>key_len</strong></td>
<td>使用索引的字节长度</td>
<td>5</td>
<td>越短越精准越好</td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td>索引匹配的列或常量</td>
<td>const</td>
<td>用哪个列与索引匹配</td>
</tr>
<tr>
<td><strong>rows</strong></td>
<td>预计要扫描的行数</td>
<td>100</td>
<td>估算值（越小越好）</td>
</tr>
<tr>
<td><strong>filtered</strong></td>
<td>条件过滤比例</td>
<td>10</td>
<td>百分比，表示过滤后的行比例</td>
</tr>
<tr>
<td><strong>Extra</strong></td>
<td>额外信息</td>
<td>Using index, Using where, Using temporary</td>
<td>最能暴露性能问题的字段</td>
</tr>
</tbody></table>
<h1 id="三-EXPLAIN关键字段"><a href="#三-EXPLAIN关键字段" class="headerlink" title="三.EXPLAIN关键字段"></a>三.EXPLAIN关键字段</h1><h2 id="id-——-执行顺序"><a href="#id-——-执行顺序" class="headerlink" title="id —— 执行顺序"></a><code>id</code> —— 执行顺序</h2><ul>
<li>表示查询中每个 <code>SELECT</code> 的执行标识。</li>
<li>数字越大，执行优先级越高。</li>
</ul>
<p>例如:EXPLAIN SELECT * FROM user WHERE id IN (SELECT user_id FROM order);</p>
<br/>

<p>输出中会有两行：</p>
<ul>
<li>子查询的 <code>id</code> 更大，说明子查询先执行。</li>
</ul>
<h2 id="type-——-访问类型（最重要"><a href="#type-——-访问类型（最重要" class="headerlink" title="type —— 访问类型（最重要)"></a><code>type</code> —— 访问类型（最重要)</h2><p>表示MySQL如何查找表中的行， 这是 SQL 执行性能最直观的指标之一。  性能由好到查排序如下</p>
<table>
<thead>
<tr>
<th>type 值</th>
<th>含义</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>system</strong></td>
<td>只有一行数据的系统表</td>
<td>特殊情况，极快</td>
<td><code>SELECT * FROM dual;</code></td>
</tr>
<tr>
<td><strong>const</strong></td>
<td>通过主键或唯一索引精确匹配</td>
<td>只返回一行，常量级别</td>
<td><code>WHERE id = 1</code></td>
</tr>
<tr>
<td><strong>eq_ref</strong></td>
<td>联表时主键等值匹配</td>
<td>多表连接中，每次都只匹配一行</td>
<td><code>user.id = order.user_id</code><br/> 且 user_id 为主键</td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td>非唯一索引或前缀索引等值匹配</td>
<td>可能返回多行</td>
<td><code>WHERE name = &#39;Bob&#39;</code><br/> 且 name 有普通索引</td>
</tr>
<tr>
<td><strong>range</strong></td>
<td>索引范围扫描</td>
<td>范围条件查询</td>
<td><code>WHERE age &gt; 18</code><br/> 或 <code>BETWEEN</code></td>
</tr>
<tr>
<td><strong>index</strong></td>
<td>全索引扫描</td>
<td>扫描整个索引树，而非表</td>
<td>没WHERE但用到索引顺序，如 <code>ORDER BY name</code></td>
</tr>
<tr>
<td><strong>ALL</strong></td>
<td>全表扫描</td>
<td>没索引最慢</td>
<td><code>SELECT * FROM users</code></td>
</tr>
</tbody></table>
<h2 id="key-——-实际使用的索引"><a href="#key-——-实际使用的索引" class="headerlink" title="key —— 实际使用的索引"></a><code>key</code> —— 实际使用的索引</h2><ul>
<li>显示优化器真正选择的索引。</li>
<li>若为 <code>NULL</code> → 没有使用索引。</li>
<li>若不为空 → 表示命中索引。</li>
</ul>
<p>对比：</p>
<p>possible_keys: idx_name, idx_age<br>key: idx_age</p>
<br/>

<p>  说明优化器考虑了两个索引，但最终选择了 <code>idx_age</code>。  </p>
<h2 id="rows-——-预计扫描的行数"><a href="#rows-——-预计扫描的行数" class="headerlink" title="rows —— 预计扫描的行数"></a><code>rows</code> —— 预计扫描的行数</h2><ul>
<li>表示 MySQL 估计要扫描的记录数量。</li>
<li><strong>越小越好</strong>。</li>
<li>MySQL 会根据表的统计信息估算。</li>
</ul>
<h2 id="Extra-——-附加信息（隐藏性能陷阱）"><a href="#Extra-——-附加信息（隐藏性能陷阱）" class="headerlink" title="Extra —— 附加信息（隐藏性能陷阱）"></a><code>Extra</code> —— 附加信息（隐藏性能陷阱）</h2><p> 它描述了 <strong>MySQL 执行查询时的额外操作</strong>，也就是说：除了索引访问以外，MySQL 在执行过程中还“多做了什么”。 </p>
<h3 id="常见的Extra值详解"><a href="#常见的Extra值详解" class="headerlink" title="常见的Extra值详解"></a>常见的Extra值详解</h3><table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
<th>性能影响</th>
<th>说明&#x2F;场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Using index</strong></td>
<td>覆盖索引查询</td>
<td>✅ 优化很好</td>
<td>数据只从索引中获取，不访问表数据（不回表）</td>
</tr>
<tr>
<td><strong>Using where</strong></td>
<td>使用 WHERE 条件过滤</td>
<td>⚠️ 正常</td>
<td>表示 MySQL 还要额外判断 WHERE 条件</td>
</tr>
<tr>
<td><strong>Using temporary</strong></td>
<td>用了临时表</td>
<td>❌ 性能差</td>
<td>出现在 <code>GROUP BY</code><br/>、<code>DISTINCT</code><br/>、<code>UNION</code></td>
</tr>
<tr>
<td><strong>Using filesort</strong></td>
<td>用了文件排序</td>
<td>❌ 性能差</td>
<td>出现在 <code>ORDER BY</code><br/>，说明没用上索引排序</td>
</tr>
<tr>
<td><strong>Using index condition</strong></td>
<td>索引条件下推（ICP）</td>
<td>✅ 优化</td>
<td>MySQL 5.6+，减少回表次数</td>
</tr>
<tr>
<td><strong>Using join buffer</strong></td>
<td>联表时用了连接缓冲区</td>
<td>⚠️ 需优化</td>
<td>表示没用上索引连接</td>
</tr>
<tr>
<td><strong>Using MRR</strong></td>
<td>多范围读优化</td>
<td>✅ 改善随机 I&#x2F;O</td>
<td></td>
</tr>
<tr>
<td><strong>Using where; Using index</strong></td>
<td>同时过滤+覆盖索引</td>
<td>✅ 很好</td>
<td>用索引过滤并避免回表</td>
</tr>
<tr>
<td><strong>NULL</strong></td>
<td>没有额外操作</td>
<td>✅ 最理想</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Extra中的using-where-含义"><a href="#Extra中的using-where-含义" class="headerlink" title="Extra中的using where 含义"></a>Extra中的using where 含义</h3><p>extra中using where 并不是说SQL中出现了WHERE语句而是表示MySQL再执行时需要额外过滤</p>
<p>比如:</p>
<p>EXPLAIN select * from users where id&#x3D;2</p>
<br/>

<p>这个sql就不需要执行额外过滤，它检索到id&#x3D;2的数据就好了，所以Extra 就为null</p>
<p>EXPLAIN select * from users where id&gt;2</p>
<br/>

<p>这个sql当它检索到第一个id&gt;2的数据后还需要进行额外的过滤继续查找，所以Extra就是using where</p>
<p>_注意 : 即使 SQL 语句中没有写 <em><code>_WHERE_</code></em>，但如果 MySQL 必须检查行是否满足某个条件（比如 join 条件、HAVING、子查询匹配等），它仍然会显示 <em><code>_Using where_</code></em>。  _</p>
<h1 id="四-EXPLAIN-ANALYZE与EXPLAIN区别"><a href="#四-EXPLAIN-ANALYZE与EXPLAIN区别" class="headerlink" title="四.EXPLAIN ANALYZE与EXPLAIN区别"></a>四.EXPLAIN ANALYZE与EXPLAIN区别</h1><table>
<thead>
<tr>
<th>项目</th>
<th>EXPLAIN</th>
<th>EXPLAIN ANALYZE</th>
</tr>
</thead>
<tbody><tr>
<td><strong>是否执行 SQL</strong></td>
<td>❌ 不执行，只显示计划</td>
<td>✅ 真正执行并统计数据</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>预测执行计划（优化器预估）</td>
<td>实际执行报告（真实耗时与行数）</td>
</tr>
<tr>
<td><strong>输出内容</strong></td>
<td>访问方式、索引、预估行数等</td>
<td>每步的实际耗时、扫描行数、回表次数等</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>快速分析索引使用情况</td>
<td>精准定位性能瓶颈（排序&#x2F;回表&#x2F;连接）</td>
</tr>
</tbody></table>
<p><strong>一句话记忆：</strong></p>
<p><code>EXPLAIN</code> 看计划，<code>EXPLAIN ANALYZE</code> 看实战。</p>
<h1 id="五-根据EXPLAIN-ANALYZE分析过程"><a href="#五-根据EXPLAIN-ANALYZE分析过程" class="headerlink" title="五.根据EXPLAIN ANALYZE分析过程"></a>五.根据EXPLAIN ANALYZE分析过程</h1><p>假设执行SQL语句 </p>
<p>EXPLAIN ANALYZE SELECT * FROM users WHERE age &gt; 18 ORDER BY create_time DESC;</p>
<p>输出示例</p>
<p>-&gt; Sort: users.create_time desc  (cost&#x3D;100 rows&#x3D;100) (actual time&#x3D;0.1..2.3 rows&#x3D;95 loops&#x3D;1)</p>
<pre><code>-&gt; Filter: (users.age &gt; 18)  (cost=80 rows=100) (actual time=0.05..1.9 rows=95 loops=1)

    -&gt; Table scan on users  (cost=40 rows=1000) (actual time=0.03..1.7 rows=950 loops=1)
</code></pre>
<br/>

<h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头-&gt;"></a>箭头-&gt;</h2><p>表示<strong>执行顺序</strong>，最下层先执行。</p>
<ul>
<li>越靠右的行，执行得越“底层”；</li>
<li>越靠左的行，执行得越“外层”。</li>
</ul>
<h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><p>如：</p>
<ul>
<li><code>Table scan</code>：全表扫描</li>
<li><code>Index range scan</code>：范围索引扫描</li>
<li><code>Nested loop join</code>：嵌套循环连接</li>
<li><code>Sort</code> &#x2F; <code>Filter</code>：排序、过滤阶段</li>
</ul>
<h2 id="cost-xxx-rows-xxx"><a href="#cost-xxx-rows-xxx" class="headerlink" title="cost&#x3D;xxx rows&#x3D;xxx"></a>cost&#x3D;xxx rows&#x3D;xxx</h2><p>这是<strong>优化器预估值</strong>（plan 阶段产生的预测,预估值可能不准）。</p>
<ul>
<li><code>cost</code>：优化器计算的相对代价（非真实时间）</li>
<li><code>rows</code>：预估扫描的行数</li>
</ul>
<p>👉 用于比较预测 vs 实际是否偏差大。、</p>
<h2 id="actual-time-起始-结束"><a href="#actual-time-起始-结束" class="headerlink" title="actual time&#x3D;起始..结束"></a>actual time&#x3D;起始..结束</h2><p>这是<strong>实测耗时</strong>：</p>
<ul>
<li>单位：毫秒</li>
<li>第一个数是“开始时间”，第二个是“结束时间”<br>→ <code>0.1..2.3</code> 表示从开始到结束共执行 2.2ms</li>
</ul>
<h2 id="rows-xxx"><a href="#rows-xxx" class="headerlink" title="rows&#x3D;xxx"></a>rows&#x3D;xxx</h2><p> 这是<strong>真实返回行数</strong>（可能和预估不同）。<br>如果差距太大，说明优化器估算不准，可能索引统计信息老化。  </p>
<h2 id="loops-xxx"><a href="#loops-xxx" class="headerlink" title="loops&#x3D;xxx"></a>loops&#x3D;xxx</h2><p> 表示该操作执行了多少次。<br>典型在 <code>JOIN</code> 场景下很重要，比如：  </p>
<p>-&gt; Nested loop inner join  (actual time&#x3D;0.02..5.00 rows&#x3D;100 loops&#x3D;100)</p>
<p> 说明内层循环被执行了 100 次（可能是性能瓶颈）。  </p>
<h1 id="六-为什么建议先使用EXPLAIN再使用EXPLAIN-ANALYZE"><a href="#六-为什么建议先使用EXPLAIN再使用EXPLAIN-ANALYZE" class="headerlink" title="六.为什么建议先使用EXPLAIN再使用EXPLAIN ANALYZE"></a>六.为什么建议先使用EXPLAIN再使用EXPLAIN ANALYZE</h1><h2 id="两者定位不同"><a href="#两者定位不同" class="headerlink" title="两者定位不同"></a>两者定位不同</h2><table>
<thead>
<tr>
<th>命令</th>
<th>性质</th>
<th>是否执行SQL</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>EXPLAIN</strong></td>
<td>预估计划</td>
<td>❌ 不执行</td>
<td>安全查看执行路径、索引使用</td>
</tr>
<tr>
<td><strong>EXPLAIN ANALYZE</strong></td>
<td>实测报告</td>
<td>✅ 真执行SQL</td>
<td>精确测慢点、验证优化结果</td>
</tr>
</tbody></table>
<h2 id="为什么要“先-EXPLAIN-再-ANALYZE”"><a href="#为什么要“先-EXPLAIN-再-ANALYZE”" class="headerlink" title="为什么要“先 EXPLAIN 再 ANALYZE”"></a>为什么要“先 EXPLAIN 再 ANALYZE”</h2><h3 id="EXPLAIN-是安全预览"><a href="#EXPLAIN-是安全预览" class="headerlink" title="EXPLAIN 是安全预览"></a><code>EXPLAIN</code> 是安全预览</h3><ul>
<li>它**<font style="color:#DF2A3F;">不会真的执行 SQL</font>**，不会修改数据、不会扫描整表。</li>
<li>如果 SQL 写错或特别慢（比如误写 <code>SELECT * FROM big_table</code>），<br>用 <code>EXPLAIN ANALYZE</code> 会直接把数据库卡住。</li>
</ul>
<h3 id="EXPLAIN-ANALYZE-开销更大"><a href="#EXPLAIN-ANALYZE-开销更大" class="headerlink" title="EXPLAIN ANALYZE 开销更大"></a><code>EXPLAIN ANALYZE</code> 开销更大</h3><ul>
<li>它**<font style="color:#DF2A3F;">真的执行 SQL</font>**，要扫描数据、做排序、JOIN 等操作。</li>
<li>对大表来说，几秒、几十秒都可能。</li>
<li>如果 SQL 写错或是更新语句，可能直接改动生产数据 ⚠️</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/b%E6%A0%91%E5%92%8Cb+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/b%E6%A0%91%E5%92%8Cb+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">b树和b+树的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="b树"><a href="#b树" class="headerlink" title="b树"></a>b树</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1758193918187-d782046d-ef98-4f77-9a44-3e872c5c9df9.png"></p>
<p>关于m 阶b树的节点 最多有m个分支 最少有m的一半向上取整个分支(保证b树某个节点不会太稀疏)</p>
<h3 id="b-树"><a href="#b-树" class="headerlink" title="b+ 树"></a>b+ 树</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1758194591334-ed2f8243-a6a2-4f7f-b1a1-8891d9adae56.png"></p>
<p>b+树的特点就是叶子节点用一个链表连接起来 ,并且每个非叶子节点的值都是其下层节点的最大值</p>
<h3 id="b-树和b-的区别"><a href="#b-树和b-的区别" class="headerlink" title="b+树和b+的区别"></a>b+树和b+的区别</h3><p>可以很明显的看到b+树叶子节点包含着所有的数据的索引和指针,而b树每层节点都包含数据的索引和指针</p>
<p>所以b+树很适合顺序查找,b 树如果要进行顺序查找的话需要中序遍历,而b+树只需要定位到首元素然后通过链表进行顺序查找即可</p>
<p>b+ 树也很适合进行范围查找 比如说查找10-50内的元素,b+树先查找大于元素10的元素然后按链表顺序进行查找即可</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1758194659419-0a3d8aa5-7850-4b90-8b1c-b8777d92b180.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" class="post-title-link" itemprop="url">运行时数据区</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是运行时数据区？"><a href="#什么是运行时数据区？" class="headerlink" title="什么是运行时数据区？"></a>什么是运行时数据区？</h2><p> 当 Java 程序运行时，JVM 会在内存中划分出一块区域，用来管理执行所需的各种数据。<br>这块区域就叫 <strong>运行时数据区（Runtime Data Areas）</strong>。  </p>
<p>它包含了：</p>
<ul>
<li>程序计数器（Program Counter）</li>
<li>Java 虚拟机栈（JVM Stack）</li>
<li>本地方法栈（Native Method Stack）</li>
<li>堆（Heap）</li>
<li>方法区（Method Area &#x2F; 元空间 Metaspace）</li>
<li><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1762180009710-8f4cf25f-e7e7-4295-885c-0f620b6c2b6b.png"></li>
</ul>
<h1 id="区域详解"><a href="#区域详解" class="headerlink" title="区域详解"></a>区域详解</h1><h2 id="线程私有的"><a href="#线程私有的" class="headerlink" title="线程私有的"></a>线程私有的</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>程序计数器（PC Register）作用：<strong>用于记录</strong>下一条将要执行的指令位置</strong>。</p>
<ul>
<li><strong>CPU 的 PC 寄存器</strong>：指向<strong>下一条机器指令的内存地址</strong>。</li>
<li><strong>JVM 的程序计数器</strong>：指向<strong>下一条字节码指令的位置</strong>。</li>
</ul>
<p> 两者功能相同，但层级不同：CPU 的属于<strong>硬件层</strong>，JVM 的属于<strong>虚拟机软件层</strong>。  </p>
<h4 id="为什么cpu有pc-寄存器，jvm-还需要一个程序计数器呢"><a href="#为什么cpu有pc-寄存器，jvm-还需要一个程序计数器呢" class="headerlink" title="为什么cpu有pc 寄存器，jvm 还需要一个程序计数器呢"></a>为什么cpu有pc 寄存器，jvm 还需要一个程序计数器呢</h4><p>由于 <strong>JVM 字节码不能直接在 CPU 上执行</strong>，必须由 <strong>JVM 解释器或 JIT 编译器</strong> 翻译成机器码后再交给 CPU 执行。因此，JVM 需要<strong>模拟一套自己的指令执行环境</strong>，并在其中维护一个 <strong>程序计数器（PC）</strong>，用于记录<strong>当前线程下一条将要执行的字节码指令位置</strong>。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul>
<li><strong>Java 虚拟机栈</strong> 是 <strong>线程私有</strong> 的内存区域，用于<strong>方法调用和执行过程管理</strong>。</li>
<li><strong>每调用一个方法</strong>，JVM 都会创建一个 <strong>栈帧（Stack Frame）</strong> 压入当前线程的虚拟机栈中。</li>
<li>方法执行完毕后，该栈帧就会 <strong>弹出并销毁</strong>。</li>
<li><strong>局部变量（包括方法参数、临时变量）</strong> 都存放在这个栈帧里的 <strong>局部变量表（Local Variable Table）</strong> 中。</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><font style="color:rgb(60, 60, 67);">和虚拟机栈所发挥的作用非常相似，区别是：</font><strong><font style="color:rgb(60, 60, 67);">虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</font></strong></p>
<h2 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a><font style="color:rgb(60, 60, 67);">线程共享</font></h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>堆（Heap）</strong> 是 JVM 内存中<strong>最大</strong>的一块区域，<br>用于存放：</p>
<p>✅ <strong>所有对象实例（new 出来的）</strong><br>✅ <strong>数组（int[]、String[] 等）</strong></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h2 id="本地内存（线程共享）"><a href="#本地内存（线程共享）" class="headerlink" title="本地内存（线程共享）"></a>本地内存（线程共享）</h2><p><strong>本地内存（Native Memory）</strong> 不属于 JVM 管理的 <strong>堆或方法区</strong>，而是 JVM 通过底层 <strong>C&#x2F;C++ 代码</strong> 直接向操作系统申请的 <strong>堆外内存</strong>，其分配与释放由底层代码自行管理，<strong>不受 GC 控制</strong>。  </p>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p><strong>方法区（Method Area）</strong> 是 JVM 规范中定义的一块<strong>逻辑内存区域</strong>，<br>主要用于存储：</p>
<ul>
<li>✅ <strong>类的元信息</strong>（类名、父类、字段、方法等结构）</li>
<li>✅ <strong>静态变量</strong>（<code>static</code> 修饰的字段）</li>
<li>✅ <strong>常量</strong>（<code>final</code> 常量、运行时常量池）</li>
<li>✅ <strong>类字节码</strong>（字段、方法、接口的描述信息）</li>
</ul>
<p>📌 <strong>简单理解</strong>：</p>
<p>“堆放对象，方法区放类。”</p>
<p>当类首次被加载（如 <code>User.class</code>）时，JVM 会将它的结构信息存入方法区。</p>
<p>在 <strong>JDK 8 之后</strong>，HotSpot 虚拟机使用 <strong>元空间（Metaspace）</strong> 来实现方法区，并将其放置在 <strong>本地内存（Native Memory）</strong> 中，以替代早期的永久代（PermGen）。</p>
<p><em>方法区是jvm的概念，元空间就是具体的实现</em></p>
<h4 id="为什么元空间放在本地内存不放在堆中"><a href="#为什么元空间放在本地内存不放在堆中" class="headerlink" title="为什么元空间放在本地内存不放在堆中"></a>为什么元空间放在本地内存不放在堆中</h4><ol>
<li>将元空间放在堆外，使类元数据与普通对象解耦，内存调优时可以分别控制堆与元空间的大小，配置更加灵活，也更不容易因类加载导致整体 OOM。</li>
<li>堆中的对象涉及到频繁的gc，但类元数据本质上很稳定，生命周期长不适合放在堆中</li>
</ol>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存（Direct Memory）</strong> 是 JVM 通过 <strong>本地方法（C&#x2F;C++）在操作系统本地内存中分配</strong> 的一块内存区域，不属于 Java 堆，也不受 GC 管理。  </p>
<p>主要用于高性能I&#x2F;O操作（文件读写，网络通信等）</p>
<p><strong>工作原理（以写为例）</strong></p>
<p><strong>传统堆内I&#x2F;O</strong></p>
<p>[Java 堆 byte[]] → (复制) → [临时 native 缓冲区（用户缓冲区）] → (复制) → [内核缓冲区] → (DMA) → [网卡&#x2F;磁盘]</p>
<br/>

<p><strong>使用直接内存后</strong></p>
<p>[直接内存] → (复制) → [内核缓冲区] → (DMA) → [网卡&#x2F;磁盘]</p>
<br/>

<p> ！少了一次 “堆内 → 临时 native 缓冲区（用户缓冲区）” 的中间拷贝。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">类加载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是类加载？"><a href="#什么是类加载？" class="headerlink" title="什么是类加载？"></a>什么是类加载？</h1><p>当我们写好一个java 类，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个.java 	文件会被编译成.class 文件，而jvm不能直接读取.java文件，它要运行程序，就必须先把.class 文件里的字节码加载到内存中，并转换成jvm 能识别的结构，这整个过程就叫做类加载</p>
<h1 id="为什么需要多个类加载器？"><a href="#为什么需要多个类加载器？" class="headerlink" title="为什么需要多个类加载器？"></a>为什么需要多个类加载器？</h1><h3 id="1-隔离不同来源的类（核心原因）"><a href="#1-隔离不同来源的类（核心原因）" class="headerlink" title="1. 隔离不同来源的类（核心原因）"></a><strong>1. 隔离不同来源的类（核心原因）</strong></h3><p>在 JVM 中，一个类的真正身份由 <strong>“类加载器 + 全限定类名”</strong> 决定，而不是单独由类名决定。</p>
<p>也就是说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoaderA + com.example.User  → 类 X</span><br><span class="line">ClassLoaderB + com.example.User  → 类 Y</span><br></pre></td></tr></table></figure>

<p>虽然类名完全一样，但 JVM 会认为它们是两个不同的类。</p>
<p><strong>为什么要这样设计？</strong></p>
<ul>
<li><strong>避免命名冲突：</strong> 不同模块&#x2F;应用可以拥有同名类而互不干扰（比如 Tomcat 的不同 WebApp）。</li>
<li><strong>保证安全性：</strong> 核心类必须由系统级加载器加载，防止用户伪造同名的 <code>java.lang.String</code> 等关键类。</li>
<li><strong>实现模块隔离：</strong> 每个 ClassLoader 都有独立的命名空间，互相不影响。</li>
</ul>
<h3 id="2-让我们在”加载类”的时候加入自定义逻辑"><a href="#2-让我们在”加载类”的时候加入自定义逻辑" class="headerlink" title="2.让我们在”加载类”的时候加入自定义逻辑"></a>2.让我们在”加载类”的时候加入自定义逻辑</h3><p>比如加载加密类，网络类等</p>
<h1 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h1><p><strong>继承ClassLoader,重写findClass（不打破双亲委派机制）</strong></p>
<p>经典步骤：</p>
<ol>
<li>**继承 **<code>**ClassLoader**</code></li>
<li>**提供一个构造方法（可指定 parent），构造方法只要用于指定父加载器，默认系统类加载器（System ClassLoader） 作为父加载器。  **</li>
<li>**重写 **<code>**findClass(String name)**</code><ul>
<li>**把类名 <strong><code>**com.example.Hello**</code></strong> → 换成路径 **<code>**com/example/Hello.class**</code></li>
<li><strong>根据你的规则去读字节：</strong><code>**byte[] bytes = loadClassData(name);**</code></li>
<li>**调用 **<code>**defineClass(name, bytes, 0, bytes.length)**</code></li>
</ul>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">    // 比如从这个目录下找 class 文件</span></span><br><span class="line"><span class="code">    private final String classPath;</span></span><br><span class="line"><span class="code">    //自定义父类加载器，默认系统类加载器（System ClassLoader） 作为父加载器。</span></span><br><span class="line"><span class="code">    public MyClassLoader(String classPath) &#123;</span></span><br><span class="line"><span class="code">        // 使用系统类加载器做 parent（也可以改成别的）</span></span><br><span class="line"><span class="code">        super(MyClassLoader.class.getClassLoader());</span></span><br><span class="line"><span class="code">        this.classPath = classPath;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    @Override</span></span><br><span class="line"><span class="code">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line"><span class="code">        // 1. 把类名转成文件路径，比如 com.example.Hello -&gt; com/example/Hello.class</span></span><br><span class="line"><span class="code">        String fileName = name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 2. TODO: 在这里实现从 classPath + fileName 读取字节</span></span><br><span class="line"><span class="code">        byte[] classBytes = loadClassBytes(fileName);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        if (classBytes == null || classBytes.length == 0) &#123;</span></span><br><span class="line"><span class="code">            throw new ClassNotFoundException(name);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 3. 交给 JVM，把字节变成 Class 对象</span></span><br><span class="line"><span class="code">        return defineClass(name, classBytes, 0, classBytes.length);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 具体怎么读文件交给你实现 😊</span></span><br><span class="line"><span class="code">    private byte[] loadClassBytes(String fileName) &#123;</span></span><br><span class="line"><span class="code">        // TODO: 使用 FileInputStream / Files.readAllBytes 等读入字节</span></span><br><span class="line"><span class="code">        return null;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在自定义类加载器时：</p>
<ul>
<li><strong>只重写 <strong><code>**findClass()**</code></strong> 不会破坏双亲委派模型</strong><br>因为真正负责加载流程的是 <code>loadClass()</code>，它的默认实现仍然会先把加载任务交给父类加载器，只有父加载器无法加载时才回调 <code>findClass()</code>。</li>
<li><strong>重写 <strong><code>**loadClass()**</code></strong> 才能真正打破双亲委派</strong><br>因为你可以在 <code>loadClass()</code> 中自行决定：<ul>
<li>是先自己加载</li>
<li>还是先交给父加载器</li>
<li>或者按某种规则分别处理</li>
</ul>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    // 第 1 步：检查缓存，是否已经加载过</span></span><br><span class="line"><span class="code">    Class&lt;?&gt; c = findLoadedClass(name);</span></span><br><span class="line"><span class="code">    if (c == null) &#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        try &#123;</span></span><br><span class="line"><span class="code">            // 第 2 步：先让父加载器尝试加载（双亲委派）</span></span><br><span class="line"><span class="code">            c = getParent().loadClass(name);</span></span><br><span class="line"><span class="code">        &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="code">            // 第 3 步：父加载器不行 → 由当前加载器自己加载</span></span><br><span class="line"><span class="code">            c = findClass(name);   // ★ 重要：这里调用 findClass</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // 第 4 步：是否要解析</span></span><br><span class="line"><span class="code">    if (resolve) &#123;</span></span><br><span class="line"><span class="code">        resolveClass(c);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    return c;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760794761056-a95c62d3-a4fa-44ef-a19f-e007010837fc.png"></p>
<p>类从被加载到jvm开始，到卸载出内存，整个声明周期分为起个阶段，<font style="color:rgb(44, 62, 80);">分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。</font></p>
<p><font style="color:rgb(44, 62, 80);">除去使用和卸载，就是 Java 的类加载过程。这 5 个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后（我们随后来解释）。</font></p>
<ol>
<li>loading（载入）</li>
</ol>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="为什么会有双亲委派？"><a href="#为什么会有双亲委派？" class="headerlink" title="为什么会有双亲委派？"></a>为什么会有双亲委派？</h3><p>在JVM中有多个类加载器,Bootstrap（启动类加载器），Platform（拓展类加载器）…，问题是这些加载器都有能力加载类，所以当一个类被请求加载的时候，应该由谁来负责？所以由双亲委派机制来协调</p>
<p><strong>所以双亲委派机制就是当类加载器加载类的时候会先去问它们的父类能不能加载，如果父类不能加载的话会抛出异常然后这个类才会加载</strong></p>
<h3 id="为什么类加载器不直接自己加载，而要让父加载器先试一试？"><a href="#为什么类加载器不直接自己加载，而要让父加载器先试一试？" class="headerlink" title="为什么类加载器不直接自己加载，而要让父加载器先试一试？"></a>为什么类加载器不直接自己加载，而要让父加载器先试一试？</h3><p> 假设我们自己写了一个类加载器，它去加载 <code>java.lang.String</code> 这个类。  但是它的父加载器已经加载过这个类了， 那这样的话，这个加载器会重新加载一份新的 <code>String.class</code> 进内存。  系统里现在就会有两份不同的 <code>String</code> 类，虽然名字一样，但它们是由不同加载器加载的。<br>在 JVM 看来，它们就是两个完全不同的类型，互相不能转换，会导致类型混乱甚至安全问题。  、</p>
<p>所以 JVM 规定：</p>
<p>当某个加载器要加载一个类时，它必须<strong>先让父加载器尝试</strong>，<br>父加载器如果能加载，就直接使用父的结果；<br>如果父亲说“我也没有这个类”，那你再自己加载。</p>
<p>这样就能保证：</p>
<ul>
<li><code>java.lang.String</code>、<code>Object</code> 这些核心类只会被系统加载器（Bootstrap）加载；</li>
<li>你的应用层加载器不会“冒充”系统类；</li>
<li>类的唯一性与安全性都得到了保证。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Java/jvm/%E6%97%A0%E6%A0%87%E9%A2%98%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Java/jvm/%E6%97%A0%E6%A0%87%E9%A2%98%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">无标题文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Java/jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Java/jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/" class="post-title-link" itemprop="url">常量池，运行时常量池和字符串常量池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、常量池（Constant-Pool）——静态的“字典”"><a href="#一、常量池（Constant-Pool）——静态的“字典”" class="headerlink" title="一、常量池（Constant Pool）——静态的“字典”"></a>一、常量池（Constant Pool）——静态的“字典”</h2><p>📍位置：每个 <code>.class</code> 文件里<br>📍作用：保存<strong>编译时</strong>就确定的各种“常量信息”</p>
<p>比如你写了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译成 <code>.class</code> 文件时，编译器会把这几个东西放进常量池：</p>
<ul>
<li><code>&quot;hello world&quot;</code> 这个字符串字面量</li>
<li><code>System.out</code> 这个字段的引用</li>
<li><code>println()</code> 这个方法的符号引用</li>
<li>类名 <code>Hello</code>、<code>java/lang/Object</code>、<code>java/lang/System</code> 等</li>
</ul>
<p>这些统统放进 <code>.class</code> 文件的 <strong>常量池表</strong>。</p>
<p>🧠 你可以把它想成一本“查字典”，记录了：</p>
<p>类中所有可能用到的常量、类名、方法名、字段名、描述符等。</p>
<p>它还不是内存里的对象，只是静态的数据表。</p>
<hr>
<h2 id="二、运行时常量池（Runtime-Constant-Pool）——内存里的副本"><a href="#二、运行时常量池（Runtime-Constant-Pool）——内存里的副本" class="headerlink" title="二、运行时常量池（Runtime Constant Pool）——内存里的副本"></a>二、运行时常量池（Runtime Constant Pool）——内存里的副本</h2><p>📍位置：在 <strong>方法区（method area）</strong> 中<br>📍作用：把 <code>.class</code> 文件里的常量池加载进内存，并把“符号引用”变成“真实引用”。</p>
<p>当 JVM 运行你的程序时，会把 <code>.class</code> 文件中的常量池<strong>加载进内存</strong>，<br>并创建一个“运行时常量池”，比如：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>常量池中是什么</th>
<th>运行时常量池变成什么</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;hello world&quot;</code></td>
<td>字面量符号</td>
<td>堆中字符串对象的引用</td>
</tr>
<tr>
<td><code>System.out</code></td>
<td>字段符号引用</td>
<td>指向真实的静态字段</td>
</tr>
<tr>
<td><code>println()</code></td>
<td>方法符号引用</td>
<td>指向真实方法地址</td>
</tr>
</tbody></table>
<p>✅ 也就是说：</p>
<p>“常量池”只是 <code>.class</code> 文件的原始数据，<br>“运行时常量池”才是 JVM 真正在运行时使用的东西。</p>
<h2 id="符号引用和和直接引用的区别"><a href="#符号引用和和直接引用的区别" class="headerlink" title="符号引用和和直接引用的区别"></a>符号引用和和直接引用的区别</h2><h3 id="直觉理解：符号引用-≠-真实地址"><a href="#直觉理解：符号引用-≠-真实地址" class="headerlink" title="直觉理解：符号引用 ≠ 真实地址"></a>直觉理解：符号引用 ≠ 真实地址</h3><p>我们先打个比方👇</p>
<p>假设你在 <code>.class</code> 文件里写了这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>这行代码在 <code>.class</code> 文件的常量池里，会记录为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Methodref #4.#5  // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<p>这里的：</p>
<ul>
<li><code>&quot;java/io/PrintStream&quot;</code> 是一个字符串</li>
<li><code>&quot;println&quot;</code> 也是字符串</li>
<li><code>&quot;(Ljava/lang/String;)V&quot;</code> 是方法描述符（代表“参数是 String，返回值是 void”）</li>
</ul>
<p>这些东西——<strong>都不是内存地址</strong>，只是名字、路径、描述。<br>它们告诉 JVM：“我要调用一个叫 <code>java/io/PrintStream.println</code> 的方法”。</p>
<p>这就叫：</p>
<p><strong>符号引用（Symbolic Reference）</strong><br>是一种用<strong>字符串、名字或符号</strong>表示类、字段、方法的“引用”，<br>而不是内存中的真实地址。</p>
<h3 id="符号引用到直接引用的转变（解析阶段发生）"><a href="#符号引用到直接引用的转变（解析阶段发生）" class="headerlink" title="符号引用到直接引用的转变（解析阶段发生）"></a>符号引用到直接引用的转变（解析阶段发生）</h3><p>当类被加载到内存后，JVM 会在“解析阶段”把这些符号引用变成真正的“内存地址”，也就是：</p>
<p><strong>直接引用（Direct Reference）</strong></p>
<p>举个例子👇</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>引用类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>.class</code><br/> 文件</td>
<td>符号引用</td>
<td><code>&quot;java/io/PrintStream.println:(Ljava/lang/String;)V&quot;</code></td>
</tr>
<tr>
<td>运行时内存</td>
<td>直接引用</td>
<td>指向真正的 <code>println()</code><br/> 方法在内存中的地址</td>
</tr>
</tbody></table>
<hr>
<h3 id="符号引用都有哪些？"><a href="#符号引用都有哪些？" class="headerlink" title="符号引用都有哪些？"></a>符号引用都有哪些？</h3><p>JVM 规范规定，符号引用主要有三类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>举例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>类或接口的符号引用</td>
<td><code>&quot;java/lang/String&quot;</code></td>
<td>告诉 JVM 我依赖哪个类</td>
</tr>
<tr>
<td>字段的符号引用</td>
<td><code>&quot;System.out:Ljava/io/PrintStream;&quot;</code></td>
<td>告诉 JVM 需要访问哪个字段</td>
</tr>
<tr>
<td>方法的符号引用</td>
<td><code>&quot;println:(Ljava/lang/String;)V&quot;</code></td>
<td>告诉 JVM 需要调用哪个方法</td>
</tr>
</tbody></table>
<p>这些在 <code>.class</code> 文件的常量池里都有编号，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#4 = Methodref #10.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="用一句话总结："><a href="#用一句话总结：" class="headerlink" title="用一句话总结："></a>用一句话总结：</h3><p><strong>符号引用</strong>：类文件中的“名字引用”，编译期生成，用来描述依赖关系。<br><strong>直接引用</strong>：运行期真正的内存地址或偏移量，用来让 JVM 真正访问对象、字段或方法。</p>
<h2 id="三、字符串常量池（String-Constant-Pool）——专为字符串优化"><a href="#三、字符串常量池（String-Constant-Pool）——专为字符串优化" class="headerlink" title="三、字符串常量池（String Constant Pool）——专为字符串优化"></a>三、字符串常量池（String Constant Pool）——专为字符串优化</h2><p>位置：堆<br>作用：存放程序中出现的所有字符串字面量（”abc”、”user” 等），<strong>避免重复创建字符串对象</strong></p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;hello&quot;;</span><br><span class="line">String s2 = &quot;hello&quot;;</span><br><span class="line">System.out.println(s1 == s2); // true</span><br></pre></td></tr></table></figure>

<p>为什么 <code>true</code>？<br>因为 <code>&quot;hello&quot;</code> 这个字符串在字符串常量池中只会有一个对象。</p>
<ul>
<li>第一次遇到 <code>&quot;hello&quot;</code> → 放入字符串常量池（堆中）</li>
<li>第二次再遇到 <code>&quot;hello&quot;</code> → JVM 检查池里已经有了，直接复用引用</li>
</ul>
<p>🧠 注意：</p>
<p>运行时常量池里存的是字符串对象的“引用”，<br>真正的字符串对象存在 <strong>字符串常量池（堆中）</strong>。</p>
<hr>
<h2 id="四、三者关系图（重点记忆）"><a href="#四、三者关系图（重点记忆）" class="headerlink" title="四、三者关系图（重点记忆）"></a>四、三者关系图（重点记忆）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────────┐</span><br><span class="line">│ .class 文件                  │</span><br><span class="line">│  └─ 常量池（符号引用）       │</span><br><span class="line">└──────────────────────────────┘</span><br><span class="line">              ↓  加载</span><br><span class="line">┌──────────────────────────────┐</span><br><span class="line">│ 方法区 (JDK7以前是永久代)     │</span><br><span class="line">│  └─ 运行时常量池（引用表）    │</span><br><span class="line">└──────────────────────────────┘</span><br><span class="line">              ↓  引用指向</span><br><span class="line">┌──────────────────────────────┐</span><br><span class="line">│ 堆内存                        │</span><br><span class="line">│  └─ 字符串常量池（StringTable）│</span><br><span class="line">│       存真正的 String 对象     │</span><br><span class="line">└──────────────────────────────┘</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、总结表"><a href="#五、总结表" class="headerlink" title="五、总结表"></a>五、总结表</h2><table>
<thead>
<tr>
<th>概念</th>
<th>阶段</th>
<th>位置</th>
<th>内容</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>常量池</td>
<td>编译时</td>
<td><code>.class</code><br/> 文件</td>
<td>符号引用</td>
<td><code>&quot;hello&quot;</code><br/>, 方法名等</td>
</tr>
<tr>
<td>运行时常量池</td>
<td>运行时</td>
<td>方法区</td>
<td>已解析的引用</td>
<td>指向堆对象的指针</td>
</tr>
<tr>
<td>字符串常量池</td>
<td>运行时</td>
<td>堆中</td>
<td>字符串对象</td>
<td><code>&quot;hello&quot;</code><br/> 对象本身</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
