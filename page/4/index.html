<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="刘翰霖">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">刘翰霖</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">哈希表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>redis 中的hash表数据结构就是一个正常的哈希表采用<strong>链式哈希</strong>来解决哈希冲突</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539193121-5c42e9fe-e3e5-4db4-a7f2-ba3afe433d1c.png">如图dictht 指向一个哈希表的数组,数组中每个元素都是一个哈希表节点的链表</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>redis的哈希表有一个 特点就是一个哈希表结构体中定义了两个哈希表，<font style="color:rgb(44, 62, 80);">之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539292770-805ea47d-cbd6-4894-9afe-272a166d6f28.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539328496-c26f66ec-9eca-4646-a7ab-6fac98d90ad1.png"></p>
<h3 id="渐进式hash"><a href="#渐进式hash" class="headerlink" title="渐进式hash"></a>渐进式hash</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539601585-aa657ad0-eca8-41a2-81d6-d9e289855d27.png"></p>
<h3 id="rehash的触发条件"><a href="#rehash的触发条件" class="headerlink" title="rehash的触发条件"></a>rehash的触发条件</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539624416-d50fac17-c054-44b3-a616-ec241a4307a7.png"></p>
<p><strong><font style="color:rgb(48, 79, 254);"></font></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/ZSET/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/ZSET/" class="post-title-link" itemprop="url">ZSET</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-什么是zset"><a href="#一-什么是zset" class="headerlink" title="一.什么是zset"></a>一.什么是zset</h1><p> Redis 中的 **ZSet（Sorted Set，有序集合） ,它在集合（Set）的基础上，为每个元素关联了一个 score（分数），并且所有元素会根据这个分数自动 从小到大排序。  **</p>
<p>** 非常适合用来做排行榜、延时队列、优先级任务、推荐系统等场景。  **</p>
<h1 id="二-zset的常用命令"><a href="#二-zset的常用命令" class="headerlink" title="二.zset的常用命令"></a>二.zset的常用命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member [score member ...]</code></td>
<td>添加元素及其分数</td>
<td><code>ZADD rank 100 user1 90 user2</code></td>
</tr>
<tr>
<td><code>ZRANGE key start stop [WITHSCORES]</code></td>
<td>按排名升序取值</td>
<td><code>ZRANGE rank 0 2 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZREVRANGE key start stop [WITHSCORES]</code></td>
<td>按排名降序取值</td>
<td><code>ZREVRANGE rank 0 2 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>查询指定成员的分数</td>
<td><code>ZSCORE rank user1</code></td>
</tr>
<tr>
<td><code>ZINCRBY key increment member</code></td>
<td>增加某个成员的分数</td>
<td><code>ZINCRBY rank 10 user1</code></td>
</tr>
<tr>
<td><code>ZREM key member [member ...]</code></td>
<td>删除元素</td>
<td><code>ZREM rank user2</code></td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取集合中元素个数</td>
<td><code>ZCARD rank</code></td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>获取成员的升序排名</td>
<td><code>ZRANK rank user1</code></td>
</tr>
<tr>
<td><code>ZREVRANK key member</code></td>
<td>获取成员的降序排名</td>
<td><code>ZREVRANK rank user1</code></td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></td>
<td>按分数范围取值</td>
<td><code>ZRANGEBYSCORE rank 50 100 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZREMrangeByScore key min max</code></td>
<td>删除某个分数区间的成员</td>
<td><code>ZREMRANGEBYSCORE rank 0 50</code></td>
</tr>
</tbody></table>
<p>三.zset的底层数据结构</p>
<p><strong>ZSet 底层使用跳表（SkipList）实现，而不是平衡树。</strong><br>跳表通过多层索引结构实现平均 O(log n) 的查找效率，与平衡树相同，但结构更简单、插入删除更高效。  </p>
<h2 id="redis-中zset为什么使用跳表而不是平衡树"><a href="#redis-中zset为什么使用跳表而不是平衡树" class="headerlink" title="redis 中zset为什么使用跳表而不是平衡树"></a>redis 中zset为什么使用跳表而不是平衡树</h2><ol>
<li>从内存角度看，跳表比平衡树更省空间：跳表节点平均仅需约两个指针（前后），而平衡树节点通常要维护三个指针（左、右、父）  </li>
<li>跳表底层是<strong>有序链表</strong>，范围查询可从起点一路向后遍历，<br>复杂度 O(log n + k)，实现简单；平衡树则需进行<strong>中序遍历</strong>。</li>
<li><strong>实现更简单、维护成本低</strong>：跳表更新删除只需要变动指针即可；平衡树必须通过<strong>旋转操作</strong>维持结构平衡，逻辑繁琐、实现复杂。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/ZipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/ZipList/" class="post-title-link" itemprop="url">ZipList</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">压缩列表</font></strong></a><strong><font style="color:rgb(25, 27, 31);">（</font></strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=ziplist&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">ziplist</font></strong></a><strong><font style="color:rgb(25, 27, 31);">）本质上就是一个字节数组，是</font></strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=Redis&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">Redis</font></strong></a><strong><font style="color:rgb(25, 27, 31);">为了节约内存而设计的一种线性数据结构</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760537667649-decf9823-34b3-449a-997e-315d61f152ec.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760537684492-157cd6b7-4198-4169-8ffb-7d15c239aada.png"></p>
<p><strong><font style="color:rgb(25, 27, 31);">而压缩列表节点又有三个属性组成，分别是previous_entry_length，encoding，content</font></strong><font style="color:rgb(25, 27, 31);">。</font></p>
<ol>
<li><strong><font style="color:rgb(25, 27, 31);">previous_entry_length</font></strong></li>
</ol>
<p><font style="color:rgb(25, 27, 31);">这个属性记录了压缩列表前一个节点的长度，用于实现“链表的向前查找”</font></p>
<p><font style="color:rgb(25, 27, 31);">这个属性记录了压缩列表前一个节点的长度，</font><strong><font style="color:rgb(25, 27, 31);">该属性根据前一个节点的大小不同可以是1个字节或者5个字节。</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">如果前一个节点的长度小于254个字节，那么previous_entry_length的大小为1个字节，</font><strong><font style="color:rgb(25, 27, 31);">即前一个节点的长度可以使用1个字节表示</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">如果前一个节点的长度大于等于254个字节，那么previous_entry_length的大小为5个字节</font><strong><font style="color:rgb(25, 27, 31);">，第一个字节会被设置为0xFE(十进制的254），之后的四个字节则用于保存前一个节点的长度。</font></strong></p>
<ol start="2">
<li><strong><font style="color:rgb(25, 27, 31);">encoding</font></strong></li>
</ol>
<p><strong>当前节点的数据类型与长度编码信息</strong><strong><font style="color:rgb(25, 27, 31);">。  </font></strong></p>
<p>它的作用是告诉 Redis：</p>
<p><strong><font style="color:rgb(25, 27, 31);">“当前节点的内容（content）是字符串还是整数？如果是字符串，它的长度是多少？如果是整数，是哪种整数类型？”</font></strong></p>
<ol start="3">
<li><strong><font style="color:rgb(25, 27, 31);">content</font></strong></li>
</ol>
<p><strong><font style="color:rgb(25, 27, 31);">content属性负责保存节点的值，值的具体类型由上一个字段encoding来决定。</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760538093497-b652385b-6c44-454b-a413-24fbd791ee9b.png"></p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p><strong><font style="color:rgb(25, 27, 31);">当添加或删除节点时，可能就会因为previous_entry_length的变化导致发生连锁的更新操作。</font></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/redis_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/redis_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">redis 线程模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>主线程：唯一负责命令解析&#x2F;执行、数据结构操作、事件循环调度、AOF&#x2F;RDB 触发等“核心逻辑”。（也就是真正执行读写操作的线程）</li>
<li>网络io线程，多个网络io线程处理网络io</li>
<li>BIO 线程池（处理慢io的线程池）：固定几个后台线程处理慢 IO（aof fsync、close&#x2F;open、lazy-free 等），避免主线程被阻塞。比如说当写回策略是Everysec 的时候就由慢io线程池调用fsync 方法将AOF内核缓冲区刷新到磁盘中</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/redis_%E5%A4%A7key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/redis_%E5%A4%A7key/" class="post-title-link" itemprop="url">redis 大key</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis-的大key-会引发什么问题"><a href="#redis-的大key-会引发什么问题" class="headerlink" title="redis 的大key 会引发什么问题"></a>redis 的大key 会引发什么问题</h1><h2 id="大key-对AOF的影响"><a href="#大key-对AOF的影响" class="headerlink" title="大key 对AOF的影响"></a>大key 对AOF的影响</h2><ol>
<li>如果使用always写回策略，那么由主线程同步调用fsync（）方法，对于大key的写入很耗时，会造成阻塞</li>
<li>如果是Everysec或no 策略则不会影响主线程，因为Everysec 由慢IO线程池异步调用fsync，no策略是由OS自主调用fsync</li>
</ol>
<h2 id="大Key对AOF重写和RDB的影响"><a href="#大Key对AOF重写和RDB的影响" class="headerlink" title="大Key对AOF重写和RDB的影响"></a>大Key对AOF重写和RDB的影响</h2><h3 id="容易触发AOF重写-当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写"><a href="#容易触发AOF重写-当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写" class="headerlink" title="容易触发AOF重写:当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写"></a><font style="color:#DF2A3F;">容易触发AOF重写:</font>当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写</h3><h3 id="创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；"><a href="#创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；" class="headerlink" title="创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；"></a><font style="color:rgb(44, 62, 80);">创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</font></h3><p>Redis 在执行 AOF 重写或 RDB 快照时需要 <code>fork()</code> 创建子进程。<code>fork()</code> 会将父进程的整张页表复制一份给子进程，因此当实例中存在大量大 key、占用内存页很多时，页表规模会变得很大，导致页表复制过程耗时严重，从而使 <code>fork()</code> 阻塞主线程。</p>
<p>例如你用一个 <strong>大 key</strong> 存了 500MB 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET bigkey &lt;500MB value&gt;</span><br></pre></td></tr></table></figure>

<p>那么 Redis 进程就会多出 <strong>500MB 内存占用</strong>。</p>
<p>而操作系统管理内存的单位是 <strong>页（page）</strong>，一般是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 页 = 4KB</span><br></pre></td></tr></table></figure>

<p>那么 500MB 大概需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500MB / 4KB ≈ 128,000 个页</span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<p>Redis 必须创建 <strong>128,000 个页表项</strong> 来记录这些映射关系。</p>
<p>因此：</p>
<p><strong>大 Key 必然导致页表变大，因为大 Key 占用更多内存页，而每一个页都要一个页表项。</strong></p>
<h3 id="创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长"><a href="#创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长" class="headerlink" title="创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长"></a><font style="color:rgb(44, 62, 80);">创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长</font></h3><h2 id="大key-除了影响持久化外，还会有一下影响"><a href="#大key-除了影响持久化外，还会有一下影响" class="headerlink" title="大key 除了影响持久化外，还会有一下影响"></a>大key 除了影响持久化外，还会有一下影响</h2><ol>
<li><font style="color:rgb(44, 62, 80);">客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</font></li>
<li><font style="color:rgb(44, 62, 80);">引发网络阻塞。每次获取大 key 产生的网络流量较大，引发网络阻塞。每次获取大 key 产生的网络流量较大，这对于普通千兆网卡的服务器来说是灾难性的。</font></li>
<li><font style="color:rgb(44, 62, 80);">使用del删除大 key 时，会阻塞工作线程（建议使用unlink 命令删除大key）</font></li>
</ol>
<h1 id="如何避免大key呢"><a href="#如何避免大key呢" class="headerlink" title="如何避免大key呢"></a><font style="color:rgb(44, 62, 80);">如何避免大key呢</font></h1><ol>
<li>在设计阶段，尽量把大key 拆成很多小key</li>
<li>不要使用del命令删除大key，该命令会阻塞主线程，使用unlink（redis4.0）命令删除（ 主线程只负责将 key 从字典中移除，不会阻塞  ，真正的内存释放由后台慢IO线程池完成）</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/redis_%E4%B8%AD%E7%9A%84LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/redis_%E4%B8%AD%E7%9A%84LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">redis 中的LRU和LFU算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>LRU算法全称是Latest Recently Used 最近最少使用，最选择淘汰最近最少使用的数据</p>
<h3 id="传统LRU的实现"><a href="#传统LRU的实现" class="headerlink" title="传统LRU的实现"></a>传统LRU的实现</h3><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<h3 id="redis-如何实现LRU"><a href="#redis-如何实现LRU" class="headerlink" title="redis 如何实现LRU"></a>redis 如何实现LRU</h3><p>redis 实现的是一种近似的LRU算法，目的是为了更好的节约内存，它的实现方式是在Redis的对象结构体中添加一个额外的字段，用于记录数据的最后一次访问时间</p>
<p>当Redis 进行内存淘汰的时候，会使用<strong>随机采样</strong>的方法来淘汰数据，就是随机取5个值（此值可配），然后淘汰最久没有使用的那个</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p>
<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>LFU 全称是 Least Frequently Used，翻译为<strong>最近最不常用</strong>。<br>LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是：“如果数据过去被访问得多次，那么将来被访问的频率也更高。”</p>
<p> 所以，LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据仍然在缓存中长期占用的问题。**所以作为缓存数据库，相比于 LRU 算法，LFU 算法更加合理。 ** </p>
<h3 id="redisLFU的实现"><a href="#redisLFU的实现" class="headerlink" title="redisLFU的实现"></a>redisLFU的实现</h3><p> LFU 算法相对于 LRU 算法的实现，多记录了「<strong>数据的访问频次</strong>」的信息（<font style="color:#DF2A3F;">是访问频次不是访问次数！！！</font>）。<br>Redis 对象的结构如下：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760854468519-f5cc7c5a-4549-4b63-ae0d-d1109e89c61e.png"></p>
<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis 可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长短，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt（Last Decrement Time），低 8bit 存储 logc（Logistic Counter）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760854505771-8999f755-382a-4261-9426-e1f99c6476df.png"></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">ldt 是用来记录 key 的访问时间戳；</font></li>
<li><strong>logc</strong><font style="color:rgb(44, 62, 80);"> 是用来记录 key 的</font><font style="color:#DF2A3F;">访问频次</font><font style="color:rgb(44, 62, 80);">，它的值越小表示使用频率越低，越容易淘汰。每个新加入的 key 的 logc 初始值为 5。  </font></li>
</ul>
<p><font style="color:#DF2A3F;">注意，logc 并不是单纯的访问次数，而是访问</font><strong><font style="color:#DF2A3F;">频次（访问频率）</font></strong><font style="color:#DF2A3F;">，因为 </font><strong><font style="color:#DF2A3F;">logc 会随时间推移而衰减</font></strong><font style="color:#DF2A3F;">。</font></p>
<p><font style="color:#000000;">在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关：<br></font><font style="color:#000000;">如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大。<br></font><font style="color:#000000;">这种实现的 LFU 算法是根据</font><strong><font style="color:#000000;">访问频率</font></strong><font style="color:#000000;">来淘汰数据的，而不只是访问次数。<br></font><font style="color:#000000;">访问频率需要考虑 key 的访问是多长时间段内发生的。<br></font><font style="color:#000000;">key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地就会降低，这样被淘汰的概率也会更大。</font></p>
<p><font style="color:#000000;">对 logc 做完衰减操作后，就开始对 logc 进行增加操作。<br></font><font style="color:#000000;">增加操作并不是单纯的 +1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</font></p>
<p><font style="color:#000000;">所以，Redis 在访问 key 时，对于 logc 是这样变化的：<br></font><font style="color:#000000;">1️⃣</font><font style="color:#000000;"> 先按照上次访问间隔当前的时长，来对 logc 进行衰减；<br></font><font style="color:#000000;">2️⃣</font><font style="color:#000000;"> 然后，再按照一定概率增加 logc 的值。</font></p>
<p><code>&lt;font style=&quot;color:#000000;&quot;&gt;redis.conf&lt;/font&gt;</code><font style="color:#000000;"> 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</font></p>
<ul>
<li><strong><font style="color:#000000;">lfu-decay-time</font></strong><font style="color:#000000;">：用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为 1；lfu-decay-time 越大，衰减越慢。</font></li>
<li><strong><font style="color:#000000;">lfu-log-factor</font></strong><font style="color:#000000;">：用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</font></li>
</ul>
<p><font style="color:#DF2A3F;">  </font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/Hset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/Hset/" class="post-title-link" itemprop="url">Hset</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Hset 底层数据结构是由listpack或hash表实现的,当数据较少时并且所有数据数据量少于64字节(默认值可配置)采用listpack ,数据较大时采用hash来实现</p>
<h2 id="Redis-怎么用它表示一个hash"><a href="#Redis-怎么用它表示一个hash" class="headerlink" title="Redis 怎么用它表示一个hash"></a>Redis 怎么用它表示一个hash</h2><p> 很巧妙：<strong>Redis 把每个 key-value 对依次塞进 listpack 里</strong>，也就是：  </p>
<p>[key1, value1, key2, value2, key3, value3, …]</p>
<p>换句话说：</p>
<ul>
<li>奇数位置是 key；</li>
<li>偶数位置是 value。</li>
</ul>
<p>这就是 Redis 的“小型哈希”在内存中的真实样子。</p>
<p> 查找时 Redis 会顺序扫描（O(N)），但因为数据很小，这样反而更快、更省内存。  </p>
<h2 id="这样设计的优点"><a href="#这样设计的优点" class="headerlink" title="这样设计的优点"></a>这样设计的优点</h2><table>
<thead>
<tr>
<th>特点</th>
<th>listpack 编码（小hash）</th>
<th>hashtable 编码（大hash）</th>
</tr>
</thead>
<tbody><tr>
<td>内存占用</td>
<td>极小（紧凑连续）</td>
<td>较大（多层结构）</td>
</tr>
<tr>
<td>查找复杂度</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>场景</td>
<td>小、短、频繁创建销毁的哈希对象</td>
<td>大、长期存在的哈希对象</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" class="post-title-link" itemprop="url">索引失效</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E7%B4%A2%E5%BC%95/" itemprop="url" rel="index"><span itemprop="name">索引</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="先理解innodb的索引结构"><a href="#先理解innodb的索引结构" class="headerlink" title="先理解innodb的索引结构"></a>先理解innodb的索引结构</h2><p>主键索引(聚簇索引)</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760781099298-f66eea9b-9958-4ca8-9b27-4e1b1a4fa166.png"></p>
<p>二级索引（非聚簇索引）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760781118261-b761d5f5-7ef5-4f72-adfb-95351a8d3d93.png"></p>
<h2 id="索引失效的原因"><a href="#索引失效的原因" class="headerlink" title="索引失效的原因"></a>索引失效的原因</h2><h3 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就i是like %xx 或者like %xx% 这两种方式都会造成索引失效</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">索引优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E7%B4%A2%E5%BC%95/" itemprop="url" rel="index"><span itemprop="name">索引</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h1><p>对字符串字段的前 N 个字符建立索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX(name(10))</span><br></pre></td></tr></table></figure>

<p>好处：减少索引体积，提高查询性能。</p>
<h1 id="覆盖索引优化（联合索引）"><a href="#覆盖索引优化（联合索引）" class="headerlink" title="覆盖索引优化（联合索引）"></a>覆盖索引优化（联合索引）</h1><p>查询所需字段全部在索引中即可，不用回表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二级索引（字段1、字段2...）的叶子节点即可取到所有需要的数据</span><br></pre></td></tr></table></figure>

<p>好处：减少大量随机 I&#x2F;O，不回表最省性能。</p>
<h1 id="主键索引自增"><a href="#主键索引自增" class="headerlink" title="主键索引自增"></a>主键索引自增</h1><h2 id="1-InnoDB-的主键是聚簇索引"><a href="#1-InnoDB-的主键是聚簇索引" class="headerlink" title="1. InnoDB 的主键是聚簇索引"></a>1. InnoDB 的主键是聚簇索引</h2><ul>
<li>数据行按主键顺序存储在 B+Tree 叶子节点中。</li>
<li>主键顺序决定数据的真实物理存储顺序。</li>
</ul>
<h2 id="2-自增主键的优势"><a href="#2-自增主键的优势" class="headerlink" title="2. 自增主键的优势"></a>2. 自增主键的优势</h2><ol>
<li>所有插入都是“顺序追加”</li>
</ol>
<ul>
<li>新记录的主键值越来越大 → 永远插入到最后一页。</li>
<li>页满了再自动开新页，不需要移动旧数据。</li>
</ul>
<ol start="2">
<li>不会产生页分裂</li>
</ol>
<p>页分裂是什么？</p>
<ul>
<li>当在某个页的“中间位置”插入新记录时，数据空间不够，就需要拆成两个页，并移动部分记录。</li>
</ul>
<p>自增主键永远插在尾部 → <strong>不会触发页分裂</strong>。</p>
<h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><p><font style="color:rgb(44, 62, 80);">假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763783493528-b9d8a21c-edc6-4868-8bc0-d7ec39b929b9.png"></p>
<p><font style="color:rgb(44, 62, 80);">出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</font></p>
<p><font style="color:rgb(44, 62, 80);">而如果记录是顺序插入的，例如插入数据11，</font><font style="color:rgb(44, 62, 80);">则只需开辟新的数据页，也就不会发生页分裂：</font></p>
<font style="color:rgb(44, 62, 80);">  
</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2025/png/50543647/1763783528247-2ce56374-6fc7-4bfb-98d3-790646a50a09.png)
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E4%BB%8E%E7%A3%81%E7%9B%98%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3mysql_%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E4%BB%8E%E7%A3%81%E7%9B%98%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3mysql_%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">从磁盘角度理解mysql 索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E7%B4%A2%E5%BC%95/" itemprop="url" rel="index"><span itemprop="name">索引</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760777445096-2722feb3-a908-442b-8dea-dcf575adf14a.png"></p>
<h3 id="一、磁盘与-I-O-的基础概念"><a href="#一、磁盘与-I-O-的基础概念" class="headerlink" title="一、磁盘与 I&#x2F;O 的基础概念"></a>一、磁盘与 I&#x2F;O 的基础概念</h3><p>磁盘的最小读写单元是 <strong>扇区（Sector）</strong>，通常大小为 <strong>512 字节</strong>。<br>操作系统以 <strong>页（Page）</strong> 为单位读写数据（MySQL 默认页大小为 16KB）。</p>
<p>为了方便理解，这里以扇区为例模拟磁盘读写。</p>
<h3 id="二、没有索引时：全表扫描"><a href="#二、没有索引时：全表扫描" class="headerlink" title="二、没有索引时：全表扫描"></a>二、没有索引时：全表扫描</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760777482567-fd59e418-8aa8-47d8-afcd-76d5f87e0138.png"></p>
<p>假设：</p>
<ul>
<li>每行数据大小为 <strong>128 字节</strong>；</li>
<li>一张表有 <strong>800 行数据</strong>；</li>
<li>磁盘每个扇区大小为 <strong>512 字节</strong>。</li>
</ul>
<p> 总数据量为：  800 × 128 &#x3D; 102,400 字节</p>
<p>每个扇区能存放：512 ÷ 128 &#x3D; 4 行数据</p>
<p> 因此需要：  800 ÷ 4 &#x3D; 200 个扇区</p>
<p> 如果没有索引，MySQL 查询时必须扫描全部 200 个扇区，也就是 <strong>200 次磁盘 I&#x2F;O</strong>。  </p>
<h3 id="三、引入索引：减少磁盘-I-O"><a href="#三、引入索引：减少磁盘-I-O" class="headerlink" title="三、引入索引：减少磁盘 I&#x2F;O"></a>三、引入索引：减少磁盘 I&#x2F;O</h3><p>键值（key） → 数据所在磁盘页的地址（pointer）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760777621855-077c911f-e2eb-416a-979c-0f0881d0654b.png"></p>
<p>所以此时就就将200次磁盘io变为了现在索引中查找100*128&#x2F;512 在索引中找的的数据进行查找</p>
<p>同样的我们可以在进行二级索引,三级索引…减少磁盘io</p>
<h3 id="四、多级索引：B-Tree-结构的出现"><a href="#四、多级索引：B-Tree-结构的出现" class="headerlink" title="四、多级索引：B+Tree 结构的出现"></a>四、多级索引：B+Tree 结构的出现</h3><p>当索引记录本身也很大时（例如几百万条），<br>我们还可以在索引上再建索引 —— 即 <strong>多级索引</strong>。<br>这就形成了 MySQL 的 <strong>B+Tree 索引结构</strong>。</p>
<p>每一层索引都存储下一层节点的磁盘地址。<br>通过分层目录结构，MySQL 可以在 3～4 次磁盘 I&#x2F;O 内定位到目标数据</p>
<h3 id="五、B-Tree-查找过程示例"><a href="#五、B-Tree-查找过程示例" class="headerlink" title="五、B+Tree 查找过程示例"></a>五、B+Tree 查找过程示例</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760778577127-29a8bdf3-5ed7-4c0a-9de7-38c69ab412b9.png"></p>
<h3 id="查找步骤："><a href="#查找步骤：" class="headerlink" title="查找步骤："></a>查找步骤：</h3><ol>
<li>在根节点中找到 <code>33 &lt; 37 &lt; 65</code>，进入对应的下层节点；</li>
<li>在第二层节点中锁定包含 37 的区间；</li>
<li>到叶子节点中精确查找 <code>id=37</code>；</li>
<li>如果是 <strong>聚簇索引</strong>，叶子节点直接存放数据；<br>如果是 <strong>二级索引</strong>，叶子节点存放主键值，再回表查找数据。</li>
</ol>
<p>🔹 访问树的每一层都需要一次磁盘 I&#x2F;O；<br>通常 B+Tree 高度为 3～4 层，<br>所以 MySQL 只需 3～4 次 I&#x2F;O 就能定位到任意记录。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760778600374-90c4805d-457c-470d-98c7-5f998a1856ef.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
