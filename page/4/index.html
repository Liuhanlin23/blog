<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="刘翰霖">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="刘翰霖">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘翰霖">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>刘翰霖</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<meta name="referrer" content="no-referrer">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">刘翰霖</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘翰霖</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">数据库和缓存如何保证一致性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>_ 数据库与缓存的强一致性其实是一个伪命题。既然引入缓存是为了提高系统的并发性能，就必须接受两者之间__<strong>可能存在短暂不一致</strong><strong>的事实。<br>因此，我们的目标不是追求完全一致，而是</strong><strong>尽可能保证最终一致性</strong><strong>。<br>在当前实践中，最稳妥、通用的做法是：</strong><strong>先更新数据库，再删除缓存（Cache-Aside 模式）</strong>__，这样可以最大程度地降低数据不一致的风险。  _</p>
<h2 id="先更新数据库还是先更新缓存"><a href="#先更新数据库还是先更新缓存" class="headerlink" title="先更新数据库还是先更新缓存"></a>先更新数据库还是先更新缓存</h2><p> 当执行写操作时，无论是<strong>先更新数据库再更新缓存</strong>，还是<strong>先更新缓存再更新数据库</strong>，都可能导致<strong>数据库与缓存数据不一致</strong>的问题。  </p>
<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760857257593-45414a73-5251-4100-ae53-01c13ed45062.png"></p>
<p>举个例子，比如有A,B两个请求同时更新同一条数据，则可能出现这样的顺序</p>
<p>A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。</p>
<p>此时，数据库中的数据是 2，而缓存中的数据却是 1，<strong>出现了缓存和数据库中的数据不一致的现象。</strong></p>
<h3 id="先更新缓存再更新数据库"><a href="#先更新缓存再更新数据库" class="headerlink" title="先更新缓存再更新数据库"></a>先更新缓存再更新数据库</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760857381327-125861e6-888d-4faf-b492-47d0122254cb.png">A 请求先将缓存的数据更新为 1，然后在更新数据库前，B 请求来了，将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 A 请求将数据库的数据更新为 1。</p>
<p>此时，数据库中的数据是 1，而缓存中的数据却是 2，<strong>出现了缓存和数据库中的数据不一致的现象。</strong></p>
<p>所以，<strong>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」</strong>，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p>
<h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><p><strong>最好的方式还是先更新数据库再删除缓存</strong></p>
<h3 id="先更新数据库再删除缓存"><a href="#先更新数据库再删除缓存" class="headerlink" title="先更新数据库再删除缓存"></a>先更新数据库再删除缓存</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760858210694-457dfc38-b9eb-4a05-8643-25787beaea1c.png"></p>
<p><font style="color:rgb(44, 62, 80);">假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。</font><strong><font style="color:rgb(48, 79, 254);">但是在实际中，这个问题出现的概率并不高</font></strong><font style="color:rgb(44, 62, 80);">。</font></p>
<p><strong><font style="color:rgb(48, 79, 254);">因为缓存的写入通常要远远快于数据库的写入</font></strong><font style="color:rgb(44, 62, 80);">，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</font></p>
<p><font style="color:rgb(44, 62, 80);">而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</font></p>
<p><font style="color:rgb(44, 62, 80);">所以，</font><strong><font style="color:rgb(48, 79, 254);">「先更新数据库 + 再删除缓存」的方案，是可以很大程度保证数据一致性的</font></strong><font style="color:rgb(44, 62, 80);">。</font></p>
<p><font style="color:rgb(44, 62, 80);">并且实际中我们也会为缓存加上过期时间，如果出现数据库和缓存不一致，也是再这个时间呢，最终还是可以实现一致性</font></p>
<h4 id="如何应对缓存删除失败"><a href="#如何应对缓存删除失败" class="headerlink" title="如何应对缓存删除失败"></a><font style="color:rgb(44, 62, 80);">如何应对缓存删除失败</font></h4><p>假设我么再更新完数据库后删除缓存失败了，导致缓存还是旧值，不又会出现缓存数据不一致么？所以针对这个问题有两个解决方案</p>
<h5 id="1-消息队列重试机制"><a href="#1-消息队列重试机制" class="headerlink" title="1.消息队列重试机制"></a>1.消息队列重试机制</h5><p><font style="color:rgb(44, 62, 80);">我们可以引入</font><strong><font style="color:rgb(48, 79, 254);">消息队列</font></strong><font style="color:rgb(44, 62, 80);">，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。保证并发能力的同时又一定程度的避免缓存删除失败出现的缓存数据不一致</font></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">如果应用</font><strong><font style="color:rgb(48, 79, 254);">删除缓存失败</font></strong><font style="color:rgb(44, 62, 80);">，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是</font><strong><font style="color:rgb(48, 79, 254);">重试机制</font></strong><font style="color:rgb(44, 62, 80);">。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</font></li>
<li><font style="color:rgb(44, 62, 80);">如果</font><strong><font style="color:rgb(48, 79, 254);">删除缓存成功</font></strong><font style="color:rgb(44, 62, 80);">，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</font></li>
</ul>
<p>缺点：<font style="color:rgb(44, 62, 80);">对代码入侵性比较强，因为需要改造原本业务的代码。</font></p>
<h5 id="订阅mysql-binlog，再操作删除"><a href="#订阅mysql-binlog，再操作删除" class="headerlink" title="订阅mysql binlog，再操作删除"></a>订阅mysql binlog，再操作删除</h5><p><font style="color:rgb(44, 62, 80);">「</font><strong><font style="color:rgb(48, 79, 254);">先更新数据库，再删缓存</font></strong><font style="color:rgb(44, 62, 80);">」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</font></p>
<h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a><font style="color:rgb(44, 62, 80);">先删除缓存，再更新数据库</font></h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760858396753-dfbe5a38-281c-45fc-bf86-d07ff31fe8ea.png"></p>
<p>再来看看先删除缓存，再更新数据库</p>
<p><font style="color:rgb(44, 62, 80);">假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</font></p>
<p><font style="color:rgb(44, 62, 80);">最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</font></p>
<p><font style="color:rgb(44, 62, 80);">可以看到，</font><strong><font style="color:rgb(48, 79, 254);">先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</font></strong><font style="color:rgb(44, 62, 80);">。</font></p>
<h4 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a><font style="color:rgb(44, 62, 80);">延迟双删</font></h4><p><em>这个方案是有待商榷的，知识网上有这样的言论，在实际开发中可以忽略这个方案</em></p>
<p><font style="color:rgb(44, 62, 80);">针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「</font><strong><font style="color:rgb(48, 79, 254);">延迟双删</font></strong><font style="color:rgb(44, 62, 80);">」。</font></p>
<p><font style="color:rgb(44, 62, 80);">延迟双删实现的伪代码如下：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760858663392-a7a0e5d3-72b5-4955-b3d6-a1ffa7830af4.png"></p>
<p><font style="color:rgb(44, 62, 80);">加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。</font></p>
<p><font style="color:rgb(44, 62, 80);">所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。</font></p>
<p><font style="color:rgb(44, 62, 80);">但是这个睡眠时间就很难设定，设定太大了会导致并发能力下降，太小了就又会容易出现数据库缓存不一致问题，所以还是建议采用像更新数据库，再删除缓存的方案</font></p>
<p><font style="color:rgb(44, 62, 80);"></font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">哈希表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>redis 中的hash表数据结构就是一个正常的哈希表采用<strong>链式哈希</strong>来解决哈希冲突</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539193121-5c42e9fe-e3e5-4db4-a7f2-ba3afe433d1c.png">如图dictht 指向一个哈希表的数组,数组中每个元素都是一个哈希表节点的链表</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>redis的哈希表有一个 特点就是一个哈希表结构体中定义了两个哈希表，<font style="color:rgb(44, 62, 80);">之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539292770-805ea47d-cbd6-4894-9afe-272a166d6f28.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539328496-c26f66ec-9eca-4646-a7ab-6fac98d90ad1.png"></p>
<h3 id="渐进式hash"><a href="#渐进式hash" class="headerlink" title="渐进式hash"></a>渐进式hash</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539601585-aa657ad0-eca8-41a2-81d6-d9e289855d27.png"></p>
<h3 id="rehash的触发条件"><a href="#rehash的触发条件" class="headerlink" title="rehash的触发条件"></a>rehash的触发条件</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760539624416-d50fac17-c054-44b3-a616-ec241a4307a7.png"></p>
<p><strong><font style="color:rgb(48, 79, 254);"></font></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/ZSET/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/ZSET/" class="post-title-link" itemprop="url">ZSET</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-什么是zset"><a href="#一-什么是zset" class="headerlink" title="一.什么是zset"></a>一.什么是zset</h1><p> Redis 中的 **ZSet（Sorted Set，有序集合） ,它在集合（Set）的基础上，为每个元素关联了一个 score（分数），并且所有元素会根据这个分数自动 从小到大排序。  **</p>
<p>** 非常适合用来做排行榜、延时队列、优先级任务、推荐系统等场景。  **</p>
<h1 id="二-zset的常用命令"><a href="#二-zset的常用命令" class="headerlink" title="二.zset的常用命令"></a>二.zset的常用命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member [score member ...]</code></td>
<td>添加元素及其分数</td>
<td><code>ZADD rank 100 user1 90 user2</code></td>
</tr>
<tr>
<td><code>ZRANGE key start stop [WITHSCORES]</code></td>
<td>按排名升序取值</td>
<td><code>ZRANGE rank 0 2 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZREVRANGE key start stop [WITHSCORES]</code></td>
<td>按排名降序取值</td>
<td><code>ZREVRANGE rank 0 2 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>查询指定成员的分数</td>
<td><code>ZSCORE rank user1</code></td>
</tr>
<tr>
<td><code>ZINCRBY key increment member</code></td>
<td>增加某个成员的分数</td>
<td><code>ZINCRBY rank 10 user1</code></td>
</tr>
<tr>
<td><code>ZREM key member [member ...]</code></td>
<td>删除元素</td>
<td><code>ZREM rank user2</code></td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取集合中元素个数</td>
<td><code>ZCARD rank</code></td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>获取成员的升序排名</td>
<td><code>ZRANK rank user1</code></td>
</tr>
<tr>
<td><code>ZREVRANK key member</code></td>
<td>获取成员的降序排名</td>
<td><code>ZREVRANK rank user1</code></td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></td>
<td>按分数范围取值</td>
<td><code>ZRANGEBYSCORE rank 50 100 WITHSCORES</code></td>
</tr>
<tr>
<td><code>ZREMrangeByScore key min max</code></td>
<td>删除某个分数区间的成员</td>
<td><code>ZREMRANGEBYSCORE rank 0 50</code></td>
</tr>
</tbody></table>
<p>三.zset的底层数据结构</p>
<p><strong>ZSet 底层使用跳表（SkipList）实现，而不是平衡树。</strong><br>跳表通过多层索引结构实现平均 O(log n) 的查找效率，与平衡树相同，但结构更简单、插入删除更高效。  </p>
<h2 id="redis-中zset为什么使用跳表而不是平衡树"><a href="#redis-中zset为什么使用跳表而不是平衡树" class="headerlink" title="redis 中zset为什么使用跳表而不是平衡树"></a>redis 中zset为什么使用跳表而不是平衡树</h2><ol>
<li>从内存角度看，跳表比平衡树更省空间：跳表节点平均仅需约两个指针（前后），而平衡树节点通常要维护三个指针（左、右、父）  </li>
<li>跳表底层是<strong>有序链表</strong>，范围查询可从起点一路向后遍历，<br>复杂度 O(log n + k)，实现简单；平衡树则需进行<strong>中序遍历</strong>。</li>
<li><strong>实现更简单、维护成本低</strong>：跳表更新删除只需要变动指针即可；平衡树必须通过<strong>旋转操作</strong>维持结构平衡，逻辑繁琐、实现复杂。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/ZipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/ZipList/" class="post-title-link" itemprop="url">ZipList</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">压缩列表</font></strong></a><strong><font style="color:rgb(25, 27, 31);">（</font></strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=ziplist&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">ziplist</font></strong></a><strong><font style="color:rgb(25, 27, 31);">）本质上就是一个字节数组，是</font></strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=171555619&content_type=Article&match_order=1&q=Redis&zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">Redis</font></strong></a><strong><font style="color:rgb(25, 27, 31);">为了节约内存而设计的一种线性数据结构</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760537667649-decf9823-34b3-449a-997e-315d61f152ec.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760537684492-157cd6b7-4198-4169-8ffb-7d15c239aada.png"></p>
<p><strong><font style="color:rgb(25, 27, 31);">而压缩列表节点又有三个属性组成，分别是previous_entry_length，encoding，content</font></strong><font style="color:rgb(25, 27, 31);">。</font></p>
<ol>
<li><strong><font style="color:rgb(25, 27, 31);">previous_entry_length</font></strong></li>
</ol>
<p><font style="color:rgb(25, 27, 31);">这个属性记录了压缩列表前一个节点的长度，用于实现“链表的向前查找”</font></p>
<p><font style="color:rgb(25, 27, 31);">这个属性记录了压缩列表前一个节点的长度，</font><strong><font style="color:rgb(25, 27, 31);">该属性根据前一个节点的大小不同可以是1个字节或者5个字节。</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">如果前一个节点的长度小于254个字节，那么previous_entry_length的大小为1个字节，</font><strong><font style="color:rgb(25, 27, 31);">即前一个节点的长度可以使用1个字节表示</font></strong></p>
<p><font style="color:rgb(25, 27, 31);">如果前一个节点的长度大于等于254个字节，那么previous_entry_length的大小为5个字节</font><strong><font style="color:rgb(25, 27, 31);">，第一个字节会被设置为0xFE(十进制的254），之后的四个字节则用于保存前一个节点的长度。</font></strong></p>
<ol start="2">
<li><strong><font style="color:rgb(25, 27, 31);">encoding</font></strong></li>
</ol>
<p><strong>当前节点的数据类型与长度编码信息</strong><strong><font style="color:rgb(25, 27, 31);">。  </font></strong></p>
<p>它的作用是告诉 Redis：</p>
<p><strong><font style="color:rgb(25, 27, 31);">“当前节点的内容（content）是字符串还是整数？如果是字符串，它的长度是多少？如果是整数，是哪种整数类型？”</font></strong></p>
<ol start="3">
<li><strong><font style="color:rgb(25, 27, 31);">content</font></strong></li>
</ol>
<p><strong><font style="color:rgb(25, 27, 31);">content属性负责保存节点的值，值的具体类型由上一个字段encoding来决定。</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760538093497-b652385b-6c44-454b-a413-24fbd791ee9b.png"></p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p><strong><font style="color:rgb(25, 27, 31);">当添加或删除节点时，可能就会因为previous_entry_length的变化导致发生连锁的更新操作。</font></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/redis_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/redis_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">redis 线程模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>主线程：唯一负责命令解析&#x2F;执行、数据结构操作、事件循环调度、AOF&#x2F;RDB 触发等“核心逻辑”。（也就是真正执行读写操作的线程）</li>
<li>网络io线程，多个网络io线程处理网络io</li>
<li>BIO 线程池（处理慢io的线程池）：固定几个后台线程处理慢 IO（aof fsync、close&#x2F;open、lazy-free 等），避免主线程被阻塞。比如说当写回策略是Everysec 的时候就由慢io线程池调用fsync 方法将AOF内核缓冲区刷新到磁盘中</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/redis_%E5%A4%A7key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/redis_%E5%A4%A7key/" class="post-title-link" itemprop="url">redis 大key</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis-的大key-会引发什么问题"><a href="#redis-的大key-会引发什么问题" class="headerlink" title="redis 的大key 会引发什么问题"></a>redis 的大key 会引发什么问题</h1><h2 id="大key-对AOF的影响"><a href="#大key-对AOF的影响" class="headerlink" title="大key 对AOF的影响"></a>大key 对AOF的影响</h2><ol>
<li>如果使用always写回策略，那么由主线程同步调用fsync（）方法，对于大key的写入很耗时，会造成阻塞</li>
<li>如果是Everysec或no 策略则不会影响主线程，因为Everysec 由慢IO线程池异步调用fsync，no策略是由OS自主调用fsync</li>
</ol>
<h2 id="大Key对AOF重写和RDB的影响"><a href="#大Key对AOF重写和RDB的影响" class="headerlink" title="大Key对AOF重写和RDB的影响"></a>大Key对AOF重写和RDB的影响</h2><h3 id="容易触发AOF重写-当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写"><a href="#容易触发AOF重写-当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写" class="headerlink" title="容易触发AOF重写:当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写"></a><font style="color:#DF2A3F;">容易触发AOF重写:</font>当AOF日志写入了很多大key，AOF日志文件会迅速增大，会很快触发AOF重写</h3><h3 id="创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；"><a href="#创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；" class="headerlink" title="创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；"></a><font style="color:rgb(44, 62, 80);">创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</font></h3><p>Redis 在执行 AOF 重写或 RDB 快照时需要 <code>fork()</code> 创建子进程。<code>fork()</code> 会将父进程的整张页表复制一份给子进程，因此当实例中存在大量大 key、占用内存页很多时，页表规模会变得很大，导致页表复制过程耗时严重，从而使 <code>fork()</code> 阻塞主线程。</p>
<p>例如你用一个 <strong>大 key</strong> 存了 500MB 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET bigkey &lt;500MB value&gt;</span><br></pre></td></tr></table></figure>

<p>那么 Redis 进程就会多出 <strong>500MB 内存占用</strong>。</p>
<p>而操作系统管理内存的单位是 <strong>页（page）</strong>，一般是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 页 = 4KB</span><br></pre></td></tr></table></figure>

<p>那么 500MB 大概需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500MB / 4KB ≈ 128,000 个页</span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<p>Redis 必须创建 <strong>128,000 个页表项</strong> 来记录这些映射关系。</p>
<p>因此：</p>
<p><strong>大 Key 必然导致页表变大，因为大 Key 占用更多内存页，而每一个页都要一个页表项。</strong></p>
<h3 id="创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长"><a href="#创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长" class="headerlink" title="创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长"></a><font style="color:rgb(44, 62, 80);">创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长</font></h3><h2 id="大key-除了影响持久化外，还会有一下影响"><a href="#大key-除了影响持久化外，还会有一下影响" class="headerlink" title="大key 除了影响持久化外，还会有一下影响"></a>大key 除了影响持久化外，还会有一下影响</h2><ol>
<li><font style="color:rgb(44, 62, 80);">客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</font></li>
<li><font style="color:rgb(44, 62, 80);">引发网络阻塞。每次获取大 key 产生的网络流量较大，引发网络阻塞。每次获取大 key 产生的网络流量较大，这对于普通千兆网卡的服务器来说是灾难性的。</font></li>
<li><font style="color:rgb(44, 62, 80);">使用del删除大 key 时，会阻塞工作线程（建议使用unlink 命令删除大key）</font></li>
</ol>
<h1 id="如何避免大key呢"><a href="#如何避免大key呢" class="headerlink" title="如何避免大key呢"></a><font style="color:rgb(44, 62, 80);">如何避免大key呢</font></h1><ol>
<li>在设计阶段，尽量把大key 拆成很多小key</li>
<li>不要使用del命令删除大key，该命令会阻塞主线程，使用unlink（redis4.0）命令删除（ 主线程只负责将 key 从字典中移除，不会阻塞  ，真正的内存释放由后台慢IO线程池完成）</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/redis_%E4%B8%AD%E7%9A%84LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/redis_%E4%B8%AD%E7%9A%84LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">redis 中的LRU和LFU算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>LRU算法全称是Latest Recently Used 最近最少使用，最选择淘汰最近最少使用的数据</p>
<h3 id="传统LRU的实现"><a href="#传统LRU的实现" class="headerlink" title="传统LRU的实现"></a>传统LRU的实现</h3><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<h3 id="redis-如何实现LRU"><a href="#redis-如何实现LRU" class="headerlink" title="redis 如何实现LRU"></a>redis 如何实现LRU</h3><p>redis 实现的是一种近似的LRU算法，目的是为了更好的节约内存，它的实现方式是在Redis的对象结构体中添加一个额外的字段，用于记录数据的最后一次访问时间</p>
<p>当Redis 进行内存淘汰的时候，会使用<strong>随机采样</strong>的方法来淘汰数据，就是随机取5个值（此值可配），然后淘汰最久没有使用的那个</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p>
<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>LFU 全称是 Least Frequently Used，翻译为<strong>最近最不常用</strong>。<br>LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是：“如果数据过去被访问得多次，那么将来被访问的频率也更高。”</p>
<p> 所以，LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据仍然在缓存中长期占用的问题。**所以作为缓存数据库，相比于 LRU 算法，LFU 算法更加合理。 ** </p>
<h3 id="redisLFU的实现"><a href="#redisLFU的实现" class="headerlink" title="redisLFU的实现"></a>redisLFU的实现</h3><p> LFU 算法相对于 LRU 算法的实现，多记录了「<strong>数据的访问频次</strong>」的信息（<font style="color:#DF2A3F;">是访问频次不是访问次数！！！</font>）。<br>Redis 对象的结构如下：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760854468519-f5cc7c5a-4549-4b63-ae0d-d1109e89c61e.png"></p>
<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis 可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长短，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt（Last Decrement Time），低 8bit 存储 logc（Logistic Counter）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760854505771-8999f755-382a-4261-9426-e1f99c6476df.png"></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">ldt 是用来记录 key 的访问时间戳；</font></li>
<li><strong>logc</strong><font style="color:rgb(44, 62, 80);"> 是用来记录 key 的</font><font style="color:#DF2A3F;">访问频次</font><font style="color:rgb(44, 62, 80);">，它的值越小表示使用频率越低，越容易淘汰。每个新加入的 key 的 logc 初始值为 5。  </font></li>
</ul>
<p><font style="color:#DF2A3F;">注意，logc 并不是单纯的访问次数，而是访问</font><strong><font style="color:#DF2A3F;">频次（访问频率）</font></strong><font style="color:#DF2A3F;">，因为 </font><strong><font style="color:#DF2A3F;">logc 会随时间推移而衰减</font></strong><font style="color:#DF2A3F;">。</font></p>
<p><font style="color:#000000;">在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关：<br></font><font style="color:#000000;">如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大。<br></font><font style="color:#000000;">这种实现的 LFU 算法是根据</font><strong><font style="color:#000000;">访问频率</font></strong><font style="color:#000000;">来淘汰数据的，而不只是访问次数。<br></font><font style="color:#000000;">访问频率需要考虑 key 的访问是多长时间段内发生的。<br></font><font style="color:#000000;">key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地就会降低，这样被淘汰的概率也会更大。</font></p>
<p><font style="color:#000000;">对 logc 做完衰减操作后，就开始对 logc 进行增加操作。<br></font><font style="color:#000000;">增加操作并不是单纯的 +1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</font></p>
<p><font style="color:#000000;">所以，Redis 在访问 key 时，对于 logc 是这样变化的：<br></font><font style="color:#000000;">1️⃣</font><font style="color:#000000;"> 先按照上次访问间隔当前的时长，来对 logc 进行衰减；<br></font><font style="color:#000000;">2️⃣</font><font style="color:#000000;"> 然后，再按照一定概率增加 logc 的值。</font></p>
<p><code>&lt;font style=&quot;color:#000000;&quot;&gt;redis.conf&lt;/font&gt;</code><font style="color:#000000;"> 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</font></p>
<ul>
<li><strong><font style="color:#000000;">lfu-decay-time</font></strong><font style="color:#000000;">：用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为 1；lfu-decay-time 越大，衰减越慢。</font></li>
<li><strong><font style="color:#000000;">lfu-log-factor</font></strong><font style="color:#000000;">：用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</font></li>
</ul>
<p><font style="color:#DF2A3F;">  </font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/Redis/Hset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/Redis/Hset/" class="post-title-link" itemprop="url">Hset</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Hset 底层数据结构是由listpack或hash表实现的,当数据较少时并且所有数据数据量少于64字节(默认值可配置)采用listpack ,数据较大时采用hash来实现</p>
<h2 id="Redis-怎么用它表示一个hash"><a href="#Redis-怎么用它表示一个hash" class="headerlink" title="Redis 怎么用它表示一个hash"></a>Redis 怎么用它表示一个hash</h2><p> 很巧妙：<strong>Redis 把每个 key-value 对依次塞进 listpack 里</strong>，也就是：  </p>
<p>[key1, value1, key2, value2, key3, value3, …]</p>
<p>换句话说：</p>
<ul>
<li>奇数位置是 key；</li>
<li>偶数位置是 value。</li>
</ul>
<p>这就是 Redis 的“小型哈希”在内存中的真实样子。</p>
<p> 查找时 Redis 会顺序扫描（O(N)），但因为数据很小，这样反而更快、更省内存。  </p>
<h2 id="这样设计的优点"><a href="#这样设计的优点" class="headerlink" title="这样设计的优点"></a>这样设计的优点</h2><table>
<thead>
<tr>
<th>特点</th>
<th>listpack 编码（小hash）</th>
<th>hashtable 编码（大hash）</th>
</tr>
</thead>
<tbody><tr>
<td>内存占用</td>
<td>极小（紧凑连续）</td>
<td>较大（多层结构）</td>
</tr>
<tr>
<td>查找复杂度</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>场景</td>
<td>小、短、频繁创建销毁的哈希对象</td>
<td>大、长期存在的哈希对象</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/" class="post-title-link" itemprop="url">索引失效</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E7%B4%A2%E5%BC%95/" itemprop="url" rel="index"><span itemprop="name">索引</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="先理解innodb的索引结构"><a href="#先理解innodb的索引结构" class="headerlink" title="先理解innodb的索引结构"></a>先理解innodb的索引结构</h2><p>主键索引(聚簇索引)</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760781099298-f66eea9b-9958-4ca8-9b27-4e1b1a4fa166.png"></p>
<p>二级索引（非聚簇索引）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1760781118261-b761d5f5-7ef5-4f72-adfb-95351a8d3d93.png"></p>
<h2 id="索引失效的原因"><a href="#索引失效的原因" class="headerlink" title="索引失效的原因"></a>索引失效的原因</h2><h3 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h3><p>当我们使用左或者左右模糊匹配的时候，也就i是like %xx 或者like %xx% 这两种方式都会造成索引失效</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘翰霖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘翰霖">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 刘翰霖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/25/MySQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">索引优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E7%B4%A2%E5%BC%95/" itemprop="url" rel="index"><span itemprop="name">索引</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h1><p>对字符串字段的前 N 个字符建立索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX(name(10))</span><br></pre></td></tr></table></figure>

<p>好处：减少索引体积，提高查询性能。</p>
<h1 id="覆盖索引优化（联合索引）"><a href="#覆盖索引优化（联合索引）" class="headerlink" title="覆盖索引优化（联合索引）"></a>覆盖索引优化（联合索引）</h1><p>查询所需字段全部在索引中即可，不用回表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二级索引（字段1、字段2...）的叶子节点即可取到所有需要的数据</span><br></pre></td></tr></table></figure>

<p>好处：减少大量随机 I&#x2F;O，不回表最省性能。</p>
<h1 id="主键索引自增"><a href="#主键索引自增" class="headerlink" title="主键索引自增"></a>主键索引自增</h1><h2 id="1-InnoDB-的主键是聚簇索引"><a href="#1-InnoDB-的主键是聚簇索引" class="headerlink" title="1. InnoDB 的主键是聚簇索引"></a>1. InnoDB 的主键是聚簇索引</h2><ul>
<li>数据行按主键顺序存储在 B+Tree 叶子节点中。</li>
<li>主键顺序决定数据的真实物理存储顺序。</li>
</ul>
<h2 id="2-自增主键的优势"><a href="#2-自增主键的优势" class="headerlink" title="2. 自增主键的优势"></a>2. 自增主键的优势</h2><ol>
<li>所有插入都是“顺序追加”</li>
</ol>
<ul>
<li>新记录的主键值越来越大 → 永远插入到最后一页。</li>
<li>页满了再自动开新页，不需要移动旧数据。</li>
</ul>
<ol start="2">
<li>不会产生页分裂</li>
</ol>
<p>页分裂是什么？</p>
<ul>
<li>当在某个页的“中间位置”插入新记录时，数据空间不够，就需要拆成两个页，并移动部分记录。</li>
</ul>
<p>自增主键永远插在尾部 → <strong>不会触发页分裂</strong>。</p>
<h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><p><font style="color:rgb(44, 62, 80);">假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/50543647/1763783493528-b9d8a21c-edc6-4868-8bc0-d7ec39b929b9.png"></p>
<p><font style="color:rgb(44, 62, 80);">出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</font></p>
<p><font style="color:rgb(44, 62, 80);">而如果记录是顺序插入的，例如插入数据11，</font><font style="color:rgb(44, 62, 80);">则只需开辟新的数据页，也就不会发生页分裂：</font></p>
<font style="color:rgb(44, 62, 80);">  
</font><font style="color:rgb(44, 62, 80);"> </font>![](https://cdn.nlark.com/yuque/0/2025/png/50543647/1763783528247-2ce56374-6fc7-4bfb-98d3-790646a50a09.png)
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">刘翰霖</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
